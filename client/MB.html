<!DOCTYPE html>
<!--
    Web page written by David Eck, http://math.hws.edu/eck/index.html
    You can do anything you like with this web page and with the code, but
    if you use a substantial portion of it, you should include attribution.

    This is a fairly complete "Mandelbrot Set" viewer program, including
    the ability to do arbitrary precision computation (very slowly) when you
    zoom in too far to do the calculations with regular floating point numbers.

    It can save and load examples as XML in a clunky way, by copy-and-paste
    between files and a textarea that appears when "Show XML Input/Export"
    is clicked.  All of the ideas and some of the code were ported from
    an older program that was written in java.

    This file depends on the scripts mandelbrot-worker-remote.js, mandelbrot-worker-local.js, slider.js, touch.js,
    and Daniel Trebbien's BigDecimal-all-last.min.js.

    August, 2019. Added Palette Editor.
    January, 2020. Improved Palette Editor.
    April, 2020.  Cleaned up standard palettes, removed a few, added Dark Colors palette.
    May, 2020.  Change maximum image width and height from 2500 to 10000 (but that
        doesn't necessarily mean very large images will work on every device).
    October, 2021.  Fixed a bug in startJob() and startSecondPass() that showed up
        when the change in y-value from one line to the next is very small.  This was
        done previously by successive subtraction, which introduced errors.  Thanks to
        Robert Munafo for finding and fixing the bug.
    August, 2022.  Use localStorage to save workerCount between sessions.

    Changes by Bill Wood:
    Jul/Aug 2019: Rewrote job processing to be client/server, also fixed y-value issue as above
                  Changed HP_CUTOFF from 16 to 15 to avoid artifacts at the limits of f64 precision
                  Added "High Precision" toggle and rows/second info
    Jan-Apr 2023: Rewrote JavaScript server in Rust to get 10-15 times speedup in high precision computations
                  When zooming, the zoomed area is displayed using image interpolation while calculations are done
                  Left, right, up, and down arrow key bindings shift the image appropriately; page down and page up zoom in and out
                  Max image width/height is now 7680 (8K)
                  Fixed off by factor of 10 error in zoom out by 10,000 and 100,000
                  Added option to run calculations locally on the browser in JavaScript, or on the backend Rust server
                  Added undo (ctrl-z) and redo (ctrl-shift-z and ctrl-y) key bindings
                  Fixed small bug where dx value was being used to increment yval instead of dy value in HP calculations
                  Rewrote browser-side computations from JavaScript to Rust WASM for 5-7 times speedup in high precision computations
                  Added interactive sliders for control of max iterations, zoom level, palette offset, etc.
                  Added undo/redo with image interpolation for zoom.
                  Added full window mode, activated with "f" and deactivated with "f" or escape.
                  Added full screen mode, activated with "F" and deactivated with "F", "f", or escape.
                  Added default "Fit Window" image size in place of old default 800x600 image size
                  Streamlined UI with Help and Examples at top
                  Optimized for mobile devices
                  Added touch controls for pan
                  Added touch controls for pinch to zoom out and spread to zoom in
                  Don't clear canvas every time image size changes
                  "Fit Window" now covers the whole window, controls are laid on top with transparency
                  Added progress circle in lower right
                  Remember current image settings across browser sessions
                  Added button to copy a permalink to the current image settings
-->
<html>
<head>
<meta name='viewport' content='width=device-width, height=device-height, user-scalable=no, initial-scale=1, minimum-scale=1, maximum-scale=1'/>
<meta charset="UTF-8">
<title>Mandelbrot Viewer</title>
<!--
<meta property="og:image" content="https://mandelbrot.xxxxxx.com/thumbnail.png"/>
<meta property="og:url" content="https://mandelbrot.xxxxxx.com/MB.html"/>
-->
<meta property="og:type" content="website"/>
<meta property="og:title" content="Mandelbrot Viewer" />
<meta property="og:description" content="This Mandelbrot viewer, originally by David Eck, has been rewritten with a Rust backend, considerably speeding it up."/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
<style type="text/css">
   body {
       background-color: #e8ecf3;
       font-family: Arial, sans-serif;
        /* disable pinch zoom in body */
       touch-action: pan-x pan-y;
   }
   canvas {
       display: block;
       background-color: #BBBBBB;
   }
    .fixedCanvas {
        border: 2px solid black;
    }
    .fullWindowCanvas {
        position: fixed;
        top: 0px;
        left: 0px;
        border: 0px;
    }
    .fullWindowCanvasFront {
        z-index: 8;
    }

    /* main UI grid */
    .mainUI {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 10px;
    }
    .col1 {
        grid-column: 1;
    }
    .col2 {
        grid-column: 2;
        grid-row: 1 / span 2;
        padding: 0px;
        margin-right: 8px;
    }

    .progressCircle {
        position: fixed;
        bottom: 10px;
        right: 10px;
        z-index: 8;
    }
    .displayNone {
        display: none;
    }

   #controls {
       display: inline-block;
       background-color: rgba(255, 255, 255, 0.6);
       /* border: 2px solid black; */
       padding: 0;
       border-radius: 8px;
       z-index: 5;
   }
   #controls p {
       margin: 12px 0;
       white-space: nowrap;
   }
   div.group {
       padding: 0px 6px;
       border-bottom: 1px solid rgba(0, 0, 0, 0.6);
   }
   div.grouplast {
       padding: 0px 6px;
   }
   #xmlimportbg {
       position: fixed;
       z-index: 10;
       opacity: 0.7;
       background-color: black;
       left: 0;
       top: 0;
       width: 100%;
       height: 100%;
       display: none;
   }
   #xmlimport, #paletteEditor {
       position: absolute;
       left: 35px;
       top: 100px;
       z-index:20;
       padding: 10px;
       background-color: #D8D8FF;
       border: 2px solid #000099;
       border-radius: 16px;
       box-shadow: 5px 5px 8px black;
       display: none;
   }
   textarea {
     white-space: pre;
     word-wrap: normal;
     overflow-x: scroll;
   }

    /* Style the tooltip container */
    .tooltip {
        position: relative;
        display: inline-block;
        font-weight: normal;
    }
    /* Style the tooltip text */
    .tooltip .helptext {
        visibility: hidden;
        width: 800px;
        background-color: rgba(255, 255, 255, 1);
        color: #000;
        text-align: left;
        border-radius: 8px;
        padding: 10px;
        position: absolute;
        font-size: 16px;
        font-weight: normal;
        top: 100%;
        left: 100%;
        transform: translateX(-51%);
        border: 1px solid black;
    }
    /* Show the tooltip text when hovering over the container */
    .tooltip:hover .helptext {
        visibility: visible;
    }
    /* Format the tooltip arrow */
    .tooltip .helptext::after {
        content: "";
        position: absolute;
        bottom: 100%;
        left: 50%;
        border-width:6px;
        border-style: solid;
        /* border-color: #555 transparent transparent transparent; */
        border-color: white transparent transparent transparent;
        filter: drop-shadow(0px 0px 2px rgba(0, 0, 0, 0.65));
    }
    /* Style the tooltip text */
    .tooltip .exampletext {
        visibility: hidden;
        width: 800px;
        background-color: rgba(255, 255, 255, 1);
        color: #000;
        text-align: left;
        border-radius: 8px;
        padding: 10px;
        position: absolute;
        font-size: 16px;
        font-weight: normal;
        top: 100%;
        left: 100%;
        transform: translateX(-28.5%);
        border: 1px solid black;
    }
    /* Show the tooltip text when hovering over the container */
    .tooltip:hover .exampletext {
        visibility: visible;
    }
    /* Format the tooltip arrow */
    .tooltip .exampletext::after {
        content: "";
        position: absolute;
        bottom: 100%;
        left: 29.5%;
        border-width: 6px;
        border-style: solid;
        /* border-color: #555 transparent transparent transparent; */
        border-color: white transparent transparent transparent;
        filter: drop-shadow(0px 0px 2px rgba(0, 0, 0, 0.65));
    }

    #home-icon {
        margin-left: 8px;
    }
    .svg-icon {
        cursor: pointer;
        transition-duration: 0.2s;
        color: white;
        filter: drop-shadow(0px 0px 2px rgba(0, 0, 0, 0.65));
        width: 34px;
        margin-top: 4px;
    }
    #header-table {
        position: relative; /* Required for z-index */
        border-collapse: separate; /* Recommended for border-radius */
        border-spacing: 0; /* Recommended for border-radius */
        background-color: rgba(255, 255, 255, 0.7);
        border-radius: 8px;
        z-index: 7;
        width: 100%;
        font-size: 20px;
        table-layout: fixed;
        text-align: left;
    }

    #examples td, #examples tr {
        margin: 0;
        padding: 0;
    }
    #examples {
        padding: 0;
        margin: 7px auto;
        border: 2px solid darkgray;
        border-spacing: 0;
    }
    #examples td {
        border: 2px solid darkgray;
        max-width: 33.33%;
    }
    #examples img, #examples a {
        max-width: 100%;
        height: auto;
        display: block;
    }

    .selectable {
        user-select: text;
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
    }
    .unselectable {
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
    }
  </style>
</style>

<script src="BigDecimal-all-last.min.js"></script>
<script src="slider.js"></script>
<script src="touch.js"></script>
<script src="percentage-complete.js"></script>
<script>

"use strict";

(function() {
    // load Google analytics, but only if web host is wpwoodjr domain; don't do analytics for other hosts
    if (window.location.hostname === "wpwoodjr.github.io") {
        // console.log("loading Google tag for domain", window.location.hostname);
        // <!-- Google tag (gtag.js) -->
        let script = document.createElement("script");
        script.src = "https://www.googletagmanager.com/gtag/js?id=G-7MMVRWY57P";
        script.async = true;
        document.head.appendChild(script);

        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-7MMVRWY57P');
    }
})();

var HP_CUTOFF_EXP = 15;
var HP_CUTOFF = new BigDecimal("1e-15");
var TEN = new BigDecimal("10");
var TWO = new BigDecimal("2");


var OSC;  // Off-screen canvas, holds the the Mandelbrot set.
var OSG;  // Graphics context for off-screen canvas.
var canvas;    // On-screen canvas -- shows OSC, with stuff possibly drawn on top.
var graphics;  // Graphics context for on-screen canvas.

var ArrayType = window.Uint32Array || Array;

var workers;
let jobNum = 0;

var running = false;
var repaintTimeout;
const repaintTimer = 750, repaintInitialTimer = 333;

var /* BigDecimal */ xmin_requested, ymin_requested, xmax_requested, ymax_requested;
var /* BigDecimal */ xmin, ymin, xmax, ymax;
var /* BigDecimal */ dx, dy;
var /* Uint32Array */ xminArray, yValArray, dxArray;

var jobs;
var workerCount = 1;
let jobStartTime;
let rowsCompleted, rowsPerSecond, jobsCompleted, jobsPerSecond;
var highPrecision;

var COMPUTING_FIRST_PASS = 1, DONE_FIRST_PASS = 2, COMPUTING_SECOND_PASS = 3, IDLE = 4;
var state = IDLE;

var dragbox = null;

let maxIterSlider, mainPaletteOffsetSlider, mainPaletteLengthSlider, paletteSelectSlider;
let zoomInSlider, zoomOutSlider;
let touch;

const statusText = {
    init: function() {
        this.statusHeader = new StatusText("status-header", "Idle", "#008cff");
        this.statusMessage = new StatusText("status-message", "Idle", "#AA0000");
    },
    updateText: function(text) {
        this.statusHeader.updateText(text);
        this.statusMessage.updateText(text);
    }
}

const progressCircle = {
    init: function(doSecondPass) {
        this.firstPassColor = "rgba(33, 150, 243, 0.6)";
        this.firstPassColorNoSecondPass = "rgba(38, 174, 255, 0.8)";
        this.secondPassColor = "rgba(255, 255, 255, 0.6)";
        this.transparentColor = "rgba(255, 255, 255, 0)";
        this.element = document.getElementById("progressCircle");
        this.circle = new ProgressCircle(this.element, this.firstPassColor, this.secondPassColor, 30, true);
        this.pass = 1;
        this.doSecondPass = doSecondPass;
    },
    setPercentage: function(percentage) {
        this.circle.setPercentage(1 - percentage);
    },
    setPass: function(pass, highPrecision) {
        this.pass = pass;
        if (pass === 1) {
            this.setFirstPassColors(this.doSecondPass);
        } else {
            this.circle.setForegroundColor(this.secondPassColor);
            this.circle.setBackgroundColor(this.transparentColor);
        }
        this.element.classList.remove("displayNone");
        const text = highPrecision ? "HP" : "";
        this.circle.updateText(text);
        this.setPercentage(0);
    },
    setFirstPassColors: function(doSecondPass) {
        this.doSecondPass = doSecondPass;
        if (this.pass === 1) {
            this.circle.setForegroundColor(doSecondPass ? this.firstPassColor : this.firstPassColorNoSecondPass);
            this.circle.setBackgroundColor(doSecondPass ? this.secondPassColor : this.transparentColor);
        }
    },
    hide: function() {
        this.element.classList.add("displayNone");
    }
}

let currentImageSize;
var palette;
var fixedPaletteLength;
var paletteLength;
var paletteColors;

var savedIterationCounts;
var savedIterationCounts2ndPass;

var imageData, hres, vres;  // for setting pixel colors.

var currentXML = null;

var undoList = null; // will be an array; null here prevents SetDefaults from adding a spurious undo item
var undoCount = 0;
var applyUndoInProgress = false;

var paletteEditInProgress = false;

var interlaced = getLocalStorageItem("interlaced", true);
var interlaceOrder = (function() {
      var order = [127];
      for (var i = 64; i >= 1; i /= 2) {
          var ct = order.length;
          for (var j = 0; j < ct; j++) {
              order.push(order[j] - i);
          }
      }
      return order;
   })();

var digits, chunks;
var /* BigDecimal */ twoTo16 = new BigDecimal("65536");
var log2of10 = Math.log(10)/Math.log(2);

let compute_mandelbrot;
WebAssembly
    .compileStreaming(fetch("mb-wasm.wasm"))
    .then(wasmModule => {
        compute_mandelbrot = wasmModule;
        init();
    });

function convert( /* int[] */ x, /* BigDecimal */ X, /* int */ count) {
    var neg = false;
    if (X.signum() == -1) {
        neg = true;
        X = X.negate();
    }
    x[0] = Number(X.setScale(0,BigDecimal.ROUND_DOWN).toString());
    for (var i = 1; i < count; i++) {
        X = X.subtract(new BigDecimal(""+x[i-1]));
        X = X.multiply(twoTo16);
        x[i] = Number(X.setScale(0,BigDecimal.ROUND_DOWN).toString());
    }
    if (neg) {
        negate(x,count);
    }
    function negate( /* int[] */ x, /* int */ chunks) {
        for (var i = 0; i < chunks; i++)
            x[i] = 0xFFFF-x[i];
        ++x[chunks-1];
        for (var i = chunks-1; i > 0 && (x[i] & 0x10000) != 0; i--) {
            x[i] &= 0xFFFF;
            ++x[i-1];
        }
        x[0] &= 0xFFFF;
    }
}

function setLimits(x1, x2, y1, y2, recordUndo) {
    var oldLimits = [xmin_requested,xmax_requested,ymin_requested,ymax_requested];
    xmin_requested = x1;
    xmax_requested = x2;
    ymin_requested = y1;
    ymax_requested = y2;
    if (xmax_requested.compareTo(xmin_requested) < 0) {
       var temp = xmin_requested;
       xmin_requested = xmax_requested;
       xmax_requested = temp;
    }
    if (ymax_requested.compareTo(ymin_requested) < 0) {
       var temp = ymax_requested;
       ymax_requested = ymin_requested;
       ymin_requested = temp;
    }
    checkAspect();
    if (recordUndo) {
        addUndoItem("Change Limits", oldLimits, [xmin_requested,xmax_requested,ymin_requested,ymax_requested]);
    }
}

function checkAspect() {  // adjust requested x/y limits to match aspect ratio of image
    xmin = xmin_requested;
    xmax = xmax_requested;
    ymin = ymin_requested;
    ymax = ymax_requested;
    if (xmin.scale() < HP_CUTOFF_EXP + 8)
        xmin = xmin.setScale(HP_CUTOFF_EXP + 8);
    if (xmax.scale() < HP_CUTOFF_EXP + 8)
        xmax = xmax.setScale(HP_CUTOFF_EXP + 8);
    if (ymin.scale() < HP_CUTOFF_EXP + 8)
        ymin = ymin.setScale(HP_CUTOFF_EXP + 8);
    if (ymax.scale() < HP_CUTOFF_EXP + 8)
        ymax = ymax.setScale(HP_CUTOFF_EXP + 8);
    var dx = xmax.subtract(xmin).setScale(Math.max(xmax.scale(),HP_CUTOFF_EXP)*2, BigDecimal.ROUND_HALF_EVEN);
    dx = dx.divide(new BigDecimal("" + canvas.width),BigDecimal.ROUND_HALF_EVEN);
    var precision = 0;
    while (dx.compareTo(TWO) < 0) {
       precision++;
       dx = dx.multiply(TEN);
    }
    if (precision < HP_CUTOFF_EXP)
        precision = HP_CUTOFF_EXP;
    var scale = precision + 5 + Math.floor((precision-10)/10);
    xmin = xmin.setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    xmax = xmax.setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    ymin = ymin.setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    ymax = ymax.setScale(scale,BigDecimal.ROUND_HALF_EVEN);

    var width = xmax.subtract(xmin);
    var height = ymax.subtract(ymin);
    var aspect = width.divide(height,BigDecimal.ROUND_HALF_EVEN);
    var windowAspect = new BigDecimal( "" + canvas.width/canvas.height );
    if (aspect.compareTo(windowAspect) < 0) {
        var newWidth = width.multiply(windowAspect).divide(aspect,BigDecimal.ROUND_HALF_EVEN);
        var center = xmax.add(xmin).divide(TWO,BigDecimal.ROUND_HALF_EVEN);
        xmax = center.add(newWidth.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale, BigDecimal.ROUND_HALF_EVEN);
        xmin = center.subtract(newWidth.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    }
    else if (aspect.compareTo(windowAspect) > 0) {
        var newHeight = height.multiply(aspect).divide(windowAspect,BigDecimal.ROUND_HALF_EVEN);
        var center = ymax.add(ymin).divide(TWO,BigDecimal.ROUND_HALF_EVEN);
        ymax = center.add(newHeight.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale,BigDecimal.ROUND_HALF_EVEN);
        ymin = center.subtract(newHeight.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    }
}

function doDraw() {
    // console.log("doDraw from", (new Error()).stack.split("\n")[2].trim().split(" ")[1]);
    if (zoomTimeout) {
        clearInterval(zoomTimeout);
        zoomTimeout = null;
    }
    graphics.drawImage(OSC,0,0);
    if (dragbox && dragbox.width > 2 && dragbox.height > 2) {
       dragbox.draw();
    }
}

function repaint(dontUpdateStatusToIdle) {
    // console.log("repaint from", (new Error()).stack.split("\n")[2].trim().split(" ")[1], dontUpdateStatusToIdle);
    doDraw();
    const rpsText = rowsPerSecond.toPrecision(3) + " rows/sec";
    if (running) {
        repaintTimeout = setTimeout(repaint, repaintTimer);
        let rc = rowsCompleted;
        let pass = "Pass 1, ";
        let ch = canvas.height;
        if (state == COMPUTING_SECOND_PASS) {
            rc -= ch;
            ch += 1;
            pass = "Pass 2, ";
        }
        const prec = highPrecision ? digits + " digits precision" : "normal precision";
        statusText.statusMessage.updateText(pass + prec +
                    "... completed " + rc + " of " + ch + " rows at " + rpsText);
        statusText.statusHeader.updateText(pass + prec + ", " + (rc/ch*100).toFixed(0) + "%");
    } else if (dontUpdateStatusToIdle !== true) {
        statusText.statusMessage.updateText("Idle (" + rpsText + ")");
        statusText.statusHeader.updateText("Idle (" + rpsText + " " + canvas.width + "X" + canvas.height + ")");
    }
}

const jsRemoteWorker = "mandelbrot-worker-remote-v2.0.js"
const jsLocalWorker = "mandelbrot-worker-local-wasm.js"
function newWorkers(count) {
    // console.log("newWorkers from", (new Error()).stack.split("\n")[2].trim().split(" ")[1]);
    if (workers) {
       for (let i = 0; i < workers.length; i++) {
          workers[i].terminate();
       }
    }
    workers = [];
    let jsWorker = document.getElementById("local").checked ? jsLocalWorker : jsRemoteWorker;
    for (let i = 0; i < count; i++) {
        workers[i] = new Worker(jsWorker);
        workers[i].onmessage = jobFinished;
        workers[i].postMessage([ "wasm", i, compute_mandelbrot ]);
    }
}

const MAX_SECONDS_PER_JOB = 4;
function stopJob(dontUpdateStatusToIdle) {
    // console.log("stopJob", running, jobsPerSecond, workerCount/MAX_SECONDS_PER_JOB, "from", (new Error()).stack.split("\n")[2].trim().split(" ")[1]);
    if (zoomTimeout) {
        clearInterval(zoomTimeout);
        zoomTimeout = null;
    }
    if (running) {
        jobNum++;
        running = false;
        document.getElementById("stop").disabled = true;
        if (repaintTimeout) {
            clearTimeout(repaintTimeout);
            repaintTimeout = null;
        }
        repaint(dontUpdateStatusToIdle);
        if (jobsPerSecond < workerCount/MAX_SECONDS_PER_JOB) {
            // console.log("Making new workers:", jobsPerSecond, workerCount/MAX_SECONDS_PER_JOB);
            newWorkers(workerCount);
        }
    }
}

let maxRowsPerJob = 32;
let maxRowsPerJobHP = 4;

function startJob(dontClear) {
    // console.log("startJob", running, zoomTimeout, dontClear, "from", (new Error()).stack.split("\n")[2].trim().split(" ")[1]);
    if (running) {
       stopJob();
    }
    if (! zoomTimeout && dontClear !== true) {
        graphics.fillStyle = "#BBBBBB";
        graphics.fillRect(0,0,canvas.width,canvas.height);
        OSG.fillStyle = "#BBBBBB";
        OSG.fillRect(0,0,canvas.width,canvas.height);
    }
    imageData = OSG.getImageData(0,0,canvas.width,1);
    hres = Math.round(imageData.width/canvas.width);
    vres = imageData.height;
    dx = xmax.subtract(xmin).divide(new BigDecimal(""+(canvas.width-1)),BigDecimal.ROUND_HALF_EVEN);
    dy = ymax.subtract(ymin).divide(new BigDecimal(""+(canvas.height-1)),BigDecimal.ROUND_HALF_EVEN);
    highPrecision = document.getElementById("highPrecision").checked || dy.compareTo(HP_CUTOFF) < 0;
    jobs = [];
    var yVal = ymax.add(new BigDecimal("0"));
    var rows = canvas.height;
    var columns = canvas.width;
    savedIterationCounts = new Array(rows);
    savedIterationCounts2ndPass = new Array(rows+1);
    if (highPrecision) {
        digits = xmin.scale();
        chunks = Math.floor((digits * log2of10)/16 + 2);
        xminArray = new ArrayType(chunks+1);
        dxArray = new ArrayType(chunks+1);
        let dyArray = new ArrayType(chunks+1);
        convert(xminArray, xmin, chunks+1);
        convert(dxArray,dx,chunks+1);
        convert(dyArray, dy, chunks+1);

        let rowsPerJobHP = Math.min(maxRowsPerJobHP, Math.floor(rows/workerCount));
        for (let row = 0; row < rows; row += rowsPerJobHP) {
            let ytmp = yVal.subtract(dy.multiply(new BigDecimal(row.toString())));
            yValArray = new ArrayType(chunks+1);
            convert(yValArray, ytmp, chunks+1);
            jobs.push({
                row: row,
                columns: columns,
                xmin: xminArray,
                dx: dxArray,
                yVal: yValArray,
                dy: dyArray,
                nrows: Math.min(rowsPerJobHP, rows - row)
            });
        }
    }
    else {
        var xmin_d = Number(xmin.toString());
        var yVal_d = Number(yVal.toString());
        var dx_d = Number(dx.toString());
        var dy_d = Number(dy.toString());
        // console.log(dx_d, dy_d, xmin_d, yVal_d);

        let rowsPerJob = Math.min(maxRowsPerJob, Math.floor(rows/workerCount));
        for (let row = 0; row < rows; row += rowsPerJob) {
            jobs.push({
                row: row,
                columns: columns,
                xmin: xmin_d,
                dx: dx_d,
                yVal: yVal_d,   // to reduce error calculate y in worker as yVal_d - (row + 0..nrows)*dy_d
                dy: dy_d,
                nrows: Math.min(rowsPerJob, rows - row)
            });
        }
    }
    jobs.reverse();     // keep original order

    if (interlaced) {
        var sortedJobs = jobs;
        jobs = [];
        for (var i = 0; i < interlaceOrder.length; i++) {
            for (var j = interlaceOrder[i]; j < sortedJobs.length; j += interlaceOrder.length) {
                jobs.push(sortedJobs[j]);
                //if (sortedJobs[j] == null) {  // for debugging
                //    throw "bad logic";
                //}
                //sortedJobs[j] = null;
            }
        }
    }

    jobStartTime = Date.now();
    for (let i = 0; i < workerCount; i++) {
        let j = jobs.pop();
        j.workerNum = i;
        workers[i].postMessage(["setup",jobNum, maxIterSlider.value,highPrecision,i]);
        workers[i].postMessage([
            "task", j.row, j.columns,
            j.xmin, j.dx, j.yVal, j.dy, j.nrows
        ]);
    }

    rowsCompleted = 0;
    rowsPerSecond = 0;
    jobsCompleted = 0;
    jobsPerSecond = 0;
    running = true;
    document.getElementById("stop").disabled = false;
    var prec = highPrecision ? "high precision, " + digits + " digits" : "normal precision";
    statusText.updateText("Pass 1, " + prec + "...");
    if (! zoomTimeout) {
        repaintTimeout = setTimeout(repaint, repaintInitialTimer);
    }
    state = COMPUTING_FIRST_PASS;
    progressCircle.setPass(1, highPrecision);
    currentXML = currentExampletoXML();
}

function jobFinished(msg) {
    var job = msg.data;
    if (job[0] != jobNum)
       return;
    if (jobs.length > 0) {
       var worker = workers[job[3]];
       var j = jobs.pop();
       worker.postMessage([
            "task", j.row, j.columns,
            j.xmin, j.dx, j.yVal, j.dy, j.nrows
        ]);
    }
    var iterationCounts = job[2];
    let nRows = job[4];
    for (let i = 0; i < nRows; i++) {
        let row = job[1] + i;
        if (state == COMPUTING_FIRST_PASS) {
           savedIterationCounts[row] = iterationCounts[i];
           putRow(row);
        }
        else {
            savedIterationCounts2ndPass[row] = iterationCounts[i];
            // all rows need to be present for averaging second pass if workerCount > 1
            //if (row > 0) {
            //   putRow(row-1);
            //}
        }
    }

    const elapsedSecs = (Date.now() - jobStartTime)/1000.0;
    rowsCompleted += nRows;
    rowsPerSecond = rowsCompleted/elapsedSecs;
    jobsCompleted += 1;
    jobsPerSecond = jobsCompleted/elapsedSecs;

    const ch = canvas.height;
    if (state == COMPUTING_FIRST_PASS) {
        progressCircle.setPercentage(rowsCompleted/ch);
        if (rowsCompleted === ch) {
            state = DONE_FIRST_PASS;
            if (document.getElementById("secondpass").checked) {
                stopJob(true);
                startSecondPass();
            } else {
                stopJob();
                progressCircle.hide();
            }
        }
    } else {
        progressCircle.setPercentage((rowsCompleted - ch)/(ch + 1));
        if (rowsCompleted === 2*ch + 1) {
            // all rows need to be present for averaging second pass if workerCount > 1
            for (let row = 0; row < ch; row++) {
                putRow(row);
            }
            state = IDLE;
            stopJob();
            progressCircle.hide();
        }
    }
}

function startSecondPass() {
    if (running) {
       stopJob();
    }
    dx = xmax.subtract(xmin).divide(new BigDecimal(""+(canvas.width-1)),BigDecimal.ROUND_HALF_EVEN);
    dy = ymax.subtract(ymin).divide(new BigDecimal(""+(canvas.height-1)),BigDecimal.ROUND_HALF_EVEN);
    var dxHalf = dx.divide(TWO,BigDecimal.ROUND_HALF_EVEN);
    var dyHalf = dy.divide(TWO,BigDecimal.ROUND_HALF_EVEN);
    highPrecision = document.getElementById("highPrecision").checked || dy.compareTo(HP_CUTOFF) < 0;
    jobs = [];
    var yVal = ymax.add(dyHalf);
    var xStart = xmin.subtract(dxHalf);
    var rows = canvas.height + 1;
    var columns = canvas.width + 1;
    if (highPrecision) {
        digits = xmin.scale();
        chunks = Math.floor((digits * log2of10)/16 + 2);
        xminArray = new ArrayType(chunks+1);
        dxArray = new ArrayType(chunks+1);
        let dyArray = new ArrayType(chunks+1);
        convert(xminArray, xStart, chunks+1);
        convert(dxArray,dx,chunks+1);
        convert(dyArray, dy, chunks+1);

        let rowsPerJobHP = Math.min(maxRowsPerJobHP, Math.floor(rows/workerCount));
        for (let row = 0; row < rows; row += rowsPerJobHP) {
            let ytmp = yVal.subtract(dy.multiply(new BigDecimal(row.toString())));
            yValArray = new ArrayType(chunks+1);
            convert(yValArray, ytmp, chunks+1);
            jobs.push({
                row: row,
                columns: columns,
                xmin: xminArray,
                dx: dxArray,
                yVal: yValArray,
                dy: dyArray,
                nrows: Math.min(rowsPerJobHP, rows - row)
            });
        }
    }
    else {
        var xmin_d = Number(xStart.toString());
        var yVal_d = Number(yVal.toString());
        var dx_d = Number(dx.toString());
        var dy_d = Number(dy.toString());
        //var ymax_d = Number(ymax.toString()) + dy_d/2;

        let rowsPerJob = Math.min(maxRowsPerJob, Math.floor(rows/workerCount));
        for (let row = 0; row < rows; row += rowsPerJob) {
            jobs.push({
                row: row,
                columns: columns,
                xmin: xmin_d,
                dx: dx_d,
                yVal: yVal_d,   // to reduce error calculate y in worker as yVal_d - (row + 0..nrows)*dy_d
                dy: dy_d,
                nrows: Math.min(rowsPerJob, rows - row)
            });
        }
        //jobs.reverse();     // keep original order (don't need to since now we're waiting for all rows to finish before drawing)
    }

    for (var i = 0; i < workerCount; i++) {
        var j = jobs.pop();
        j.workerNum = i;
        workers[i].postMessage(["setup",jobNum, maxIterSlider.value,highPrecision,i]);
        workers[i].postMessage([
            "task", j.row, j.columns,
            j.xmin, j.dx, j.yVal, j.dy, j.nrows
        ]);
    }
    running = true;
    document.getElementById("stop").disabled = false;
    repaintTimeout = setTimeout(repaint, repaintInitialTimer);
    state = COMPUTING_SECOND_PASS;
    progressCircle.setPass(2, highPrecision);
}

function putRow(row) {
    var iterationCounts = savedIterationCounts[row];
    var above = savedIterationCounts2ndPass[row];
    var below = savedIterationCounts2ndPass[row+1];
    var average = above && below;
    var secondPassColor;
    var ct;
    if (average) {
       ct = above[0];
       var c1 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
       ct = below[0];
       var c2 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
       secondPassColor = [c1[0]+c2[0],c1[1]+c2[1],c1[2]+c2[2]];
    }
    var columns = canvas.width;
    for (var i = 0; i < columns; i++) {
       ct = iterationCounts[i];
       var color;
       if (ct < 0) {
          color = [0,0,0];
       }
       else {
          var paletteIndex = iterationCounts[i] % paletteLength;
          color = paletteColors[paletteIndex];
       }
       if (average) {
           ct = above[i+1];
           var c1 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
           ct = below[i+1];
           var c2 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
           var secondPassColor2 = [c1[0]+c2[0],c1[1]+c2[1],c1[2]+c2[2]];
           color = [ // had a bug where I modified the color that was still in the palette array!
               ( 4*color[0] + secondPassColor[0] + secondPassColor2[0] ) / 8,
               ( 4*color[1] + secondPassColor[1] + secondPassColor2[1] ) / 8,
               ( 4*color[2] + secondPassColor[2] + secondPassColor2[2] ) / 8
           ];
           secondPassColor = secondPassColor2;
       }
       var p = 4*i*hres;
       for (var j = 0; j < hres; j++) {
           imageData.data[p] = color[0];
           imageData.data[p+1] = color[1];
           imageData.data[p+2] = color[2];
           imageData.data[p+3] = 255;
       }
    }
    for (var i = 0; i < vres; i++) {
        OSG.putImageData(imageData,0,row*vres+i);
    }
}

function setDefaults() {
    stopJob();
    setLimits(new BigDecimal("-2.2"), new BigDecimal("0.8"), new BigDecimal("-1.2"), new BigDecimal("1.2"), false);
    maxIterSlider.setDefault();
    mainPaletteLengthSlider.setDefaultsFromMaxIter();
    fixedPaletteLength = mainPaletteLengthSlider.value;
    mainPaletteOffsetSlider.setDefault();
    const oldPaletteSelectSliderState = paletteSelectSlider.getPaletteSelectSliderState();
    paletteSelectSlider.reset();
    palette = new Palette();
    createPaletteColors();
    if (undoList) {
        const oldXML = currentXML;
        const oldURL = persistence.setDefaultURL();
        startJob();
        addUndoItem("Restore Defaults", [oldXML, oldPaletteSelectSliderState, oldURL],
            [currentXML, paletteSelectSlider.getPaletteSelectSliderState(), persistence.url]);
    } else {
        // first time calling setDefaults
        document.getElementById("customsize").style.display = "none";
        document.getElementById("imagesize").value = "0 0";
        setCanvasToWindow();
    }
}

function remapColors() {
    for (var row = 0; row < canvas.height; row++) {
       if (savedIterationCounts[row]) {
           putRow(row);
       }
    }
    doDraw();
    currentXML = currentExampletoXML();
}

function createPaletteColors(newPaletteOffset) {
    paletteLength = fixedPaletteLength;
    let offset = typeof newPaletteOffset === "number" ? newPaletteOffset/100 : mainPaletteOffsetSlider.value/100;
    offset = Math.round(offset * paletteLength);
    paletteColors = palette.makeRGBs(paletteLength,offset);
}

const ZOOM = 1;
const ZOOMINRECT = 2;
const ZOOMOUTRECT = 3;

function DragBox(x,y) {
    this.x = this.left = x;
    this.y = this.top = y;
    this.width = 0;
    this.height = 0;
}
DragBox.prototype.draw = function() {  // Draw the box on the on-screen canvas
    graphics.strokeStyle = "#FFFFFF";
    graphics.lineWidth = 4;
    graphics.strokeRect(this.left,this.top,this.width,this.height);
    graphics.strokeStyle = "#000000";
    graphics.lineWidth = 2;
    graphics.strokeRect(this.left,this.top,this.width,this.height);
}
DragBox.prototype.setCorner = function(x1,y1) {
    var w = Math.abs(x1 - this.x);
    var h = Math.abs(y1 - this.y);
    if (w < 3 || h < 3) {
        this.width = this.height = 0;
        return;
    }
    var aspect = canvas.width/canvas.height;
    var rectAspect = w / h;
    if (aspect > rectAspect)
        w = Math.round(w*aspect/rectAspect);
    else if (aspect < rectAspect)
        h = Math.round(h*rectAspect/aspect);
    if (this.x < x1) {
        this.left = this.x;
    }
    else {
        this.left = this.x - w;
    }
    if (this.y < y1) {
        this.top = this.y;
    }
    else {
        this.top = this.y - h;
    }
    this.width = w;
    this.height = h;
}
DragBox.prototype.zoom = function(zoomin) {
    if (this.width <= 2 || this.height <= 2)
       return;
    stopJob();
    if (zoomin == false) {
        doZoomOutFromRect(this.left, this.top, this.width, this.height, true);
    }
    else {
        doZoomInOnRect(this.left, this.top, this.width, this.height, true);
    }
    startJob();
}

let zoomTimeout;
let OSZC;  // Zoom canvas.
let OSZG;  // Graphics context for zoom canvas.
const FPS = 60;
const ZOOMTIME = 250;   // zoom time in ms
const NFRAMES = Math.floor(ZOOMTIME/1000*FPS);
const FRAMEINTERVAL = ZOOMTIME/NFRAMES;

function drawZoom(left, top, width, height, doStartJob) {
    // console.log("drawZoom from", (new Error()).stack.split("\n")[2].trim().split(" ")[1], left, top, width, height, NFRAMES, FRAMEINTERVAL);

    // draw latest OSC
    graphics.drawImage(OSC,0,0);

    // scale image into OSG with gray surround if needed
    OSG.fillStyle = "#BBBBBB";
    OSG.fillRect(0, 0, canvas.width, canvas.height);
    OSG.drawImage(canvas, left, top, width, height, 0, 0, canvas.width, canvas.height);

    // save the un-zoomed image
    if (! OSZC) {
        OSZC = document.createElement("canvas");
        OSZG = OSZC.getContext("2d");
    }
    OSZC.width = canvas.width;
    OSZC.height = canvas.height;
    OSZG.drawImage(canvas, 0, 0);

    let frameCount = 1;
    zoomDrawFrame(left, top, width, height, frameCount);
    frameCount++;
    zoomTimeout = setInterval(function () {
        if (frameCount <= NFRAMES) {
            zoomDrawFrame(left, top, width, height, frameCount);
            frameCount++;
        } else {
            clearInterval(zoomTimeout);
            zoomTimeout = null;
            if (doStartJob) {
                // mobile devices may struggle to draw smooth zoom frames and compute too, so delay startJob until animation finishes
                startJob(true);
            } else {
                repaint();
            }
        }
    }, FRAMEINTERVAL);
}

function zoomDrawFrame(left, top, width, height, frameCount) {
    const zoomFactor = frameCount/NFRAMES;
    const leftZ = left*zoomFactor;
    const topZ = top*zoomFactor;
    const widthZ = canvas.width - (canvas.width - width)*zoomFactor;
    const heightZ = canvas.height - (canvas.height - height)*zoomFactor;
    graphics.fillStyle = "#BBBBBB";
    graphics.fillRect(0,0,canvas.width,canvas.height);
    graphics.drawImage(OSZC, leftZ, topZ, widthZ, heightZ, 0, 0, canvas.width, canvas.height);
}

function doZoomInOnRect(x,y,width,height, undo, undoText, dontCallDrawZoom) {
    // console.log("doZoomInOnRect", x, y, width, height);
    var rectX = new BigDecimal("" + Math.round(x));  // (Firefox can have fractional parts)
    var rectY = new BigDecimal("" + Math.round(y));
    var rectW = new BigDecimal("" + Math.round(width));
    var rectH = new BigDecimal("" + Math.round(height));
    var ImageWidth = new BigDecimal("" + canvas.width);
    var ImageHeight = new BigDecimal("" + canvas.height);
    var pixelWidth = xmax.subtract(xmin).divide(ImageWidth,BigDecimal.ROUND_HALF_EVEN);
    var pixelHeight = ymax.subtract(ymin).divide(ImageHeight,BigDecimal.ROUND_HALF_EVEN);
    var newXmin,newXmax,newYmin,newYmax;
    newXmin = xmin.add(pixelWidth.multiply(rectX));
    newYmax = ymax.subtract(pixelHeight.multiply(rectY));
    var newWidth = pixelWidth.multiply(rectW);
    var newHeight = pixelHeight.multiply(rectH);
    newXmax = newXmin.add(newWidth);
    newYmin = newYmax.subtract(newHeight);
    setLimits(newXmin, newXmax, newYmin, newYmax, false);
    if (undo) {
        undoText = undoText ? undoText : "Zoom In";
        addUndoItem(undoText, [ZOOMOUTRECT, x, y, width, height], [ZOOMINRECT, x, y, width, height]);
    }
    if (! dontCallDrawZoom) {
        drawZoom(x, y, width, height);
    }
}

function doZoomOutFromRect(x,y,width,height, undo) {
    // console.log("doZoomOutFromRect", x, y, width, height);
    var rectX = new BigDecimal("" + Math.round(x));
    var rectY = new BigDecimal("" + Math.round(y));
    var rectW = new BigDecimal("" + Math.round(width));
    var rectH = new BigDecimal("" + Math.round(height));
    var ImageWidth = new BigDecimal("" + canvas.width);
    var ImageHeight = new BigDecimal("" + canvas.height);
    var newPixelWidth = xmax.subtract(xmin).divide(rectW,BigDecimal.ROUND_HALF_EVEN);
    var newPixelHeight = ymax.subtract(ymin).divide(rectH,BigDecimal.ROUND_HALF_EVEN);
    var newXmin,newXmax,newYmin,newYmax;
    newXmin = xmin.subtract(newPixelWidth.multiply(rectX));
    newYmax = ymax.add(newPixelHeight.multiply(rectY));
    var newWidth = newPixelWidth.multiply(ImageWidth);
    var newHeight = newPixelHeight.multiply(ImageHeight);
    newXmax = newXmin.add(newWidth);
    newYmin = newYmax.subtract(newHeight);
    setLimits(newXmin, newXmax, newYmin, newYmax, false);
    if (undo) {
        addUndoItem("Zoom Out", [ZOOMINRECT, x, y, width, height], [ZOOMOUTRECT, x, y, width, height]);
    }

    let zoomFactor = (canvas.width/width + canvas.height/height)/2;
    drawZoom(-zoomFactor*x, -zoomFactor*y, zoomFactor*canvas.width, zoomFactor*canvas.height);
}

function zoom(x, y, zoomFactor, recenter, undo) {  // (x,y) is center of zoom, in pizels; recenter moves that point to center of image
    // console.log("zoom:", x, y, zoomFactor, recenter);
    var zf = new BigDecimal("" + zoomFactor);
    var X = new BigDecimal("" + Math.round(x));
    var Y = new BigDecimal("" + Math.round(y));
    var ImageWidth = new BigDecimal("" + canvas.width);
    var ImageHeight = new BigDecimal("" + canvas.height);
    var oldWidth = xmax.subtract(xmin);
    var oldHeight = ymax.subtract(ymin);
    var newWidth = oldWidth.multiply(zf);
    var newHeight = oldHeight.multiply(zf);
    if (zoomFactor > 1 && newWidth.compareTo(new BigDecimal("100")) > 0) {
        statusText.updateText("Zooming out that far would reduce the whole Mandelbrot set to a dot.  Ignored.");
        return;
    }
    stopJob();
    var pixelWidth = newWidth.divide(ImageWidth,BigDecimal.ROUND_HALF_EVEN);
    var pixelHeight = newHeight.divide(ImageHeight,BigDecimal.ROUND_HALF_EVEN);
    var centerX = xmin.add(X.multiply(oldWidth).divide(ImageWidth,BigDecimal.ROUND_HALF_EVEN));
    var centerY = ymax.subtract(Y.multiply(oldHeight).divide(ImageHeight,BigDecimal.ROUND_HALF_EVEN));
    var newXmin,newXmax,newYmin,newYmax;
    if (recenter) {
        newXmin = centerX.subtract(newWidth.divide(TWO,BigDecimal.ROUND_HALF_EVEN));
        newYmax = centerY.add(newHeight.divide(TWO,BigDecimal.ROUND_HALF_EVEN));
    }
    else {
        newXmin = centerX.subtract(X.multiply(pixelWidth));
        newYmax = centerY.add(Y.multiply(pixelHeight));
    }
    newYmin = newYmax.subtract(newHeight);
    newXmax = newXmin.add(newWidth);
    setLimits(newXmin, newXmax, newYmin, newYmax, false);

    if (undo) {
        let midX = canvas.width/2;
        let midY = canvas.height/2;
        let undoLabel = zoomFactor > 1 ? "Zoom Out" : "Zoom In";
        let newZoom = [ZOOM, x, y, zoomFactor, recenter];
        if (recenter) {
            addUndoItem(undoLabel, [ZOOM, midX + (midX - x)/zoomFactor, midY + (midY - y)/zoomFactor, 1/zoomFactor, recenter], newZoom);
        } else {
            addUndoItem(undoLabel, [ZOOM, x, y, 1/zoomFactor, recenter], newZoom);
        }
    }

    let width = canvas.width*zoomFactor;
    let height = canvas.height*zoomFactor;
    let left, top;
    if (recenter) {
        left = x - width/2;
        top = y - height/2;
    } else {
        left = x*(1 - zoomFactor);
        top = y*(1 - zoomFactor);
    }
    drawZoom(left, top, width, height, true);
    // startJob();
}

// let singleClickTimeout = null;
// let cancelSingleClick = false;
let cancelDoubleClick = false;
function setUpDragging() {  // for image canvas
    var zoomin;
    var startX, startY; // for mouse only
    dragbox = null;  // initially, the mouse is not being dragged.
    canvas.addEventListener("dblclick",doMouseDoubleClick,false);
    new Mouser(canvas, startDrag, continueDrag, endDrag, true);
    function startDrag(x,y,evt) {
        if (evt && evt.button != 0)  // only allow left button to start drag
            return false;
        startX = x;
        startY = y;
        dragbox = null;
        zoomin = ! (evt && evt.shiftKey); 
        return true;
    }
    function continueDrag(x,y) {
        if (dragbox == null) {
            if ( Math.abs(startX - x) < 3 && Math.abs(startY - y) < 3) {
                return;  // don't show zoombox until mouse/touch has moved a bit.
            }
            dragbox = new DragBox(startX,startY);
        }
        dragbox.setCorner(x,y);
        doDraw();
    }
    function endDrag() {
        if (dragbox != null) {
            doDraw();
            dragbox.zoom(zoomin);
            dragbox = null;
        }
    }
    function doMouseDoubleClick(evt) {
        if (cancelDoubleClick || dragbox || evt.button != 0) {
            return;
        }
        const r = canvas.getBoundingClientRect();
        // account for canvas border margin
        const x = evt.clientX - (r.left + r.right - canvas.width)/2;
        const y = evt.clientY - (r.top + r.bottom - canvas.height)/2;
        const zoomFactor = evt.shiftKey ? 2 : 0.5;
        zoom(x,y,zoomFactor,!evt.altKey && !evt.ctrlKey, true);
    }
}

function Mouser(canvas, startDrag, continueDrag, endDrag, mouseMoveOnCanvasOnly) {
      // functions startDrag, continueDrag take canvas coords (x,y); for a mouse event event object is also passed.
      // function endDrag takes no parameter for touched, mouse event for mouse actions.
      // function startDrag returns a boolean, true if the down action should start a drag.
    var dragging = false;
    canvas.addEventListener("mousedown",doMouseDown,false);
    // canvas.addEventListener("touchstart",doTouchStart,false);
    function doMouseDown(evt) {
        // if (singleClickTimeout != null) {
        //     cancelSingleClick = true;
        //     clearTimeout(singleClickTimeout);
        //     singleClickTimeout = null;
        // }
        cancelDoubleClick = false;
        if (dragging) {
            return;
        }
        const r = canvas.getBoundingClientRect();
        // account for canvas border margin
        const x = evt.clientX - (r.left + r.right - canvas.width)/2;
        const y = evt.clientY - (r.top + r.bottom - canvas.height)/2;
        if (startDrag(x,y,evt)) {
            dragging = true;
            (mouseMoveOnCanvasOnly? canvas : document).addEventListener("mousemove",doMouseMove,false);
            document.addEventListener("mouseup",doMouseUp,false);
        }
    }
    function doMouseMove(evt) {
        if (!dragging) {
            return;
        }
        const r = canvas.getBoundingClientRect();
        // account for canvas border margin
        const x = evt.clientX - (r.left + r.right - canvas.width)/2;
        const y = evt.clientY - (r.top + r.bottom - canvas.height)/2;
        continueDrag(x,y,evt); 
    }
    function doMouseUp(evt) {
        if (dragging) {  
            dragging = false;
            (mouseMoveOnCanvasOnly? canvas : document).removeEventListener("mousemove",doMouseMove,false);
            document.removeEventListener("mouseup",doMouseUp,false);
            if (dragbox == null) {
            //     if (! cancelSingleClick) {
            //         singleClickTimeout = setTimeout(() => {
            //             singleClickTimeout = null;
            //             if (fullScreenCanvas) {
            //                 fromFullScreenCanvas();
            //             } else if (fullWindowCanvas) {
            //                 fromFullWindowCanvas();
            //             } else {
            //                 toFullWindowCanvas();
            //             }
            //         }, 350);
            //     }
            } else {
                endDrag(evt);
                cancelDoubleClick = true;
            }
        }
        // cancelSingleClick = false;
    }
    function doTouchStart(evt){
        if (evt.touches.length != 1) {
           doTouchCancel();
           return;
        }
        evt.preventDefault();
        if (dragging) {
            return;
        }
        const r = canvas.getBoundingClientRect();
        // account for canvas border margin
        const x = evt.touches[0].clientX - (r.left + r.right - canvas.width)/2;
        const y = evt.touches[0].clientY - (r.top + r.bottom - canvas.height)/2;
        if (startDrag(x,y)) {
            dragging = true;
            canvas.addEventListener("touchmove", doTouchMove);
            canvas.addEventListener("touchend", doTouchEnd);
            canvas.addEventListener("touchcancel", doTouchCancel);
        }
    }
    function doTouchMove(evt){
        if (!dragging)
           return;
        evt.preventDefault();
        if (evt.touches.length != 1) {
           doTouchCancel();
           return;
        }
        const r = canvas.getBoundingClientRect();
        // account for canvas border margin
        const x = evt.touches[0].clientX - (r.left + r.right - canvas.width)/2;
        const y = evt.touches[0].clientY - (r.top + r.bottom - canvas.height)/2;
        continueDrag(x,y);
    }
    function doTouchEnd(evt) {
        doTouchCancel();
    }
    function doTouchCancel() {
        if (dragging) {
           canvas.removeEventListener("touchmove", doTouchMove);
           canvas.removeEventListener("touchend", doTouchEnd);
           canvas.removeEventListener("touchcancel", doTouchCancel);
           endDrag();
           dragging = false;
        }
    }
}

function changeWorkerCount() {
    var ct = Number(document.getElementById("threadCountSelect").value);
    if (workers && ct == workers.length)
        return;
    var restart  = running;
    if (running) {
        stopJob();
    }
    workerCount = ct;
    newWorkers(ct);
    if (restart) {
        startJob();
    }
    setLocalStorageItem("mandelbrotWorkerCount-" + (document.getElementById("local").checked ? "local" : "remote"), ct);
}

async function pageExists(url) {
    try {
        const response = await fetch(url);
        // console.log(response);
        return response.ok;
    } catch (error) {
        return false;
    }
}

function initLocalOrRemote() {
    let item = getLocalStorageItem("mandelbrotLocalOrRemote", "remote");
    document.getElementById(item).checked = true;
}

function checkRemoteCanComputeMB() {
    pageExists("/remoteCanComputeMB").then(result => {
        if (! result) {
            document.getElementById("remote").disabled = true;
            document.getElementById("localRemote").title = "Mandelbrot web server is not available, calculations will be done in the browser.";
            console.warn("remote web server does not support Mandelbrot calculations");
            if (document.getElementById("remote").checked) {
                document.getElementById("local").checked = true;
                changeLocalOrRemote();
            }
        }
    });
}

function changeLocalOrRemote() {
    let localOrRemote = document.getElementById("local").checked ? "local" : "remote";
    setLocalStorageItem("mandelbrotLocalOrRemote", localOrRemote);
    let newWorkerCount = getLocalStorageItem("mandelbrotWorkerCount-" + localOrRemote, workerCount);
    if (running) {
        stopJob();
        workerCount = newWorkerCount;
        newWorkers(workerCount);
        startJob();
    } else {
        workerCount = newWorkerCount;
        newWorkers(workerCount);
    }
    document.getElementById("threadCountSelect").value = "" + newWorkerCount;
}

function setMaxIterations() {
    stopJob();
    createPaletteColors();
    startJob(true);
}

function setFixedPaletteLength(newPaletteLength) {
    // console.log("setFixedPaletteLength:", newPaletteLength);
    fixedPaletteLength = newPaletteLength;
    createPaletteColors();
    remapColors();
}

function doPaletteOffset(newPaletteOffset) {
    createPaletteColors(newPaletteOffset);
    remapColors();
}
function finishDoPaletteOffset(newPaletteOffset, oldPaletteState) {
    currentXML = currentExampletoXML();
    addUndoItem("Change PaletteOffset", oldPaletteState.value/100, newPaletteOffset/100);
}

function changeInterlaced() {
   var checked = document.getElementById("interlaced").checked;
   setLocalStorageItem("interlaced", checked);
   if (checked == interlaced) {
       return;
   }
   interlaced = checked;
   if (running) {
       stopJob();
       startJob();
   }
}

function changeImageSize() {
    let e = document.getElementById("imagesize");
    let val = e.value;
    // so that "f" and "F" are not captured here
    e.blur();
    if (val === "Custom") {
        document.getElementById("customwidth").value = "" + canvas.width;
        document.getElementById("customheight").value = "" + canvas.height;
        document.getElementById("customsize").style.display = "inline";
    } else {
        document.getElementById("customsize").style.display = "none";
        var sizes = val.split(" ");
        var width = Number(sizes[0]);
        var height = Number(sizes[1]);
        setImageSize(width,height,true);
    }
}
function doCustomSize() {
    var width = Math.round(Number(document.getElementById("customwidth").value.trim()));
    var height = Math.round(Number(document.getElementById("customheight").value.trim()));
    if (isNaN(width) || width < 64 || width > 7680) {
        statusText.updateText("Illegal value for image width.  Must be an integer in the range 64 to 7680.");
        return;
    }
    if (isNaN(height) || height < 64 || height > 7680) {
        statusText.updateText("Illegal value for image height.  Must be an integer in the range 64 to 7680.");
        return;
    }
    setImageSize(width,height,true);
}
// outerWidth/height: ios safari not reporting correct size after orientation change
// innerWidth/height: ios chrome sometimes not reporting correct size after orientation change
// window.visualViewport.width/height: ios precision too low, so width/height slightly different when pinch zooming, causing cosntant redraws
//   also when touch zooming, image doesn't cover whole screen
// document.documentElement.clientWidth/height: android height doesn't update in response to url bar hiding
const windowSize = {
    init: function() {
        // window.visualViewport.addEventListener('resize', resizeWindow);
        window.addEventListener('resize', resizeWindow);
    },
    get width() {
        // return Math.round(window.visualViewport.width*window.visualViewport.scale);
        // return Math.ceil(window.visualViewport.width);
        return window.innerWidth;
    },
    get height() {
        // return Math.round(window.visualViewport.height*window.visualViewport.scale);
        // return Math.ceil(window.visualViewport.height);
        return window.innerHeight;
    }
}
function setCanvasToWindow() {
    currentImageSize = [0, 0];
    canvas.classList.add('fullWindowCanvas');
    setTooltipSize();
    let w, h;
    w = windowSize.width;
    h = windowSize.height;

    canvas.width = w;
    canvas.height = h;
    OSC.width = w;
    OSC.height = h;
    checkAspect();
    canvas.classList.remove("displayNone");
}
function setImageSizeToFixed(w, h, oldImageSize, doDraw) {
    // console.log("setImageSizeToFixed from", (new Error()).stack.split("\n")[2].trim().split(" ")[1], w, h, doDraw);
    // console.log("setImageSizeToFixed", w, h, doDraw);
    if (!doDraw && w === canvas.width && h === canvas.height) {
        return;
    }
    const dontClear = !doDraw && Math.abs(w/h - canvas.width/canvas.height) < 0.01;
    stopJob();
    OSC.width = w;
    OSC.height = h;
    if (dontClear) {
        // put on screen image into off screen graphics
        OSG.drawImage(canvas, 0, 0, w, h);
    }
    canvas.width = w;
    canvas.height = h;
    if (dontClear) {
        // put cached image back into resized on screen image
        graphics.drawImage(OSC, 0, 0, w, h);
    }
    checkAspect();
    if (oldImageSize) {
        addUndoItem("Change Image Size", oldImageSize, currentImageSize);
    }
    startJob(dontClear);
}
function setImageSize(w, h, undo, doDraw) {
    // console.log("setImageSize from", (new Error()).stack.split("\n")[2].trim().split(" ")[1], w, h);
    // console.log("setImageSize", w, h);
    const oldImageSize = currentImageSize;
    currentImageSize = [w, h];
    if (w === 0 && h === 0) {
        statusText.statusHeader.show();
        canvas.classList.add('fullWindowCanvas');
        w = windowSize.width;
        h = windowSize.height;
    } else {
        statusText.statusHeader.hide();
        canvas.classList.remove("fullWindowCanvas");
    }
    setImageSizeToFixed(w, h, undo ? oldImageSize : false, doDraw);
}
let resizeWindowTimeout = null;
function doResizeWindow() {
    setTooltipSize();
    if (fullWindowCanvas) {
        // console.log("resize fwc:", windowSize.width, windowSize.height);
        setImageSizeToFixed(windowSize.width, windowSize.height);
    } else if (fullScreenCanvas) {
        // console.log("resize fsc:", screen.width, screen.height);
        setImageSizeToFixed(screen.width, screen.height)
    } else {
        // console.log("resize:", currentImageSize[0], currentImageSize[1]);
        setImageSize(currentImageSize[0], currentImageSize[1], false);
    }
}
function resizeWindow() {
    // console.log("resizeWindow", resizeWindowTimeout);
    if (resizeWindowTimeout !== null) {
        clearTimeout(resizeWindowTimeout);
    }
    doResizeWindow();
    // ios is not always reporting correct width and height on orientation change
    // use timeout to redo the resize after things have hopefully settled down
    resizeWindowTimeout = setTimeout(() => {
        resizeWindowTimeout = null;
        doResizeWindow();
    }, 125);
}
function setTooltipSize() {
    const mainUIRect = document.getElementById("mainUI").getBoundingClientRect();
    const w = mainUIRect.right;
    // console.log("setToolTipSize:", w.toFixed(0));
    let tooltip = document.querySelector('.tooltip .helptext');
    tooltip.style.width = Math.min(800, w*0.85) + "px";

    tooltip = document.querySelector('.tooltip .exampletext');
    tooltip.style.width = Math.min(800, w*0.85) + "px";
}

function doApplyStandardPalette(newPaletteNum, newPalette) {
    if (newPalette) {
        palette = newPalette;
    } else {
        let name = paletteSelectSlider.paletteName(newPaletteNum);
        palette = Palette.createStandardPalette(name);
    }
    createPaletteColors();
    remapColors();
}

function changeSecondPass() {
    const checked = document.getElementById("secondpass").checked;
    setLocalStorageItem("secondpass", checked);
    progressCircle.setFirstPassColors(checked);
    if (checked && !running && state == DONE_FIRST_PASS) {
        // hack to improve accuracy of rowsPerSecond and jobsPerSecond when a second pass is run sometime after first pass
        const elapsedSecs = rowsCompleted/rowsPerSecond;
        jobStartTime = Date.now() - elapsedSecs*1000;
        startSecondPass();
    }
}

function changeHighPrecision() {
    var checked = document.getElementById("highPrecision").checked;
    if (running && checked != highPrecision) {
        stopJob();
        startJob();
    }
}

function doZoomIn(z) {
    zoom(canvas.width/2, canvas.height/2, 1/z, false, true);
}

function doZoomOut(z) {
    zoom(canvas.width/2, canvas.height/2, z, false, true);
}

//---------------------- Undo/Redo ---------------------------------------

function doUndo() {
    if (undoCount > 0) {
        var item = undoList[undoCount-1];
        undoCount--;
        document.getElementById("undo").disabled = (undoCount == 0);
        document.getElementById("undo").innerHTML = undoCount? ("Undo " + undoList[undoCount-1].name) : "Undo";
        document.getElementById("redo").disabled = false;
        document.getElementById("redo").innerHTML = "Redo " + item.name;
        applyUndoItem(item.name, item.oldValue);
    }
}

function doRedo() {
    if (undoCount < undoList.length) {
        var item = undoList[undoCount];
        undoCount++;
        document.getElementById("undo").disabled = false;
        document.getElementById("undo").innerHTML = "Undo " + item.name;
        document.getElementById("redo").disabled = (undoCount == undoList.length);
        document.getElementById("redo").innerHTML = (undoCount < undoList.length)? ("Redo " + undoList[undoCount].name) : "Redo";
        applyUndoItem(item.name, item.newValue);
    }
}

function addUndoItem(name, oldValue, newValue) {
    if (applyUndoInProgress) {
        return;
    }
    undoList.length = undoCount;
    undoList.push( { name: name, oldValue: oldValue, newValue: newValue } );
    if (undoList.length > 100) {
        undoList.shift();
    }
    undoCount = undoList.length;
    document.getElementById("undo").disabled = false;
    document.getElementById("undo").innerHTML = "Undo " + name;
    document.getElementById("redo").disabled = true;
    document.getElementById("redo").innerHTML = "Redo";
}

function applyUndoItem(name, value) {
    applyUndoInProgress = true;
    switch (name) {
      case "Restore Defaults":
      case "Import Example":
          // restore other URL
          persistence.setURL(value[2]);
          installExampleFromXML(value[0], true);
          paletteSelectSlider.setPaletteSelectSliderState(value[1]);
          break;
      case "Change PaletteOffset":
         mainPaletteOffsetSlider.setValue(value*100);
         doPaletteOffset();
         break;
      case "Change Limits":
         stopJob();
         setLimits(value[0],value[1],value[2],value[3],false);
         startJob();
         break;
      case "Change Image Size":
        setImageSize(value[0],value[1],false);
        let val = value[0] + " " + value[1];
        if (["0 0", "640 480", "800 600", "1024 768", "1600 1200", "1920 1080", "1920 1200", "2560 1440", "2880 1800", "3840 1080", "3840 2160", "5120 1440", "7680 4320"].indexOf(val) < 0) {
            document.getElementById("imagesize").value = "Custom";
            document.getElementById("customsize").style.display = "inline";
            document.getElementById("customwidth").value = "" + value[0];
            document.getElementById("customheight").value = "" + value[1];
        }
        else {
            document.getElementById("imagesize").value = val;
            document.getElementById("customsize").style.display = "none";
        }
        break;
      case "Change PaletteLength":
        mainPaletteLengthSlider.setState(value);
        setFixedPaletteLength(mainPaletteLengthSlider.value);
        break;
      case "Change MaxIterations":
         maxIterSlider.setValue(value[0]);
         setMaxIterations();
         mainPaletteLengthSlider.setState(value[1]);
         setFixedPaletteLength(mainPaletteLengthSlider.value);
         break;
      case "Change Palette":
         palette = value[0].copy();
         paletteSelectSlider.setValue(value[1]);
         createPaletteColors();
         remapColors();
         break;
      case "Edit Palette":
        palette = value[0].copy();
        mainPaletteOffsetSlider.setValue(value[2]*100);
        paletteSelectSlider.setPaletteSelectSliderState(value[3]);
        mainPaletteLengthSlider.setValue(value[1]);
        setFixedPaletteLength(mainPaletteLengthSlider.value);
        break;
      case "Pinch Zoom Out":
      case "Pinch Zoom In":
      case "Zoom Out":
      case "Zoom In":
      case "Move":
        // console.log(value);
        switch (value[0]) {
            case ZOOM:
                zoom(value[1], value[2], value[3], value[4], false);
                break;
            case ZOOMINRECT:
                stopJob();
                doZoomInOnRect(value[1], value[2], value[3], value[4], false);
                startJob();
                break;
            case ZOOMOUTRECT:
                stopJob();
                doZoomOutFromRect(value[1], value[2], value[3], value[4], false);
                startJob();
                break;
        }
        break;
    }
    applyUndoInProgress = false;
}

//--------------------- Palette ------------------------------------------
function Palette(colorType,divisionPoints,colors) {
   this.colorType = colorType || "HSB";
   this.divisionPoints = divisionPoints || [0,1];
   this.divisionColors = colors || (this.colorType == "HSB" ? [ [0,1,1], [1,1,1] ] : [ [1,1,1], [0,0,0] ]);
}
Palette.prototype.getColor = function(position) {  // 0.0 <= position <= 1.0
    var pt = 1;
    while (position > this.divisionPoints[pt])
        pt++;
    var ratio = (position - this.divisionPoints[pt-1]) /
                   (this.divisionPoints[pt] - this.divisionPoints[pt-1]);
    var c1 = this.divisionColors[pt-1];
    var c2 = this.divisionColors[pt];
    var a = c1[0] + ratio*(c2[0] - c1[0]);
    var b = c1[1] + ratio*(c2[1] - c1[1]);
    var c = c1[2] + ratio*(c2[2] - c1[2]);
    return this.toRGB(a,b,c);
};
Palette.prototype.toRGB = function(a,b,c) {  // 3 non-clamped color components.
    a = (this.colorType == "HSB")? (a - Math.floor(a)) : clamp(a);
    b = clamp(b);
    c = clamp(c);
    var color;
    if (this.colorType == "HSB")
        color = rgbFromHSV(a, b, c);
    else
        color = [a,b,c];
    color[0] = Math.round(color[0]*255);
    color[1] = Math.round(color[1]*255);
    color[2] = Math.round(color[2]*255);
    return color;
	function clamp(x) {
		x = 2*(x/2 - Math.floor(x/2));
		if (x > 1)
			x = 2 - x;
		return x;
	}
    function rgbFromHSV(h,s,v) {  // all components in range 0 to 1
        h *= 360;
        var r,g,b;
        var c,x;
        c = v*s;
        x = (h < 120)? h/60 : (h < 240)? (h-120)/60 : (h-240)/60;
        x = c * (1-Math.abs(x-1));
        x += (v-c);
        switch (Math.floor(h/60)) {
            case 0: r = v; g = x; b = v-c; break;
            case 1: r = x; g = v; b = v-c; break;
            case 2: r = v-c; g = v; b = x; break;
            case 3: r = v-c; g = x; b = v; break;
            case 4: r = x; g = v-c; b = v; break;
            case 5: r = v; g = v-c; b = x; break;
        }
        return [r,g,b];
    }
};
Palette.prototype.makeRGBs = function(paletteLength, offset) {
    var rgb = new Array(paletteLength);
    rgb[offset % paletteLength] =
             this.toRGB(this.divisionColors[0][0],this.divisionColors[0][1],this.divisionColors[0][2]);
    var dx = 1.0 / (paletteLength-1);
    for (var i = 1; i < paletteLength-1; i++) {
        rgb[(offset+i) % paletteLength] = this.getColor(i*dx);
    }
    var last = this.divisionColors.length - 1;
    rgb[(offset+paletteLength-1) % paletteLength] =
              this.toRGB(this.divisionColors[last][0],this.divisionColors[last][1],this.divisionColors[last][2]);
    return rgb;
};
Palette.prototype.makeCanvasColors = function(paletteLength, offset) {
    var rgb = this.makeRGBs(paletteLength,offset);
    var colors = new Array(rgb.length);
    for (var i = 0; i < rgb.length; i++)
        colors[i] = "rgb(" + rgb[i][0] + "," + rgb[i][1] + "," + rgb[i][2] + ")";
    return colors;
};
Palette.prototype.toXMLString = function() {
   var xml = "<palette colorType='" + this.colorType + "'>\n";
   for (var i = 0; i < this.divisionPoints.length; i++) {
       xml += "   <divisionPoint position='" + this.divisionPoints[i] + "' color='" +
            this.divisionColors[i][0] + ";" + this.divisionColors[i][1] + ";" +this.divisionColors[i][2] +
            "'/>\n";
   }
   xml += "</palette>\n";
   return xml;
};
Palette.prototype.copy = function() {
    var divColors = [];
    for (var i = 0; i < this.divisionColors.length; i++) {
        divColors.push(this.divisionColors[i].slice(0));
    }
    return new Palette(this.colorType,this.divisionPoints.slice(0),divColors);
};
Palette.fromXML = function( paletteNode ) {  // can throw an exception
    try {
       var children = paletteNode.childNodes;
       var type = paletteNode.getAttribute("colorType") || "RBG";
       if (type != "HSB" && type != "RGB") {
           throw "Bad colorType.";
       }
       var points = [];
       var colors = [];
       for (var i = 0; i < children.length; i++) {
          var child = children.item(i);
          if (child.nodeType == 1 && child.tagName == "divisionPoint") { // element node
              var pt = child.getAttribute("position");
              var rgb = child.getAttribute("color");
              if (pt === null || rgb === null) {
                  throw "Missing data for divisionPoint";
              }
              pt = Number(pt);
              rgb = rgb.split(";");
              rgb = [Number(rgb[0]),Number(rgb[1]),Number(rgb[2])];
              if (isNaN(pt) || pt < 0 || pt > 1) {
                   throw "Bad data for divisionPoint";
              }
              for (var j = 0; j < 3; j++) {
                   if (isNaN(rgb[j]) || rgb[j] < 0 ){
                      throw "Bad data for divisionPoint color";
                   }
                   else if (rgb[j] < 0) {
                      throw "Color component number " + (j+1) + " can't be less than zero.";
                   }
                   else if (rgb[j] > 1 && (j > 0 || type == "RGB")) {
                      throw "Color component number " + (j+1) + " can't be greater than one.";
                   }
              }
              if (i > 0 && pt <= points[points.length-1]) {
                  throw "Division points out of order";
              }
              points.push(pt);
              colors.push(rgb);
          }
       }
       if (points.length < 2 || points[0] != 0 || points[points.length-1] != 1) {
           throw "Illegal divisionPoint data";
       }
       return new Palette(type, points, colors);
    }
    catch (e) {
        throw "Illegal palette definition: " + e;
    }
};
Palette.createStandardPalette = function(name) {
    var palette;
    switch (name) {
        case "Grayscale":
           palette = new Palette("RGB");
           break;
        case "CyclicGrayscale":
           palette = new Palette("RGB",[0,0.5,1],[[0,0,0],[1,1,1],[0,0,0]]);
           break;
        case "Red/Cyan":
           palette = new Palette("RGB",[0,0.5,1],[[1,0,0],[0,1,1],[1,0,0]]);
           break;
        case "Blue/Gold":
           palette = new Palette("RGB",[0,0.5,1],[[0.1,0.1,1],[1,0.6,0],[0.3,0.3,1]]);
           break;
        case "EarthAndSky":
           palette = new Palette("RGB",[0,0.15,0.33,0.67,0.85,1],
                     [[1,1,1],[1,0.8,0],[0.53,0.12,0.075],[0,0,0.6],[0,0.4,1],[1,1,1]]);
           break;
        case "HotAndCold":
           palette = new Palette("RGB",[0,0.16,0.5,0.84,1],
                     [[1,1,1],[0,0.4,1],[0.2,0.2,0.2],[1,0,0.8],[1,1,1]]);
           break;
        case "Fire":
           palette = new Palette("RGB",[0,0.17,0.83,1],
                     [[0,0,0],[1,0,0],[1,1,0],[1,1,1]]);
           break;
        case "Cyclic Fire":
           palette = new Palette("RGB",[0,0.2,0.4,0.5,0.6,0.8,1],
                     [[0,0,0],[1,0,0],[1,1,0],[1,1,1],[1,1,0],[1,0,0],[0,0,0]]);
           break;
        case "TreeColors":
           palette = new Palette("HSB",[0,0.33,0.66,1],
                     [[0.1266,0.5955,0.2993],[0.0896,0.3566,0.6575],[0.6195,0.8215,0.4039],[0.1266,0.5955,0.2993]]);
           break;
        case "Seashore":
           palette = new Palette("RGB",[0,0.1667,0.3333,0.5,0.6667,0.8333,1],
                     [[0.7909,0.9961,0.7630],[0.8974,0.8953,0.6565],[0.9465,0.3161,0.1267],[0.5184,0.1109,0.0917],
                              [0.0198,0.4563,0.6839],[0.5385,0.8259,0.8177],[0.7909,0.9961,0.7630]]);
           break;
        case "Pastels":
           palette = new Palette("RGB",[0,0.180781,0.418566,0.627035,0.858306,1],
                     [ [ 0.80585,0.81648,0.82180 ], [ 0.43882,0.52393,1 ], [ 1,0.35904,0.58244 ],
                       [ 1,1,0.52127 ], [ 0.54787,0.93351,0.56914 ], [ 0.80585,0.81648,0.82180 ] ]);
           break;
        case "Dark":
           palette = new Palette("RGB",['0','0.18241042','0.38599348','0.57166123','0.78338762','1'],
                         [  [0.65957446,0,0],[0,0.30585106,0.58776595],[0.81648936,0.41489361,0.07180851],
                                [0,0.48670212,0.16489361],[0.29787234,0.13829787,0.75],[0.65957446,0,0] ]);
//           palette = new Palette("RGB",[0,0.18241,0.38599,0.57166,0.78338,1],
//                       [ [0.65957,0,0],[0,0.40159,0.74734],[0.87234,0.49202,0.07180],
//                           [0,0.48670,0.16489],[0.29787,0.13829,0.75], [0.65957,0,0] ]);
           break;
        case "Random":
           var c = [Math.random(),Math.random(),Math.random()];
           palette = new Palette("RGB",[],[]);
           palette.divisionPoints[0] = 0;
           palette.divisionColors[0] = c;
           for (var i = 1; i <= 5; i++) {
               palette.divisionPoints[i] = i/6;
               palette.divisionColors[i] = [Math.random(),Math.random(),Math.random()];
           }
           palette.divisionPoints[6] = 1;
           palette.divisionColors[6] = c;
           break;
        case "Custom":
            palette = paletteSelectSlider.data.customPalette;
            break;
        case "Spectrum":
            palette = new Palette();
            break;
        default:
            console.error("unknown palette:", name);
            break;
    }
    return palette;
};

//----- Palette Editor ---------------------------------------------------------------

function showPaletteEditor() {
    document.removeEventListener("keydown", handleCanvasKeys);
    if (!colorEditCanvas) {  // showing for the first time, do initialization
        document.getElementById("applyPaletteEdit").onclick = applyAndClose;
        document.getElementById("revertPaletteEdit").onclick = revert;
        document.getElementById("dismissPaletteEdit").onclick = dismiss;
        document.getElementById("addcolorstop").onclick = function() { colorEditCanvas.addColorStop(); };
        document.getElementById("deletecolorstop").onclick = function() { colorEditCanvas.deleteColorStop(); };
        document.getElementById("lockcolors").onchange = setLeftRightColorsLocked;
        document.getElementById("paletteEditStandardInstall").onclick = installStandard;
        document.getElementById("paletteEditStandardSelect").value = "EarthAndSky";
        document.addEventListener("keydown", doKey, false);
        updateDuringDrag = document.getElementById("updateWhileDraggingCheck").checked;
        document.getElementById("updateWhileDraggingCheck").oninput = function() { 
           updateDuringDrag =document.getElementById("updateWhileDraggingCheck").checked;
        };
        histogramPalette = document.getElementById("histogrampalette");
        colorEditCanvas = new ColorEditCanvas();
        colorSliders = [ 
           new SliderAndInput(document.getElementById("colorslider0"), document.getElementById("colorinput0"), 0, 1),
           new SliderAndInput(document.getElementById("colorslider1"), document.getElementById("colorinput1"), 0, 1),
           new SliderAndInput(document.getElementById("colorslider2"), document.getElementById("colorinput2"), 0, 1)
        ];
        colorSliders[0].onchange = function(v) { newColorSliderValue(0,v); };
        colorSliders[1].onchange = function(v) { newColorSliderValue(1,v); };
        colorSliders[2].onchange = function(v) { newColorSliderValue(2,v); };
        paletteLengthSlider = new SliderAndInput(document.getElementById("lengthslider"), document.getElementById("editorlengthinput"), 1, maxIterSlider.value, paletteLength, true, true);
        paletteOffsetSlider = new SliderAndInput(document.getElementById("offsetslider"), document.getElementById("editoroffsetinput"), 0, 100, mainPaletteOffsetSlider.value);
        paletteLengthSlider.onchange = newPaletteMappingInEditor;
        paletteOffsetSlider.onchange = newPaletteMappingInEditor;
    }
    paletteEditInProgress = true;
    document.getElementById("paletteEditor").style.display="block";
    document.getElementById("xmlimportbg").style.display = "block";
    copyOfCurrentPalette = palette.copy();
    histogram = new Histogram();
    palettePreview = new PalettePreview();
    installPaletteInEditor(palette);
    paletteLengthSlider.reset(1,maxIterSlider.value,paletteLength);
    paletteOffsetSlider.setValue(mainPaletteOffsetSlider.value);
    document.getElementById("applyPaletteEdit").disabled = true;
    document.getElementById("revertPaletteEdit").disabled = true;
    function applyAndClose() {
        const oldPaletteSelectSliderState = paletteSelectSlider.getPaletteSelectSliderState();
        paletteSelectSlider.setCustomPalette(paletteInEditor);
        const newval = [paletteInEditor, paletteLengthInEditor, paletteOffsetFractionInEditor,
            paletteSelectSlider.getPaletteSelectSliderState()];
        addUndoItem("Edit Palette",
                [copyOfCurrentPalette, fixedPaletteLength, mainPaletteOffsetSlider.value/100,
                    oldPaletteSelectSliderState],
                newval);
        applyUndoItem("Edit Palette", newval);
        dismiss();
    }
    function dismiss() {
        document.getElementById("xmlimportbg").style.display = "none";
        document.getElementById("paletteEditor").style.display = "none";
        document.removeEventListener("keydown", doKey, false);
        document.addEventListener("keydown", handleCanvasKeys);
        paletteEditInProgress = false;
        histogram = null;
        palettePreview = null;
        paletteInEditor = null;
        colorsInEditor = null;
    }
    function revert() { 
        installPaletteInEditor( copyOfCurrentPalette );
        palettePreview.redraw();
        document.getElementById("applyPaletteEdit").disabled = true;
        document.getElementById("revertPaletteEdit").disabled = true;
    }
    function installStandard() {
        var name = document.getElementById("paletteEditStandardSelect").value;
        var p = Palette.createStandardPalette(name);
        installPaletteInEditor( p, paletteLengthInEditor, paletteOffsetFractionInEditor );
        document.getElementById("applyPaletteEdit").disabled = false;
        document.getElementById("revertPaletteEdit").disabled = false;
        palettePreview.redraw();
    }
    function doKey(evt) {
        var code = evt.keyCode;
        if (code == 27) {
            dismiss();
        }
    }
}

var copyOfCurrentPalette;
var paletteInEditor;
var paletteLengthInEditor;
var paletteOffsetFractionInEditor;
var histogram;
var histogramPalette;
var palettePreview;
var colorEditCanvas = null;
var leftRightColorsLocked;
var saveRightColorWhileLocked;
var colorsInEditor;
var colorSliders;
var paletteLengthSlider;
var paletteOffsetSlider;
var updateDuringDrag;

function installPaletteInEditor(palette,length,offsetFraction) {
    paletteInEditor = palette.copy();
    var leftCol = paletteInEditor.divisionColors[0];
    var rightCol = paletteInEditor.divisionColors[paletteInEditor.divisionColors.length-1];
    var locked = leftCol[1] == rightCol[1] && leftCol[2] == rightCol[2] &&
           (leftCol[0] == rightCol[0] || (paletteInEditor.colorType == "HSB" &&
                leftCol[0] - Math.floor(leftCol[0]) == rightCol[0] - Math.floor(rightCol[0])));
    colorEditCanvas.setLocked(locked,true);
    document.getElementById("lockcolors").checked = locked;
    paletteLengthInEditor = (typeof length != "undefined")? length : paletteLength;
    paletteLengthSlider.setValue(paletteLengthInEditor);
    paletteOffsetFractionInEditor = (typeof offsetFraction != "undefined")? offsetFraction : mainPaletteOffsetSlider.value/100;
    paletteOffsetSlider.setValue(paletteOffsetFractionInEditor*100);
    colorEditCanvas.colorsChanged();
    colorEditCanvas.select(0);
    newColorsInEditor();
    if (!updateDuringDrag)
        palettePreview.redraw();
    if (palette.colorType == "RGB") {
        document.getElementById("colorlabel0").innerHTML = "Red";
        document.getElementById("colorlabel1").innerHTML = "Green";
        document.getElementById("colorlabel2").innerHTML = "Blue";
    }
    else {
        document.getElementById("colorlabel0").innerHTML = "Hue";
        document.getElementById("colorlabel1").innerHTML = "Saturation";
        document.getElementById("colorlabel2").innerHTML = "Brightness";
    }
    if (palette.colorType == "HSB")
        colorSliders[0].setAllowOutOfRange( true, true  );
    else
        colorSliders[0].setAllowOutOfRange( false, false);
    if (palette.colorType == "HSB") { 
       var n = Math.floor(palette.divisionColors[0][0]);
       colorSliders[0].reset(n,n+1,palette.divisionColors[0][0]);
       colorSliders[0].canvas.title = "Drag the slider to set the hue of the selected color stop to a value in the range " +
                                       n + " to " + (n+1) + ". Values outside this range can be set in the textbox.";
    }
    else {
       colorSliders[0].reset(0,1,palette.divisionColors[0][0]);
       colorSliders[0].canvas.title = "Drag the slider to set the red component of the selected color stop to a value in the range 0.0 to 1.0.";
    }
    colorSliders[1].setValue(palette.divisionColors[0][1]);
    colorSliders[2].setValue(palette.divisionColors[0][2]);
}

function newColorsInEditor() {
    var offset = Math.round(paletteLengthInEditor * paletteOffsetFractionInEditor);
    colorsInEditor = paletteInEditor.makeCanvasColors(paletteLengthInEditor,offset);
    colorEditCanvas.draw();
    if (updateDuringDrag)
        palettePreview.redraw();
    redrawHistogramPalette();
    document.getElementById("applyPaletteEdit").disabled = false;
    document.getElementById("revertPaletteEdit").disabled = false;
}

function newPaletteMappingInEditor() {
    paletteLengthInEditor = paletteLengthSlider.value;
    paletteOffsetFractionInEditor = paletteOffsetSlider.value / 100;
    var offset = Math.round(paletteLengthInEditor * paletteOffsetFractionInEditor);
    colorsInEditor = paletteInEditor.makeCanvasColors(paletteLengthInEditor,offset);
    if (updateDuringDrag)
        palettePreview.redraw();
    redrawHistogramPalette();
    document.getElementById("applyPaletteEdit").disabled = false;
    document.getElementById("revertPaletteEdit").disabled = false;
}

function newColorSliderValue(componentIndex,value) {
   var colorNum = colorEditCanvas.getSelected();
   var color = paletteInEditor.divisionColors[colorNum];
   color[componentIndex] = value;
   var color2 = null;
   if (leftRightColorsLocked) {
       if (colorNum == 0) {
           color2 = paletteInEditor.divisionColors[paletteInEditor.divisionColors.length-1];
       }
       else if (colorNum == paletteInEditor.divisionColors.length-1) {
           color2 = paletteInEditor.divisionColors[0];
       }
   }
   if (color2 != null) {
       if (componentIndex == 0 && paletteInEditor.colorType == "HSB") {
           var n = Math.floor(color2[0]);
           color2[0] = n + (value - Math.floor(value));
       }
       else {
           color2[componentIndex] = value;
       }
       saveRightColorWhileLocked = null;
   }
   colorEditCanvas.colorsChanged();
   newColorsInEditor();
}

function redrawHistogramPalette() {
     var hg = histogramPalette.getContext('2d');
     var onecopy = paletteLengthInEditor/maxIterSlider.value * (histogramPalette.width-2);
     for (var i = 1; i < histogramPalette.width-1; i++) {
         var fraction = ((i-1) % onecopy) / onecopy;
         var index = Math.max(0, Math.min(colorsInEditor.length,Math.round(fraction * colorsInEditor.length)));
         hg.fillStyle = colorsInEditor[index];
         hg.fillRect(i,0,1,histogramPalette.height);
     }
     hg.strokeStyle = "black";
     hg.strokeRect(0.5,0.5,histogramPalette.width-1,histogramPalette.height-1);
}

function setLeftRightColorsLocked() {
    var locked = document.getElementById("lockcolors").checked;
    colorEditCanvas.setLocked(locked);
}

function ColorEditCanvas() {
    var canvas = document.getElementById("coloredit");
    var g = canvas.getContext('2d');
    var size = canvas.width - 16;
    var colors = null;
    var selected;
    var prevX;
    var me = this;
    new Mouser(canvas, 
       function(x,y) {
           for (var i = 0; i < paletteInEditor.divisionPoints.length; i++) {
              var p = 8 + Math.floor(paletteInEditor.divisionPoints[i] * size);
              if ((x > p-2 && x < p+3) || (y > 48 && (x > p-6 & x < p+7))) {
                  prevX = x;
                  if (i != selected) {
                      me.select(i);
                      me.draw();
                  }
                  return i > 0 && i < paletteInEditor.divisionPoints.length - 1;
              }
           }
           return false;
       },
       function (x,y) {
            var position = 8 + Math.floor(paletteInEditor.divisionPoints[selected] * size);
            var left = 8 + Math.floor(paletteInEditor.divisionPoints[selected-1] * size);
            var right = 8 + Math.floor(paletteInEditor.divisionPoints[selected+1] * size);
            var change = x - prevX;
            prevX = x;
            var newposition = Math.min(right-10,Math.max(left+10,position + change));
            if (newposition != position) {
                paletteInEditor.divisionPoints[selected] = (newposition-8)/size;
                colors = null;
                newColorsInEditor();
            }
       },
       function () {
               if (!updateDuringDrag)
                   palettePreview.redraw();
           }
     );
     canvas.ondblclick = function(evt) {
        if (evt.button != 0)
           return;
        var r = canvas.getBoundingClientRect();
        var x = evt.clientX - r.left;
        var y = evt.clientY - r.top;    
        if (y > 50)
           return;
        for (var i = 1; i < paletteInEditor.divisionPoints.length; i++) {
            var leftDP = paletteInEditor.divisionPoints[i-1];
            var rightDP = paletteInEditor.divisionPoints[i];
            var left = 8 + Math.floor( leftDP * size);
            var right = 8 + Math.floor(rightDP * size);
            if (x > left+9 && x < right-9) {
                var divisionPt = (x-8)/size;
                var t = (divisionPt - leftDP) / (rightDP - leftDP);
                var leftCol = paletteInEditor.divisionColors[i-1];
                var rightCol = paletteInEditor.divisionColors[i];
                var col = [ (1-t)*leftCol[0]+t*rightCol[0], (1-t)*leftCol[1]+t*rightCol[1], (1-t)*leftCol[2]+t*rightCol[2] ];
                paletteInEditor.divisionPoints.splice(i,0,divisionPt);
                paletteInEditor.divisionColors.splice(i,0,col);
                me.select(i);
                me.draw();
                break;
            }
        }
     };
     this.addColorStop = function() {
         var left = selected - 1;
         var right = selected + 1; 
         while (left >= 0 || right < paletteInEditor.divisionPoints.length) {
                // try to find room alternately to left and to right of selected stop
            if (placeColorStopBetween(right-1,right))
               return;
            right++;
            if (placeColorStopBetween(left,left+1))
                return;
            left--;
         }
         alert("Sorry, can't find room for another color stop.");
         function placeColorStopBetween( a, b ) {  // b - a = 1
             if (a < 0 || b >= paletteInEditor.divisionPoints.length)
                return false;
             var leftDP = paletteInEditor.divisionPoints[a];
             var rightDP = paletteInEditor.divisionPoints[b];
             if ( (rightDP-leftDP)*size > 19) {
                var divisionPt = (leftDP + rightDP)/2;
                var leftCol = paletteInEditor.divisionColors[a];
                var rightCol = paletteInEditor.divisionColors[b];
                var col = [ (leftCol[0]+rightCol[0])/2, (leftCol[1]+rightCol[1])/2, (leftCol[2]+rightCol[2])/2 ];
                paletteInEditor.divisionPoints.splice(b,0,divisionPt);
                paletteInEditor.divisionColors.splice(b,0,col);
                me.select(b);
                me.draw();
                return true;
             }
             return false;
         }
     };
     this.deleteColorStop = function() {
         if (selected > 0 && selected < paletteInEditor.divisionPoints.length-1) {
             paletteInEditor.divisionPoints.splice(selected,1);
             paletteInEditor.divisionColors.splice(selected,1);
             me.select(selected-1);
             colors = null;
             newColorsInEditor();
             me.draw();
         }
     };
     this.setLocked = function(lock,onInstall) {
         leftRightColorsLocked = lock;
         if (onInstall) {
             saveRightColorWhileLocked = null;
             return;
         }
         var leftCol = paletteInEditor.divisionColors[0];
         var rightCol = paletteInEditor.divisionColors[paletteInEditor.divisionColors.length-1];
         if (leftRightColorsLocked) {
            var save = [];
            save.push(rightCol[0]);
            save.push(rightCol[1]);
            save.push(rightCol[2]);
            rightCol[1] = leftCol[1];
            rightCol[2] = leftCol[2];
            if (paletteInEditor.colorType == "HSB") {
                var n = Math.floor(rightCol[0]);
                rightCol[0] = n + (leftCol[0] - Math.floor(leftCol[0]));
            }
            else {
                rightCol[0] = leftCol[0];
            }
            colors = null;
            newColorsInEditor();
            if (selected == paletteInEditor.divisionColors.length-1)
               me.select(selected);
            saveRightColorWhileLocked = save;
         }
         else if (saveRightColorWhileLocked != null) {
            rightCol[0] = saveRightColorWhileLocked[0];
            rightCol[1] = saveRightColorWhileLocked[1];
            rightCol[2] = saveRightColorWhileLocked[2];
            saveRightColorWhileLocked = null;
            colors = null;
            newColorsInEditor();
            if (selected == paletteInEditor.divisionColors.length-1)
               me.select(selected);
         }
     };
     this.select = function(colorIndex) {
         selected = colorIndex;
         if (paletteInEditor.colorType == "HSB") { 
            var n = Math.floor(paletteInEditor.divisionColors[selected][0]); 
            colorSliders[0].reset(n,n+1,paletteInEditor.divisionColors[selected][0]);
            colorSliders[0].canvas.title = "Drag the slider to set the hue of the selected color stop to a value in the range " +
                                            n + " to " + (n+1) + ". Values outside this range can be set in the textbox.";
         }
         else {
             colorSliders[0].setValue(paletteInEditor.divisionColors[selected][0]);
         }
         colorSliders[1].setValue(paletteInEditor.divisionColors[selected][1]);
         colorSliders[2].setValue(paletteInEditor.divisionColors[selected][2]);
         document.getElementById("deletecolorstop").disabled = !(selected > 0 && selected < paletteInEditor.divisionPoints.length-1);
     };
     this.getSelected = function() {
        return selected;
     };
     this.colorsChanged = function() {
        colors = null;
     };
     this.draw = function() {
         g.fillStyle = "#e8e8e8";
         g.fillRect(0,0,canvas.width,canvas.height);
         if (colors == null)
             colors = paletteInEditor.makeCanvasColors(size,0);
         for (var i = 0; i < size; i++) {
             g.fillStyle = colors[i];
             g.fillRect(8+i,3,1,40);
         }
         g.lineWidth = 2;
         g.strokeRect(7,2,size+2,41);
         for (var i = 0; i < paletteInEditor.divisionPoints.length; i++) {
            var x = 8 + Math.floor(paletteInEditor.divisionPoints[i] * size);
            var c = paletteInEditor.divisionColors[i]; 
            c = paletteInEditor.toRGB(c[0],c[1],c[2]); 
            c = "rgb(" + c[0] + "," + c[1] + "," + c[2] + ")";
            if ( i == selected ) {
                g.fillStyle = "black";
                g.fillRect(x-3,1,6,42);
                g.fillRect(x-7,51,14,29);
                g.fillStyle = "lightgray";
                g.fillRect(x-2,2,4,40);
                g.fillRect(x-6,52,12,27);
                g.fillStyle = c;
                g.fillRect(x-1,3,2,38);
            }
            g.fillStyle = "black";
            g.fillRect(x-1,43,2,10);
            g.fillRect(x-5,53,10,25);
            g.fillStyle = c;
            g.fillRect(x-4,54,8,23);
         }
     };
}

function PalettePreview() {
   var previewIterationCounts;
   var previewRect;
   var preview = document.getElementById("preview");
   var g = preview.getContext("2d");
   if (canvas.width >= canvas.height) {
       var h = Math.round(canvas.height/canvas.width * (preview.height-2));
       previewRect = { left:1, top: 1+Math.floor((preview.height-h)/2), width: preview.width-2, height: h };
   }
   else {
       var w = Math.round(canvas.width/canvas.height * (preview.width-2));
       previewRect = { left: 1+Math.floor((preview.width-w)/2), top: 1, width: w, height: preview.height-2 };
   }
   var previewCounts = new Array(previewRect.height);
   var desiredRow = new Array(previewRect.height+1);
   var currentRow = new Array(previewRect.height);
   var i,j;
   for (i = 0; i < previewRect.height; i++) {
       desiredRow[i] = Math.floor( i * canvas.height/previewRect.height );
       currentRow[i] = -1;
   }
   desiredRow[previewRect.height+1] = canvas.height;
   for (i = 0; i < previewRect.height; i++) {
       for (j = desiredRow[i]; j < desiredRow[i+1]; j++) {
           if (savedIterationCounts[j]) {
               currentRow[i] = j;
               previewCounts[i] = new Int32Array(previewRect.width);
               for (var k = 0; k < previewRect.width; k++) {
                   var index = Math.floor( k / previewRect.width * savedIterationCounts[j].length );
                   previewCounts[i][k] = savedIterationCounts[j][index];
               }
               break;
           }
       }
   }
   this.update = function(newRowNumber, newRowCounts) {
      for (var k = 0; k < previewRect.height; k++) { 
          if (newRowNumber < desiredRow[k+1]) { 
             if (currentRow[k] == -1 || (currentRow[k] != desiredRow[k] && newRowNumber < currentRow[k])) { 
                 currentRow[k] = newRowNumber;
                 newColors(k,newRowCounts);
             }
             break;
          }
      }
   };
   function newColors(row,counts) {
       previewCounts[row] = new Int32Array(previewRect.width);
       for (var k = 0; k < previewRect.width; k++) {
           var index = Math.floor( k / previewRect.width * counts.length );
           previewCounts[row][k] = counts[index];
       }
       showRow(row);
   }
   function showRow(row) { 
       for (var k = 0; k < previewRect.width; k++) {
           if (previewCounts[row][k] == -1)
               g.fillStyle="black";
           else {
               var index = previewCounts[row][k] % paletteLengthInEditor;
               g.fillStyle = colorsInEditor[index];
           }
           g.fillRect(k+previewRect.left,row+previewRect.top,1,1);
       }
   }
   function drawBG() {
      g.fillStyle="#e8e8e8";
      g.fillRect(0,0,preview.width,preview.height);
      g.lineWidth = 1;
      g.strokeStyle = "black";
      g.strokeRect( previewRect.left-0.5, previewRect.top-0.5, previewRect.width+1, previewRect.height );
   }
   this.redraw = function() {
      drawBG();
      for (var i = 0; i < previewCounts.length; i++) {
         if (previewCounts[i])
             showRow(i);
      }
   };
}

function Histogram() {
   var canvas = document.getElementById("histogram");
   var histogramWidth = canvas.width - 15;
   var histogramHeight = canvas.height - 15;
   var histogramCounts = new Int32Array(maxIterSlider.value+1);
   for (var j = 0; j < savedIterationCounts.length; j++) {
       if (savedIterationCounts[j]) {
          var counts = savedIterationCounts[j];
          for (var k = 0; k < counts.length; k++)
              histogramCounts[counts[k]] ++;
       }
   }
   this.update = function(newcounts) {
       for (var i = 0; i < newcounts.length; i++) {
           histogramCounts[newcounts[i]] ++;
       }
       redraw();
   };
   function redraw() {
       var g = canvas.getContext("2d");
       g.fillStyle = "white";
       g.fillRect(0,0,canvas.width,canvas.height);
       g.lineWidth = 2;
       g.strokeStyle = "red";
       g.beginPath();
       g.moveTo(8,5);
       g.lineTo(8,canvas.height-8);
       g.lineTo(canvas.width-5,canvas.height-8);
       g.stroke();
       var i,a,b;
       var maxct = 0;
       for (i = 1; i < histogramCounts.length; i++)
           maxct = Math.max(histogramCounts[i],maxct);
       if (maxct == 0)
           return;
       g.lineWidth=1;
       g.strokeStyle="black";
       g.beginPath();
       for (i = 1; i < histogramCounts.length; i++) {
           if (histogramCounts[i] > 0) {
               a = Math.round(i/histogramCounts.length * histogramWidth) + 10.5;
               b = Math.ceil(histogramCounts[i]/maxct * histogramHeight) + 0.5; 
               g.moveTo(a,canvas.height-10);
               g.lineTo(a,canvas.height-10-b);
           }
       }
       g.stroke();
   }
   redraw();
}

function SliderAndInput(canvas,textbox,min,max,val,integerOnly,allowOutOfRange) {
    this.canvas = canvas;
    this.textbox = textbox;
    this.min = (typeof min == "number")? min : 0.0;    
    this.max = (typeof max == "number")? max : this.min + 100.0;    
    this.value = (typeof val == "number")? val : this.min;
    this.integerOnly = (typeof integerOnly == "undefined")? false : integerOnly;
    this.allowOutOfRange = (typeof allowOutOfRange == "undefined")? false : allowOutOfRange;
    this.allowLessThanMin = false;
    this.g = this.canvas.getContext("2d");
    this.g.translate(0,-8);  // fudge for resuing old code
    this.size = this.canvas.width - 25;
    if (this.allowOutOfRange)
       this.size -= 20;
    this.setTabLeft();
    this.valueToTextbox();
    this.draw();
    this.onchange = null;
    var me = this;
    var valueInTextbox, savedValueWhileEditing, saveTitle;
    textbox.style.color = "black";
    textbox.style.backgroundColor = "white";
    textbox.style.padding = "2px";
    textbox.onfocus = function() { 
        valueInTextbox = savedValueWhileEditing = this.value; 
        textbox.style.backgroundColor="#d8ffd8";
        saveTitle = textbox.title;
        textbox.title = "Editing slider value. Press return or move to another input box to apply the new value, if legal.";
    };
    textbox.onblur = function() { 
        textbox.style.backgroundColor="white";
        if (checkTextbox())
            me.setValue(valueInTextbox);
        else
            me.setValue(savedValueWhileEditing);
        if (!updateDuringDrag)
            palettePreview.redraw();
        me.valueToTextbox();
        textbox.title = saveTitle;
        textbox.style.backgroundColor = "white";
    };
    textbox.oninput = function() { 
        checkTextbox();
    };
    textbox.onkeydown = function(evt) {
       if (evt.keyCode == 13 && checkTextbox()) {
          me.setValue(valueInTextbox);
          valueInTextbox = me.value;
          if (!updateDuringDrag)
              palettePreview.redraw();
       }
    };
    function checkTextbox() {
       var val = Number(textbox.value);
       if (isNaN(val)) {
           textbox.style.backgroundColor = "#ff9090";
           textbox.title = "The value in the input box is not a number!";
           return false;
       }
       if (me.integerOnly)
          val = Math.round(val);
       if (val < 0 || (val < me.min && !me.allowLessThanMin) || (val > me.max && !me.allowOutOfRange)) {
           textbox.style.backgroundColor = "#ffff90";
           textbox.title = "The value in the textbox is not in the legal range for the slider";
           return false;
       }
       valueInTextbox = val;
       textbox.style.backgroundColor="#d8ffd8";
       textbox.title = "Editing slider value. Press return or move to another input box to apply the new value, if legal.";
       return true;
    }
    var offset;
    new Mouser(this.canvas,
        function(x,y) {
           if (y < 23 && x > me.tabLeft - 2 && x < me.tabLeft + 22) {
              offset = x - (me.tabLeft+10);
              return true;
           }
           else if (y > 20 && x > 14 && x < me.canvas.width - 5) {
              var val = (x - 15)/me.size * (me.max-me.min) + me.min;
              me.setValue(val);
              return false;
           }
        },
        function(x,y) {
           x = x - offset;
           var val = (x - 15)/me.size * (me.max-me.min) + me.min;
           if (val > me.max)
              val = me.max;
           if (val < me.min)
              val = me.min;
           me.setValue(val); 
        },
        function() {
            if (!updateDuringDrag)
                palettePreview.redraw();
        }
    );
}
SliderAndInput.prototype.setAllowOutOfRange = function( allow, allowLessThanMin ) {
    if (this.allowOutOfRange == allow && this.allowLessThanMin == allowLessThanMin)
       return;
    this.allowOutOfRange = allow;
    if (allowLessThanMin)
        this.allowLessThanMin = true;
    else
        this.allowLessThanMin = false;
    this.size = this.canvas.width - 25;
    if (this.allowOutOfRange)
       this.size -= 20;
    this.setTabLeft();
    this.draw();
};
SliderAndInput.prototype.reset = function(min,max,val) {
//    if (this.min != min || this.max != max) {
        this.min = min;
        this.max = max;
        this.value = "none";
        this.setValue(val);
//    }
};
SliderAndInput.prototype.setValue = function(val) { 
    var newval = this.integerOnly? Math.round(val) : val;
    if ( ! this.allowOutOfRange ) {
        newval = Math.min(this.max,newval);
    }
    if ( ! this.allowOutOfRange ) {
        newval = Math.max(this.min,newval);
    }
    newval = Math.max(0,newval);
    if (this.value != newval) { 
        this.value = newval;
        this.valueToTextbox();
        this.changed();
    }
};
SliderAndInput.prototype.valueToTextbox = function() {
    if (this.integerOnly)
        this.textbox.value = "" + this.value;
    else
        this.textbox.value = this.value.toPrecision(3);
};
SliderAndInput.prototype.setTabLeft = function() {
   if (this.value > this.max  || this.value < this.min)
      this.tabLeft = this.size + 20;
   else
      this.tabLeft = 5 + Math.floor((this.value - this.min)/(this.max - this.min) * this.size);
};
SliderAndInput.prototype.changed = function() {
   this.setTabLeft();
   this.draw();
   if (this.onchange)
      this.onchange(this.value);
};
SliderAndInput.prototype.draw = function() {
    var graphics = this.g;
    graphics.save();
    graphics.fillStyle = "#e8e8e8";
    graphics.fillRect(0,8,this.canvas.width,this.canvas.height);
    graphics.beginPath();
    graphics.moveTo(15, 35);
    graphics.lineTo(15 + this.size, 35);
    graphics.strokeStyle = "black";
    graphics.lineWidth = 10;
    graphics.lineCap = "round";
    graphics.stroke();
    graphics.strokeStyle = "gray";
    graphics.lineWidth = 7.5;
    graphics.lineCap = "butt";
    graphics.stroke();
    graphics.beginPath();
    graphics.moveTo(15, 35);
    graphics.lineTo(Math.min(this.tabLeft + 10,15+this.size), 35);
    graphics.strokeStyle = "lightgray";
    graphics.stroke();
    graphics.fillStyle = "black";
    graphics.lineWidth = 1;
    graphics.beginPath();
    graphics.moveTo(this.tabLeft + 10, 36);
    graphics.lineTo(this.tabLeft + 20, 30);
    graphics.lineTo(this.tabLeft + 20, 10);
    graphics.lineTo(this.tabLeft, 10);
    graphics.lineTo(this.tabLeft, 30);
    graphics.closePath();
    graphics.fillStyle = "#9090FF";
    graphics.fill();
    graphics.strokeStyle = "#000099";
    graphics.stroke();
    graphics.beginPath();
    graphics.moveTo(this.tabLeft + 4.5, 14);
    graphics.lineTo(this.tabLeft + 4.5, 26);
    graphics.moveTo(this.tabLeft + 9.5, 14);
    graphics.lineTo(this.tabLeft + 9.5, 26);
    graphics.moveTo(this.tabLeft + 14.5, 14);
    graphics.lineTo(this.tabLeft + 14.5, 26);
    graphics.stroke();
    graphics.beginPath();
    graphics.moveTo(this.tabLeft + 6, 16);
    graphics.lineTo(this.tabLeft + 6, 28);
    graphics.moveTo(this.tabLeft + 11, 16);
    graphics.lineTo(this.tabLeft + 11, 28);
    graphics.moveTo(this.tabLeft + 16, 16);
    graphics.lineTo(this.tabLeft + 16, 28);
    graphics.strokeStyle = "white";
    graphics.stroke();
    graphics.restore();
};



//-------------------------------------------------------------------------------------------

function currentExampletoXML() {
    const offset = Math.round(mainPaletteOffsetSlider.value/100 * paletteLength);
    const xml = 
            "<?xml version='1.0'?>\n<mandelbrot_settings_2>\n" +
            "<image_size width='" + currentImageSize[0] + "' height='" + currentImageSize[1] + "'/>\n" +
            "<limits>\n   <xmin>" + xmin_requested.toString() + "</xmin>\n" +
            "   <xmax>" + xmax_requested.toString() + "</xmax>\n" +
            "   <ymin>" + ymin_requested.toString() + "</ymin>\n" +
            "   <ymax>" + ymax_requested.toString() + "</ymax>\n</limits>\n" +
            palette.toXMLString() +
            "<palette_mapping length='" + paletteLength + "' offset='" + offset + "'/>\n" +
            "<max_iterations value='" + maxIterSlider.value + "'/>\n" +
            "</mandelbrot_settings_2>\n";

    persistence.persist(xml);
    return xml;
}

function installExampleFromXML(xmlString, respectSize, dontShowError) {
    // console.log("installExampleFromXML:", "from", (new Error()).stack.split("\n")[2].trim().split(" ")[1], currentXML, xmlString);
    stopJob();
    try {
      var parser = new DOMParser();
      var doc = parser.parseFromString(xmlString,"text/xml").documentElement;
      var width,height,xmin,xmax,ymin,ymax,colors,length,offset,iterations;
      if (respectSize) {
          var size = doc.getElementsByTagName("image_size");
          if (size == 0) {
              respectSize = false;
          }
          else {
              width = Number(size[0].getAttribute("width"));
              height = Number(size[0].getAttribute("height"));
              respectSize = (width === 0 && height === 0)
                || ! (isNaN(width) || width > 7680 || width < 64 || isNaN(height) || height > 7680 || height < 64);
          }
      }
      xmin = doc.getElementsByTagName("xmin").item(0).textContent;
      xmax = doc.getElementsByTagName("xmax").item(0).textContent;
      ymin = doc.getElementsByTagName("ymin").item(0).textContent;
      ymax = doc.getElementsByTagName("ymax").item(0).textContent;
      colors = Palette.fromXML( doc.getElementsByTagName("palette").item(0));
      var map = doc.getElementsByTagName("palette_mapping");
      if (map.length > 0) {
          length = Number(map.item(0).getAttribute("length"));
          offset = Number(map.item(0).getAttribute("offset"));
      }
      else {
          length = 250;
          offset = 0;
      }
      iterations = Number(doc.getElementsByTagName("max_iterations").item(0).getAttribute("value"));
      xmin = new BigDecimal(xmin);
      xmax = new BigDecimal(xmax);
      ymin = new BigDecimal(ymin);
      ymax = new BigDecimal(ymax);
      if (isNaN(length) || isNaN(offset) || isNaN(iterations)) {
          throw "Bad number.";
      }
      iterations = maxIterSlider.setValue(Math.round(iterations));
      if (length == 0) {
          length = iterations;
      }
      palette = colors;
      paletteSelectSlider.setCustomPalette(palette);

      length = Math.round(length);
      mainPaletteLengthSlider.setMaxValue(Math.max(2*length, 2*iterations), false);
      mainPaletteLengthSlider.setValue(length);
      fixedPaletteLength = length;

      let tmp = offset/length;
      tmp = tmp - Math.floor(tmp);
      tmp = Math.round(10000*tmp)/10000;
      mainPaletteOffsetSlider.setValue(tmp*100);
      createPaletteColors();
      setLimits(xmin,xmax,ymin,ymax,false);
      if (respectSize) {
        setImageSize(width, height, false, true);
        let val = width + " " + height;
        if (["0 0", "640 480", "800 600", "1024 768", "1600 1200", "1920 1080", "1920 1200", "2560 1440", "2880 1800", "3840 1080", "3840 2160", "5120 1440", "7680 4320"].indexOf(val) < 0) {
            document.getElementById("imagesize").value = "Custom";
            document.getElementById("customsize").style.display = "inline";
            document.getElementById("customwidth").value = "" + width;
            document.getElementById("customheight").value = "" + height;
        }
        else {
            document.getElementById("imagesize").value = val;
            document.getElementById("customsize").style.display = "none";
        }
      } else {
        startJob();
      }
      return null;
    }
    catch (e) {
        const error =  "Illegal data in XML example string: " + e;
        if (! dontShowError)
            statusText.updateText(error);
        return error;
    }
}

function installExampleWithAjax(url) {
    statusText.updateText("Fetching " + url);
    var ajaxTimeout;
    var ajax = new XMLHttpRequest();
    ajax.open("GET",url);
    ajax.overrideMimeType("text/plain");
    ajax.addEventListener("error",function() {
        clearTimeout(ajaxTimeout);
        statusText.updateText("Error: Example could not be loaded from " + url);
    });
    ajax.addEventListener("load",function() {
        clearTimeout(ajaxTimeout);
        installExampleFromXML(ajax.responseText, false);
    });
    ajaxTimeout = setTimeout(function() {
        ajax.abort();
        statusText.updateText("Error: Request timed out while trying to load from " + url);
    }, 10000);
    try {
       ajax.send();
    } catch(e) {
        clearTimeout(ajaxTimeout);
        statusText.updateText("Error while trying to send request for example: " + url);
    }
}

function importXML() {
    document.getElementById("XMLtextinput").value = "";
    document.getElementById("xmlimportbg").style.display = "block";
    document.getElementById("xmlimport").style.display = "block";
    document.addEventListener("keydown", doKey, false);
    document.getElementById("cancelXMLimport").onclick = dismiss;
    document.getElementById("applyXMLimport").onclick = apply;
    document.getElementById("grabcurrent").onclick = grabCurrent;
    const oldXML = currentXML;
    const oldPaletteSelectSliderState = paletteSelectSlider.getPaletteSelectSliderState();
    function apply() {
        var text = document.getElementById("XMLtextinput").value.trim();
        if (text == "") {
            dismiss();
        } else {
            const oldURL = persistence.setXMLURL(text);
            const errorMsg = installExampleFromXML(text, false);
            if (errorMsg == null) {
                addUndoItem("Import Example", [oldXML, oldPaletteSelectSliderState, oldURL],
                    [currentXML, paletteSelectSlider.getPaletteSelectSliderState(), persistence.url]);
                dismiss();
            } else {
                persistence.setURL(oldURL);
                alert("Error in input: " + errorMsg);
            }
        }
    }
    function dismiss() {
        document.getElementById("xmlimportbg").style.display = "none";
        document.getElementById("xmlimport").style.display = "none";
        document.removeEventListener("keydown", doKey, false);
    }
    function grabCurrent() {
        document.getElementById("XMLtextinput").value = currentXML;
    }
    function doKey(evt) {
        var code = evt.keyCode;
        if (code == 27) {
            dismiss();
        }
    }
}

const persistence = {
    init: function() {
        const location = window.location;
        this.urlWithoutQuery = `${location.protocol}//${location.host}${location.pathname}`;
        this.setURL(location.href);

        let xmlLocalStorage;
        if (this.ex) {
            xmlLocalStorage = getLocalStorageItem("ex/" + this.ex, null);
        } else if (this.xml) {
            xmlLocalStorage = getLocalStorageItem("xml/" + this.xmlHash, null);
        } else {
            xmlLocalStorage = getLocalStorageItem("/", null);
        }

        const navEntries = performance.getEntriesByType("navigation");
        const navLast = navEntries[navEntries.length - 1];

        // if not initial navigation to page, try installing from image settings in local storage
        if (navLast.type !== "navigate" && xmlLocalStorage && installExampleFromXML(xmlLocalStorage, true, true) === null) {
        // else try installing from file
        } else if (this.ex) {
            installExampleWithAjax(this.ex);
        // else try installing from image settings encoded in the url
        } else if (this.xml && installExampleFromXML(this.xml, true, true) === null) {
        // else fall back to default settings
        } else {
            startJob();
        }

        document.getElementById("copyURLFromXML").onclick = persistence.copyURLFromXML;
    },
    setURL: function(url) {
        // console.log("persistence.setURL:", url);
        const oldURL = this.url;
        this.url = url;
        window.history.replaceState(null, "", url);

        const params = new URLSearchParams(window.location.search);
        this.ex = params.get("ex");
        this.xml = params.get("xml");
        this.xmlHash = this.xml ? this.murmurHash3(this.xml).toString(16) : null;
        return oldURL;
    },
    setDefaultURL: function() {
        return this.setURL(this.urlWithoutQuery);
    },
    setXMLURL: function(xml) {
        const url = this.urlWithoutQuery + "?xml=" + encodeURIComponent(xml);
        return this.setURL(url);
    },
    persist: function(xml) {
        if (this.ex) {
            setLocalStorageItem("ex/" + this.ex, xml);
        } else if (this.xml) {
            setLocalStorageItem("xml/" + this.xmlHash, xml);
        } else {
            setLocalStorageItem("/", xml);
        }
    },
    copyURLFromXML: function() {
        const url = persistence.urlWithoutQuery + "?xml=" + encodeURIComponent(currentXML);
        navigator.clipboard.writeText(url)
            .then(() => {
                document.getElementById("copyURLFromXML").textContent = 'Permalink Copied!';
                setTimeout(() => {
                    document.getElementById("copyURLFromXML").textContent = 'Copy Permalink';
                }, 2000);
            })
            .catch((err) => {
                console.warn('Clipboard API failed:', err);
            });
    },

    /**
     * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)
     *
     * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
     * @see http://github.com/garycourt/murmurhash-js
     * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
     * @see http://sites.google.com/site/murmurhash/
     *
     * @param {string} key ASCII only
     * @param {number} seed Positive integer only
     * @return {number} 32-bit positive integer hash 
     */
    // thanks to GPT4 for this updated version which is about 15% faster, probably due to use of Math.imul

    murmurHash3: function(key, seed = 0) {
        const c1 = 0xcc9e2d51;
        const c2 = 0x1b873593;
        let h1 = seed;
        let roundedEnd = key.length & ~0x3;

        for (let i = 0; i < roundedEnd; i += 4) {
            let k1 =
            (key.charCodeAt(i) & 0xff) |
            ((key.charCodeAt(i + 1) & 0xff) << 8) |
            ((key.charCodeAt(i + 2) & 0xff) << 16) |
            ((key.charCodeAt(i + 3) & 0xff) << 24);
            k1 = Math.imul(k1, c1);
            k1 = (k1 << 15) | (k1 >>> 17);
            k1 = Math.imul(k1, c2);

            h1 ^= k1;
            h1 = (h1 << 13) | (h1 >>> 19);
            h1 = Math.imul(h1, 5) + 0xe6546b64;
        }

        let k1 = 0;
        const val = key.length & 0x3;

        if (val === 3) {
            k1 = (key.charCodeAt(roundedEnd + 2) & 0xff) << 16;
        }
        if (val >= 2) {
            k1 |= (key.charCodeAt(roundedEnd + 1) & 0xff) << 8;
        }
        if (val >= 1) {
            k1 |= key.charCodeAt(roundedEnd) & 0xff;
            k1 = Math.imul(k1, c1);
            k1 = (k1 << 15) | (k1 >>> 17);
            k1 = Math.imul(k1, c2);
            h1 ^= k1;
        }

        h1 ^= key.length;
        h1 ^= h1 >>> 16;
        h1 = Math.imul(h1, 0x85ebca6b);
        h1 ^= h1 >>> 13;
        h1 = Math.imul(h1, 0xc2b2ae35);
        h1 ^= h1 >>> 16;

        return h1 >>> 0;
    }
}

function init() {
    try {
        canvas = document.getElementById("canvas");
        graphics = canvas.getContext("2d");
        OSC = document.createElement("canvas");
        OSC.width = canvas.width;
        OSC.height = canvas.height;
        OSG = OSC.getContext("2d", { willReadFrequently: true });
    }
    catch (e) {
         document.getElementById("message").innerHTML =
             "Sorry, this page requires canvas support, which is not available in your browser.";
         return;
    }
    if (! window.Worker ) {
         document.getElementById("message").innerHTML =
             "Sorry, this page requires WebWorker support, which is not available in your browser.";
         return;
    }
    palette = new Palette();
    document.getElementById("restoreButton").onclick = setDefaults;
    document.getElementById("stop").onclick = stopJob;
    document.getElementById("interlaced").onchange = changeInterlaced;
    document.getElementById("interlaced").checked = interlaced;
    document.getElementById("imagesize").onchange = changeImageSize;
    document.getElementById("applysize").onclick = doCustomSize;

    // must run before worker count init
    initLocalOrRemote();
    workerCount = initThreadCountSelect();
    let wcl = getLocalStorageItem("mandelbrotWorkerCount-local", workerCount);
    setLocalStorageItem("mandelbrotWorkerCount-local", wcl);
    let wcr = getLocalStorageItem("mandelbrotWorkerCount-remote", workerCount);
    setLocalStorageItem("mandelbrotWorkerCount-remote", wcr);
    workerCount = document.getElementById("local").checked ? wcl : wcr;
    document.getElementById("threadCountSelect").value = "" + workerCount;
    document.getElementById("threadCountSelect").onchange = changeWorkerCount;

    document.getElementById("showpaletteedit").onclick=showPaletteEditor;
    const doSecondPass = getLocalStorageItem("secondpass", true);
    document.getElementById("secondpass").checked = doSecondPass;
    document.getElementById("secondpass").onchange = changeSecondPass;
    document.getElementById("highPrecision").checked = false;
    document.getElementById("highPrecision").onchange = changeHighPrecision;
    document.getElementById("local").onchange = changeLocalOrRemote;
    document.getElementById("remote").onchange = changeLocalOrRemote;
    document.getElementById("importXML").onclick = importXML;
    document.getElementById("undo").onclick = doUndo;
    document.getElementById("undo").disabled = true;
    document.getElementById("redo").onclick = doRedo;
    document.getElementById("redo").disabled = true;
    setUpDragging();
    document.addEventListener("keydown", handleCanvasKeys);
    changeWorkerCount(); // has to be done before setDefaults
    createSliders();
    initTouch();
    statusText.init();
    progressCircle.init(doSecondPass);
    windowSize.init();
    setDefaults();
    persistence.init();
    undoList = [];
    undoCount = 0;
    checkRemoteCanComputeMB();
}

// Ensure we can select the actual number of processors that this machine has
// Some CPUs like the Pixel 8 Pro have a weird number of processors (eg 9)
function initThreadCountSelect() {
    var processorCount = window.navigator && window.navigator.hardwareConcurrency ? window.navigator.hardwareConcurrency : 4;
    var threadSelect = document.getElementById("threadCountSelect");
    var options = Array.from(threadSelect.options);
    var found = false;

    for (var i = 0; i < options.length; i++) {
        if (options[i].value == processorCount) {
            found = true;
            break;
        }
    }

    if (!found) {
        var option = document.createElement("option");
        option.value = processorCount;
        option.text = processorCount;
        options.push(option); // Add new option to the array

        // Sort the options array numerically by value
        options.sort(function(a, b) {
            return parseInt(a.value) - parseInt(b.value);
        });

        // Clear existing options and repopulate with sorted options
        while (threadSelect.options.length > 0) {
            threadSelect.remove(0);
        }
        options.forEach(function(opt) {
            threadSelect.add(opt);
        });
    }

    return processorCount;
}

function getLocalStorageItem(item, defaultVal) {
    try {
        let value = localStorage.getItem(item);
        // console.log(item, value, typeof value, defaultVal, typeof defaultVal);
        if (value === null) {
            return defaultVal;
        } else if (typeof defaultVal === "number" ) {
            value = parseFloat(value);
            if (isFinite(value)) {
                return value;
            } else {
                return defaultVal;
            }
        } else if (typeof defaultVal === "boolean" ) {
            return value === "true" ? true : false;
        } else {
            return value;
        }
    }
    catch(e) {
        return defaultVal;
    }
}
function setLocalStorageItem(item, value) {
    try {
        // console.log(item, value);
        localStorage.setItem(item, value);
    }
    catch(e) {
    }
}

function createSliders() {
    maxIterSlider = new Slider(
        "maxIterSlider", {
        label: "Max Iterations:",
        title: "How many steps in the Mandelbrot iteration before giving up and coloring the pixel black.",
        logarithmic: true, initialValue: 1000, minValue: 1, maxValue:999999, textLength: 6,
        stickyVals: [3,5,10,25,50,75,100,250,500,750,1000,2500,5000,7500,10000,25000,50000,75000,100000]
        });
    maxIterSlider.onInput = function (interimMaxIters, lastInterimMaxIters) {
        // console.log("i:",this.id,interimMaxIters);
        // check for palette length tracking maxIters
        if (mainPaletteLengthSlider.atMax()) {
            setFixedPaletteLength(interimMaxIters);
        }
    };
    maxIterSlider.onChange = function (newMaxIters, oldState) {
        setMaxIterations();
        let initialMPLSState = mainPaletteLengthSlider.getState();
        // if palette length is tracking maxIters, update palette max and set palette value to maxIters
        if (mainPaletteLengthSlider.atMax()) {
            mainPaletteLengthSlider.setMaxValue(newMaxIters, true);
        // else just update palette max if newMaxIters > current palette length
        } else if (2*newMaxIters > mainPaletteLengthSlider.value) {
            mainPaletteLengthSlider.setMaxValue(2*newMaxIters, false);
        }
        addUndoItem("Change MaxIterations", [oldState.value, initialMPLSState],
                [newMaxIters, mainPaletteLengthSlider.getState()]);
    };

    mainPaletteLengthSlider = new Slider(
        "mainPaletteLengthSlider", {
        label: "Palette Length:",
        title: "Size of the color palette for pixels outside the Mandebrot set. Drag all the way to the right to pin it to max iterations.",
        logarithmic: true, initialValue: 250, minValue: 2, maxValue: 999999, textLength: 6,
        stickyVals: [2,3,4,5,6,7,8,9,10,12,15,20,25,35,50,75,100,175,250,375,500,750,1000,1750,2500,3750,5000,7500,10000],
        textFormat: function (value) { return this.atMax() ? "MaxIter" : value; },
        notifyOnlyOnDifference: false,///??? why did I do this
        data: { lastPaletteLength: NaN }
        });
    mainPaletteLengthSlider.onInput = function (interimPaletteLength, lastInterimPaletteLength) {
        // console.log("i mPLS", interimPaletteLength, lastInterimPaletteLength, maxIterSlider.value);
        if (isNaN(this.data.lastPaletteLength)) {
            this.data.lastPaletteLength = this.value;
        }
        let paletteLength = this.atMax() ? maxIterSlider.value : interimPaletteLength;
        if (paletteLength !== this.data.lastPaletteLength) {
            setFixedPaletteLength(paletteLength);
            this.data.lastPaletteLength = paletteLength;
        }
    };
    mainPaletteLengthSlider.onChange = function (newPaletteLength, oldState) {
        // console.log("c mPLS", newPaletteLength, oldState.value, maxIterSlider.value);
        if (this.atMax()) {
            if (this.maxValue !== maxIterSlider.value) {
                this.setMaxValue(maxIterSlider.value, true);
            }
        } else if (2*maxIterSlider.value > this.value) {
            if (this.maxValue !== 2*maxIterSlider.value) {
                this.setMaxValue(2*maxIterSlider.value, false);
            }
        }
        if (newPaletteLength != oldState.value || this.maxValue != oldState.maxValue) {
            addUndoItem("Change PaletteLength", oldState, this.getState());
        }
        this.onBlur();
    };
    mainPaletteLengthSlider.onBlur = function() {
        this.data.lastPaletteLength = NaN;
    };
    mainPaletteLengthSlider.setDefaultsFromMaxIter = function () {
        this.setMaxValue(2*maxIterSlider.value, false);
        this.setValue(maxIterSlider.value/4);
    };

    mainPaletteOffsetSlider = new Slider(
        "mainPaletteOffsetSlider", {
        label: "Palette Offset:",
        title: "Offsets the colors within the palette to get a different mapping.",
        logarithmic: false, initialValue: 0, minValue: 0, maxValue: 100, textLength: 5,
        stickyVals: [0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100],
        textFormat: (value) => value + "%",
        onInput: doPaletteOffset,
        onChange: finishDoPaletteOffset
        });

    paletteSelectSlider = new Slider(
        "paletteSelectSlider", {
        label: "Palette:",
        title: "Select one of the standard palettes of colors.",
        logarithmic: false, initialValue: 0, minValue: 0, maxValue: 10, textLength: 14,
        textFormat: function (value) { return this.data.paletteNamesList[value]; },
        textEdit: false,
        data: {
            oldPalette: null,
            customPalette: null,
            paletteSelectList: ["Spectrum","EarthAndSky","Cyclic Fire","Seashore","TreeColors",
                "Pastels","Dark","HotAndCold","Blue/Gold","CyclicGrayscale","Random","Custom"],
            paletteNamesList: ["Spectrum","EarthAndSky","Fire","Seashore","Forest",
               "Pastel Colors","Dark Colors","HotAndCold","Blue/Gold","Grayscale","Random","Custom"]
        }});
    paletteSelectSlider.onInput = function(interimPaletteNum, lastInterimPaletteNum) {
        // console.log("i:",this.id,interimPaletteNum,lastInterimPaletteNum,this.value);
        if (! this.data.oldPalette) {
            this.data.oldPalette = palette.copy();
        }
        if (interimPaletteNum === this.value) {
            // show original palette even if it was random
            doApplyStandardPalette(null, this.data.oldPalette);
        } else {
            doApplyStandardPalette(interimPaletteNum);
        }
    };
    paletteSelectSlider.onChange = function(newPaletteNum, oldState) {
        // console.log("c:", this.id, newPaletteNum, oldState.value);
        addUndoItem("Change Palette", [this.data.oldPalette, oldState.value],
            [palette.copy(), newPaletteNum]);
        this.onBlur();
        };
    paletteSelectSlider.onBlur = function() {
        this.data.oldPalette = null;
    };
    paletteSelectSlider.reset = function() {
        let max = this.data.paletteSelectList.length - 1;
        this.setDefault();
        this.setMaxValue(max - 1, false);
    };
    paletteSelectSlider.paletteName = function(paletteNum) {
        return this.data.paletteSelectList[paletteNum];
    };
    paletteSelectSlider.setCustomPalette = function(palette) {
        let max = this.data.paletteSelectList.length - 1;
        this.setMaxValue(max, true);
        this.data.customPalette = palette.copy();
    };
    paletteSelectSlider.getPaletteSelectSliderState = function() {
        // console.log("gPSSS:", this.data.customPalette);
        return [
            this.getState(),
            this.data.customPalette
        ];
    }
    paletteSelectSlider.setPaletteSelectSliderState = function(state) {
        this.setState(state[0]);
        this.data.customPalette = state[1];
        // console.log("sPSSS:", this.data.customPalette);
    }

    let initialValue = parseInt(getLocalStorageItem("zoomInSlider", 10));
    zoomInSlider = new Slider(
        "zoomInSlider", {
        label :"Zoom in by",
        title: "Sets the zoom in amount and then zooms.",
        logarithmic: true, initialValue: initialValue, minValue: 2, maxValue: 100000, textLength: 8,
        stickyVals: [2,4,8,10,20,50,100,200,500,1000,2000,5000,10000,20000,50000,100000],
        textFormat: (value) => value + " X",
        button: true,
        onClick: () => doZoomIn(zoomInSlider.value),
        onChange: function (zoomValue) {
            doZoomIn(zoomValue);
            setLocalStorageItem(this.id, zoomValue);
        }});

    initialValue = parseInt(getLocalStorageItem("zoomOutSlider", 10));
    zoomOutSlider = new Slider(
        "zoomOutSlider", {
        label :"Zoom out by",
        title: "Sets the zoom out amount and then zooms.",
        logarithmic: true, initialValue: initialValue, minValue: 2, maxValue: 100000, textLength: 8,
        stickyVals: [2,4,8,10,20,50,100,200,500,1000,2000,5000,10000,20000,50000,100000],
        textFormat: (value) => value + " X",
        button: true,
        onClick: () => doZoomOut(zoomOutSlider.value),
        onChange: function (zoomValue) {
            doZoomOut(zoomValue);
            setLocalStorageItem(this.id, zoomValue);
        }});
}

let fullWindowCanvas = false;
let fullScreenCanvas = false;
function toFullWindowCanvas() {
    canvas.classList.add('fullWindowCanvas');
    canvas.classList.add('fullWindowCanvasFront');
    // console.log("toFullWindowCanvas", windowSize.width, windowSize.height);
    setImageSizeToFixed(windowSize.width, windowSize.height);
    fullWindowCanvas = true;
}
function fromFullWindowCanvas() {
    canvas.classList.remove('fullWindowCanvasFront');
    canvas.classList.remove('fullWindowCanvas');
    setImageSize(currentImageSize[0], currentImageSize[1], false);
    fullWindowCanvas = false;
}
function toFullScreenCanvas() {
    // console.log("tfsc");
    if (canvas.requestFullscreen) {
        canvas.classList.add('fullWindowCanvas');
        document.addEventListener("fullscreenchange", fullscreenChange);
        fullScreenCanvas = true;
        canvas.requestFullscreen();
    } else {
        statusText.updateText("Fullscreen mode not available");
    }
}
function fromFullScreenCanvas() {
    // console.log("ffsc");
    document.removeEventListener("fullscreenchange", fullscreenChange);
    canvas.classList.remove('fullWindowCanvas');
    fullScreenCanvas = false;
    if (document.fullscreenElement) {
        document.exitFullscreen();
    }
}
function fullscreenChange() {
    // console.log("fsc");
    if (! document.fullscreenElement) {
        fromFullScreenCanvas();
        // resize event happens before fullscreenChange event, so need to call it again
        resizeWindow();
    }
}

let panZoomKeyTimeout = null, panKeyOldValue, panZoomKeyCurrentAction;
function doPanZoomKey(name, x, y, w, h) {
    if (panZoomKeyTimeout) {
        clearTimeout(panZoomKeyTimeout);
        panZoomKeyTimeout = null;
    } else {
        panZoomKeyCurrentAction = name;
        panKeyOldValue = [0, 0];
    }
    if (name === "Pan" && panZoomKeyCurrentAction === name) {
        panKeyOldValue[0] += x;
        panKeyOldValue[1] += y;
        panZoomKeyTimeout = setTimeout(() => {
            addUndoItem("Move",
                [ZOOMOUTRECT, panKeyOldValue[0], panKeyOldValue[1], w, h],
                [ZOOMINRECT, panKeyOldValue[0], panKeyOldValue[1], w, h]);
            panZoomKeyTimeout = null;
        }, 500);
    // } else {///??? finish for zoom
    //     addUndoItem("Move",
    //         [ZOOMOUTRECT, panKeyOldValue[0], panKeyOldValue[1], w, h],
    //         [ZOOMINRECT, panKeyOldValue[0], panKeyOldValue[1], w, h]);
    }

    doZoomInOnRect(x, y, w, h, false);
}
let canvasKeyTimeout;
function handleCanvasKeys(event) {
    // quit when in a text box
    const node = event.target.nodeName;
    if (node === "INPUT" || node === "SELECT" || node === "TEXTAREA") {
        return;
    }

    let doStartStop = false;
    switch (event.key) {
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "ArrowDown":
        case "PageDown":
        case "PageUp":
            if (event.ctrlKey || event.altKey || event.metaKey) {
                return;
            }
            doStartStop = true;
            break;
        case "f":
        case "F":
        case "Escape":
            if (event.ctrlKey || event.altKey || event.metaKey) {
                return;
            }
            break;
        case "z":
        case "Z":
        case "y":
        case "c":
            if (event.ctrlKey && !(event.altKey || event.metaKey)) {
                break;
            }
            return;
        default:
            // quit when this doesn't handle the key event
            return;
    }

    // Cancel the default action to avoid it being handled twice
    event.preventDefault();

    // prevent too many of these slowing down response
    if (canvasKeyTimeout) {
        return;
    }

    if (doStartStop) {
        stopJob();
    }

    let doStart = true;
    const shiftLR = Math.max(1, Math.round(canvas.width/32));
    const shiftUD = Math.max(1, Math.round(canvas.height/32));
    switch (event.key) {
        case "ArrowLeft":
            doPanZoomKey("Pan", -shiftLR, 0, canvas.width, canvas.height, false);
            break;

        case "ArrowRight":
            doPanZoomKey("Pan", shiftLR, 0, canvas.width, canvas.height, false);
            break;

        case "ArrowUp":
            doPanZoomKey("Pan", 0, -shiftUD, canvas.width, canvas.height, false);
            break;

        case "ArrowDown":
            doPanZoomKey("Pan", 0, shiftUD, canvas.width, canvas.height, false);
            break;

        case "PageUp":
            doPanZoomKey("Zoom Out", -shiftLR, -shiftUD, canvas.width + shiftLR*2, canvas.height + shiftUD*2, false);
            break;

        case "PageDown":
            doPanZoomKey("Zoom In",shiftLR, shiftUD, canvas.width - shiftLR*2, canvas.height - shiftUD*2, false);
            break;

        case "F":
            if (fullScreenCanvas) {
                fromFullScreenCanvas();
            } else if (fullWindowCanvas) {
                fromFullWindowCanvas();
            } else {
                toFullScreenCanvas();
            }
            break;

        case "f":
            if (fullScreenCanvas) {
                fromFullScreenCanvas();
            } else if (fullWindowCanvas) {
                fromFullWindowCanvas();
            } else {
                toFullWindowCanvas();
            }
            break;

        case "Escape":
            if (fullWindowCanvas) {
                fromFullWindowCanvas();
            }
            break;

        case "z":
            doUndo();
            break;

        case "y":
        case "Z":
            doRedo();
            break;

        case "c":
            persistence.copyURLFromXML();
            break;
    }

    canvasKeyTimeout = setTimeout(function () {
        canvasKeyTimeout = null;
        if (doStartStop) {
            startJob();
        }
    }, 0);
}

function initTouch() {
    // Check if the device supports touch events
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints;
    if (isTouchDevice) {
        touch = new Touch("canvas", {
            FPS: FPS,
            data: {
                startJob: false,
                canvas: null,
                ctx: null,
                toFullWindowCanvas: function () {
                    if (! fullScreenCanvas && ! fullWindowCanvas
                            && currentImageSize[0] === 0 && currentImageSize[1] === 0) {
                        toFullWindowCanvas();
                    }
                }
            },
            onTouchStart: function() {
                this.data.startJob = running;
                return true;
            },
            onTouchEnd: function() {
                if (this.data.startJob && ! running) {
                    startJob(true);
                }
            },
            onInit: function() {
                this.data.canvas = document.createElement("canvas");
                this.data.ctx = this.data.canvas.getContext("2d");
            },
            onSingleTap: function(x, y) {
                if (fullScreenCanvas) {
                    fromFullScreenCanvas();
                } else if (fullWindowCanvas) {
                    fromFullWindowCanvas();
                } else {
                    toFullWindowCanvas();
                }
            },
            // Chrome on ios won't register the second touch event if emulating double tap via mouse dblclick
            //   this leads to a single tap being detected instead of a double tap
            //   easiest approach is just to register here for onDoubleTap
            onDoubleTap: function(x, y) {
                this.data.toFullWindowCanvas();
                const r = canvas.getBoundingClientRect();
                // account for canvas border margin
                x -= (r.left + r.right - canvas.width)/2;
                y -= (r.top + r.bottom - canvas.height)/2;
                zoom(x, y, 0.5, true, true);
            },
            onDragStart: function() {
                // console.log("onDragStart");
                stopJob();
                this.data.toFullWindowCanvas();
                this.data.canvas.width = canvas.width;
                this.data.canvas.height = canvas.height;
                // get latest OSC
                this.data.ctx.drawImage(OSC, 0, 0);
            },
            onDragMove: function(startX, startY, endX, endY) {
                const shiftX = endX - startX;
                const shiftY = endY - startY;

                // translate image into OSG with gray surround
                OSG.fillStyle = "#BBBBBB";
                OSG.fillRect(0, 0, canvas.width, canvas.height);
                OSG.drawImage(this.data.canvas, shiftX, shiftY);
                graphics.drawImage(OSC, 0, 0);
            },
            onDragEnd: function(startX, startY, endX, endY) {
                const shiftX = startX - endX;
                const shiftY = startY - endY;

                doZoomInOnRect(shiftX, shiftY, canvas.width, canvas.height, true, "Move", true);
                this.data.startJob = true;
            },
            onPinchStart: function() {
                this.onDragStart();
            },
            onPinchMove: function(ps, pe) {
                const centerXStart = (ps[0] + ps[2])/2;
                const centerYStart = (ps[1] + ps[3])/2;
                let centerXLast = (pe[0] + pe[2])/2;
                let centerYLast = (pe[1] + pe[3])/2;
                const shiftX = centerXStart - centerXLast;
                const shiftY = centerYStart - centerYLast;

                const lenStart = Math.sqrt(Math.pow(ps[0] - ps[2], 2) + Math.pow(ps[1] - ps[3], 2));
                const lenLast = Math.sqrt(Math.pow(pe[0] - pe[2], 2) + Math.pow(pe[1] - pe[3], 2));
                const zoomFactor = lenStart/lenLast;

                const r = canvas.getBoundingClientRect();
                // account for canvas border margin
                centerXLast -= (r.left + r.right - canvas.width)/2;
                centerYLast -= (r.top + r.bottom - canvas.height)/2;

                const width = canvas.width*zoomFactor;
                const height = canvas.height*zoomFactor;
                const left = centerXLast*(1 - zoomFactor) + shiftX;
                const top = centerYLast*(1 - zoomFactor) + shiftY;

                // translate and zoom image into OSG with gray surround
                OSG.fillStyle = "#BBBBBB";
                OSG.fillRect(0, 0, canvas.width, canvas.height);
                OSG.drawImage(this.data.canvas, left, top, width, height, 0, 0, canvas.width, canvas.height);
                graphics.drawImage(OSC, 0, 0);
            },
            onPinchEnd: function(ps, pe) {
                const centerXStart = (ps[0] + ps[2])/2;
                const centerYStart = (ps[1] + ps[3])/2;
                let centerXLast = (pe[0] + pe[2])/2;
                let centerYLast = (pe[1] + pe[3])/2;
                const shiftX = centerXStart - centerXLast;
                const shiftY = centerYStart - centerYLast;

                const lenStart = Math.sqrt(Math.pow(ps[0] - ps[2], 2) + Math.pow(ps[1] - ps[3], 2));
                const lenLast = Math.sqrt(Math.pow(pe[0] - pe[2], 2) + Math.pow(pe[1] - pe[3], 2));
                const zoomFactor = lenStart/lenLast;
                const undoText = zoomFactor > 1 ? "Pinch Zoom Out" : "Pinch Zoom In";

                const r = canvas.getBoundingClientRect();
                // account for canvas border margin
                centerXLast -= (r.left + r.right - canvas.width)/2;
                centerYLast -= (r.top + r.bottom - canvas.height)/2;

                const width = canvas.width*zoomFactor;
                const height = canvas.height*zoomFactor;
                const left = centerXLast*(1 - zoomFactor) + shiftX;
                const top = centerYLast*(1 - zoomFactor) + shiftY;

                doZoomInOnRect(left, top, width, height, true, undoText, true);
                this.data.startJob = true;
            }
        });
    }
}

// polyfill for Safari drawImage when left and/or top is negative
(function () {
    const originalDrawImage = CanvasRenderingContext2D.prototype.drawImage;

    CanvasRenderingContext2D.prototype.drawImage = function(canvas, left, top, ...args) {
        if (args.length === 6) {
            // console.log(left, top, ...args);
            let canvasLeft = 0;
            // assumes that args[2] and args[3] === 0
            if (left < 0) {
                canvasLeft = -left*args[4]/args[0];
                left = 0;
            }
            let canvasTop = 0;
            if (top < 0) {
                canvasTop = -top*args[5]/args[1];
                top = 0;
            }

            originalDrawImage.call(this, canvas, left, top, args[0], args[1], canvasLeft, canvasTop, args[4], args[5]);
        } else {
            originalDrawImage.call(this, canvas, left, top, ...args);
        }
    };
})();

</script>
</head>
<body>

<noscript><b>Sorry, this page requires JavaScript.</b></noscript>

<table id="header-table" class="unselectable">
<tr>
<td><a href=MB.html>
    <!-- thanks to https://mandelbrot.silversky.dev/ for home icon -->
    <svg id="home-icon" class="svg-icon" fill="currentColor" viewBox="0 0 16 16">
        <path d="M6.5 14.5v-3.505c0-.245.25-.495.5-.495h2c.25 0 .5.25.5.5v3.5a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.146-.354L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.354 1.146a.5.5 0 0 0-.708 0l-6 6A.5.5 0 0 0 1.5 7.5v7a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5z"></path>
        <title>Reload Mandelbrot website</title>
    </svg>
</a></td>
<td>
    <span class="tooltip">
        <!-- thanks to https://mandelbrot.silversky.dev/ for gallery icon -->
        <svg class="svg-icon" fill="currentColor" viewBox="0 0 16 16" width="34px">
            <path d="M2.5 3.5a.5.5 0 0 1 0-1h11a.5.5 0 0 1 0 1h-11zm2-2a.5.5 0 0 1 0-1h7a.5.5 0 0 1 0 1h-7zM0 13a1.5 1.5 0 0 0 1.5 1.5h13A1.5 1.5 0 0 0 16 13V6a1.5 1.5 0 0 0-1.5-1.5h-13A1.5 1.5 0 0 0 0 6v7zm1.5.5A.5.5 0 0 1 1 13V6a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-.5.5h-13z"></path>
            <title>Mandelbrot Gallery</title>
        </svg>
        <span class="exampletext selectable">
            <h3 id="gallery">Gallery</h3>
            <p>Click on one of the images below
            to render a larger-size
            version, and do some further exploration.
            For example, zoom out to see the neighborhood of
            the sample in the full Mandelbrot set.  You will usually see several striking images
            along the way!  (There is also a large, unorganized
            <a href="java/MandelbrotSettings/index.html">sample collection</a> that
            you can play with.)</p>

            <table id="examples">
            <tr>
               <td><a href="MB.html?ex=examples%2forangesky.xml"><img src="examples/orangesky.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2fgalaxies.xml"><img src="examples/galaxies.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2fspikey.xml"><img src="examples/spikey.png" width="200" height="150"></a></td>
            </tr>
            <tr>
               <td><a href="MB.html?ex=examples%2fvine.xml"><img src="examples/vine.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2ffire.xml"><img src="examples/fire.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2fcrazy.xml"><img src="examples/crazy.png" width="200" height="150"></a></td>
            </tr>
            <tr>
               <td><a href="MB.html?ex=examples%2fdragon.xml"><img src="examples/dragon.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2fflower.xml"><img src="examples/flower.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2fstar.xml"><img src="examples/star.png" width="200" height="150"></a></td>
            </tr>
            <tr>
               <td><a href="MB.html?ex=examples%2fpinwheel.xml"><img src="examples/pinwheel.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2frainbow.xml"><img src="examples/rainbow.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2fisland.xml"><img src="examples/island.png" width="200" height="150"></a></td>
            </tr>
            <tr>
               <td><a href="MB.html?ex=examples%2ffiddleheads.xml"><img src="examples/fiddleheads.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2fstatic.xml"><img src="examples/static.png" width="200" height="150"></a></td>
               <td><a href="MB.html?ex=examples%2fmitosis.xml"><img src="examples/mitosis.png" width="200" height="150"></a></td>
            </tr>
            </table>
        </span>
    </span>
</td>
<td>
    <span class="tooltip">
        <!-- thanks to https://mandelbrot.silversky.dev/ for help icon -->
        <svg class="svg-icon" fill="currentColor" viewBox="0 0 16 16">
            <path fill-rule="evenodd" d="M4.475 5.458c-.284 0-.514-.237-.47-.517C4.28 3.24 5.576 2 7.825 2c2.25 0 3.767 1.36 3.767 3.215 0 1.344-.665 2.288-1.79 2.973-1.1.659-1.414 1.118-1.414 2.01v.03a.5.5 0 0 1-.5.5h-.77a.5.5 0 0 1-.5-.495l-.003-.2c-.043-1.221.477-2.001 1.645-2.712 1.03-.632 1.397-1.135 1.397-2.028 0-.979-.758-1.698-1.926-1.698-1.009 0-1.71.529-1.938 1.402-.066.254-.278.461-.54.461h-.777ZM7.496 14c.622 0 1.095-.474 1.095-1.09 0-.618-.473-1.092-1.095-1.092-.606 0-1.087.474-1.087 1.091S6.89 14 7.496 14Z"></path>
            <title>Mandelbrot Help</title>
        </svg>
        <span class="helptext selectable">
            <h3>Basic Help</h3>
                With a mouse, double-click or click and drag on the image to zoom in.
                On a touch screen, drag or pinch to zoom; tap to hide/show controls.
                On the left are controls for the color palette, image size, etc.  Hover over a
                setting to see what it does.
            <h3>Special keys</h3>
                <table>
                    <tr><td>Left Arrow:</td><td>Scroll left</td></tr>
                    <tr><td>Right Arrow:</td><td>Scroll right</td></tr>
                    <tr><td>Up Arrow:</td><td>Scroll up</td></tr>
                    <tr><td>Down Arrow:</td><td>Scroll down</td></tr>
                    <tr><td>Page Up:</td><td>Zoom out on image</td></tr>
                    <tr><td>Page Down:</td><td>Zoom in on image</td></tr>
                    <tr><td>f:</td><td>Fill window with image, hide controls</td></tr>
                    <tr><td>F (shift-f):</td><td>Fill screen with image</td></tr>
                    <tr><td>Esc</td><td>Exit fill window or fill screen mode</td></tr>
                    <tr><td>Ctrl-z</td><td>Undo last action</td></tr>
                    <tr><td>Ctrl-y</td><td>Redo last undone action</td></tr>
                    <tr><td>Ctrl-c</td><td>Copy a "permalink" (for sharing the current image) to the clipboard</tr>
                </table>
            <h3>More Help</h3>
                For a detailed description, instructions, and examples, see <a href='MB-info.html'>more help</a>.
            <h3>More Info</h3>
                The number of "Workers" (in the controls pane) determines how much CPU is used for calculations.  The preset value should work well.
                To experiment, click on <a href="MB.html?ex=java%2FMandelbrotSettings%2FMandelbrotSettings_25_May_2009_3.xml">this link</a>,
                then vary the number of workers to speed it up or slow it down.
            </p><p>
            <h3>Background</h3>
                Based on a browser-only Mandelbrot Set viewer by <a href=https://math.hws.edu/eck/index.html target="_blank">David Eck</a>,
                this revised version can run calculations in the browser or on a backend web server.  By default it tries to use the web server;
                if the web server doesn't support calculations it runs them in the browser.
                When the web server is hosted on Kubernetes, increasing the number of workers brings in more pods to speed up the computation.
                Calculations are done in Rust for increased speed over the original JavaScript version.
            </p><p>
                See the <a href="https://github.com/wpwoodjr/MandelRust" target="_blank">GitHub repository</a> for more information.
            </p>
        </span>
    </span>
</td>
<td id="status-header" width="37%"></td>
</tr>
</table>

<p id="message"></p>

<div id="mainUI" class="mainUI unselectable">
<div id="controls" class="col1">
   <div class="group">
      <p><button id="restoreButton" title="Restore default limits, image size, palette, max iterations.">Restore Defaults</button><button id="stop" style="margin-left:20px" title="Abort the current computation, if any, leaving an incomplete image.">Stop</button></p>
   </div>
   <div class="group">
      <p><label title="If checked, lines in image are computed out of order.  This can give a general idea of the image more quickly."><input type="checkbox" id="interlaced">Interlaced Drawing</label></p>
      <p><label title="If checked, extra computations are done that can often give the completed image a smoother look, by computing two samples per pixel and averaging the resulting colors."><input type="checkbox" id="secondpass">Do a Second Pass</label></p>
      <p><label title="Increasing this can speed up the computation by utilizing more CPUs.">Workers: <select id="threadCountSelect">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7</option>
          <option value="8">8</option>
          <option value="10">10</option>
          <option value="12">12</option>
          <option value="16">16</option>
          <option value="24">24</option>
          <option value="32">32</option>
          <option value="48">48</option>
          <option value="64">64</option>
      </select></label></p>
      <p>
        <label id="localRemote" title="Run calculations locally in the browser or on the remote web server.">
        <input type="radio" id="local" name="location" value="local">
        <label for="local">Browser</label>
        <input type="radio" id="remote" name="location" value="remote">
        <label for="remote">Server</label></label>
      </p>
      <p>
        <label title="If checked, high precision arithmetic will be used even when its not needed (slower)." style="display:none">
        <input type="checkbox" id="highPrecision">High Precision</label>
      </p>
   </div>
   <div class="group">
      <p><button id="undo">Undo</button></p>
      <p><button id="redo">Redo</button></p>
   </div>
   <div class="group">
      <p><label title="Width and height of the Mandelbrot picture, in pixels.">Image Size: <select id="imagesize">
        <option value="0 0">Fit Window</option>
        <option value="640 480">640x480</option>
        <option value="800 600">800x600</option>
          <option value="1024 768">1024x768</option>
          <option value="1600 1200">1600x1200</option>
          <option value="1920 1080">1920x1080</option>
          <option value="1920 1200">1920x1200</option>
          <option value="2560 1440">2560x1440</option>
          <option value="2880 1800">2880x1800</option>
          <option value="3840 1080">3840x1080</option>
          <option value="3840 2160">3840x2160</option>
          <option value="5120 1440">5120x1440</option>
          <option value="7680 4320">7680x4320</option>
          <option value="Custom">Custom</option>
      </select></label><span id="customsize" style="display:none"><br><input type="text" maxlength="4" style="width:4ch" id="customwidth">x<input type="text" maxlength="4" style="width:4ch" id="customheight"> <button id="applysize">Apply</button></span></p>
   </div>
   <div class="group" id="maxIterSlider">
   </div>
   <div class="group">
      <p id="mainPaletteLengthSlider"></p>
      <p id="mainPaletteOffsetSlider"></p>
      <p id="paletteSelectSlider"></p>
      <p><button id="showpaletteedit" title="Show a popup dialog box that gives greater control over the palette.">Show Palette Editor</button>
            &nbsp;(<a href="palette-editor-info.png" target="_blank" title="Opens a guide to the Palette Editor in a separate tab or window.">info</a>)</p>
   </div>
   <div class="group">
      <p id="zoomInSlider"></p>
      <p id="zoomOutSlider"></p>
   </div>
   <div class="grouplast">
      <p><button id="importXML" title="Put up an input box into which you can copy-and-paste the XML code for an example, or get the XML for the current example.">Show XML Import/Export</button></p>
      <p><button id="copyURLFromXML" title='Copy a "permalink" (for sharing the current image) to the clipboard'>Copy Permalink</button></p>
   </div>
</div>
<div class="col2">
  <canvas id="canvas" class="fixedCanvas fullWindowCanvas displayNone"></canvas>
  <div id="status-message"></div>
</div>
</div>
<div id="progressCircle" class="progressCircle displayNone"></div>

<div id="xmlimportbg">
</div>
<div id="xmlimport">
<p>Mandelbrot examples can be coded as "XML documents."<br>
You can copy-and-paste the XML code for an example<br>
into this text input box.  Click "Apply" to import the<br>
example.  Click "Cancel" or press ESC to cancel. The <br>
"Grab Current Example" button loads the XML for the<br>
example that is currently shown in the program; this<br>
allows you to save the example (or even edit it by hand).</p>
<p><button style="margin-left:50px" id="applyXMLimport">Apply</button>
<button style="margin-left:20px" id="cancelXMLimport">Cancel</button>
<button style="margin-left:20px" id="grabcurrent">Grab Current Example</button></p>
<p><textarea rows="21" cols="55" id="XMLtextinput" placeholder="XML code goes here"></textarea>
</div>


<div id="paletteEditor">
<table bgcolor="#E8E8E8" cellpadding=3 cellspacing=0 border=2>
<tr>
   <td colspan=2>
      <table width=620 border=0>
      <tr><td align=left><button id="paletteEditStandardInstall"
             title="Click this button to replace the palette below with the standard palette that is selected on the right.">Install:</button>
          <select id="paletteEditStandardSelect" title="Click the button on the left to apply this palette in the palette editor.">
            <option value="Spectrum">Spectrum</option>
            <option value="EarthAndSky">EarthAndSky</option>
            <option value="Cyclic Fire">Fire</option>
            <option value="Seashore">Seashore</option>
            <option value="TreeColors">Forest</option>
            <option value="Pastels">Pastel Colors</option>
            <option value="Dark">Dark Colors</option>
            <option value="HotAndCold">HotAndCold</option>
            <option value="CyclicGrayscale">Grayscale</option>
            <option value="Random">Random</option>
          </select></td>
          <td align=right><button id="addcolorstop"
                title="Click to add a color stop to the palette below. The stop will be added next to the currently selected stop, if possible.  You can also add a stop by double-clicking the palette.">Add Color Stop</button>
                <button id="deletecolorstop" title="Click to delete the selected color stop. The first and last stops cannot be deleted.">Delete</button>
                <label style="margin-left:20pt" title="Check this box to lock the colors of the first and last color stops so that the two colors are forced to be the same.">Lock<input type="checkbox" id="lockcolors"></label>
          </td>
      </tr>
      </table>
      <p style="margin: 5px 0 0 0"><canvas id="coloredit" width=630 height=80
           title="Click a color stop to select it.  Drag selected color stop (except for the two at the ends) to move it.  Double-click in a free area to add a color stop."></canvas></p>
      <table border=0 cellpadding=0 style="margin:0 0 0 20px">
       <tr><td><canvas id="colorslider0" width=401 height=40
           title="Drag the slider to set the first color component of the selected color stop to a value in the range 0.0 to 1.0."></canvas></td>
           <td><input type=text id="colorinput0" size=5 title="You can type a value for the first color component here, 0.0 to 1.0 for Red, anything greater than or equal to zero for Hue.">
           <span id="colorlabel0">Hue</span></td>
       </tr>
       <tr><td><canvas id="colorslider1" width=401 height=40
           title="Drag the slider to set the second color component of the selected color stop to a value in the range 0.0 to 1.0."></canvas></td>
           <td><input type=text id="colorinput1" size=5 title="You can type a value for the second color component here, in the range 0.0 to 1.0.">
           <span id="colorlabel1">Saturation</span></td>
       </tr>
       <tr><td><canvas id="colorslider2" width=401 height=40
           title="Drag the slider to set the third color component of the selected color stop to a value in the range 0.0 to 1.0."></canvas></td>
           <td><input type=text id="colorinput2" size=5 title="You can type a value for the third color component here, in the range 0.0 to 1.0.">
           <span id="colorlabel2">Brightness</span></td>
       </tr>
      </table>
   </td>
</tr>
<tr>
   <td valign=top>
      <canvas id="histogram" width=420 height=100
          title="Shows the distribution of iteration counts in the image, from 1 up to MaxIterations.  This can help with selecting a good palette length."></canvas>
      <p style="margin: 3px 0 0 9px"><canvas id="histogrampalette" width=408 height=22 style="display:inline"
          title="Shows how colors from palette will actually be applied to each iteration count, based on palette length and palette offset."></canvas></p>
      <table border=0 cellpadding=0 style="margin:3px 0 0 0">
       <tr><td colspan=2><canvas id="lengthslider" width=420 height=40
           title="Drag the slider to set the palette length.  Slider shows values between 1 and MaxIterations."></canvas></td>
       </tr>
       <tr><td align=right colspan=2>
              <input type=text id="editorlengthinput" size=5 
                  title="You can type a value for the palette length here.  It must be 1 or more.">Palette Length</td>
       </tr>
       <tr><td align=right><canvas id="offsetslider" width=250 height=40
           title="Drag the slider to set the palette offset as a percentage in the range 0 to 100."></canvas></td>
           <td align=left><input type=text id="editoroffsetinput" size=5 title="You can type a value for the palette offset percentage, in the range 0.0 to 100.0.">%&nbsp;&nbsp;Offset</td>
       </tr>
      </table>
   </td>
   <td valign=top width=200>
       <table border=0 cellpadding=0>
         <tr><td><canvas id="preview" width=200 height=200 
               title="A rough copy of the current image, with edited colors applied, giving a preview of the image with the edited palette."></td></tr>
         <tr><td><label title="If this box is unchecked, changes are only applied to the above preview when a drag action end.  Uncheck the box if your computer is having trouble keeping up as you drag a slider or color stop.">
               <input type=checkbox id="updateWhileDraggingCheck" checked>UpdateDuringDrag</label></td></tr>
       </table>
   </td>
</tr>
<tr>
   <td align=center  colspan=2>
   <button id="dismissPaletteEdit" title="Cancel palette editing, leaving colors in the image unchanged.">Cancel</button>
   <button id="revertPaletteEdit" title="Restore the palette to the its state when the palette editor was opened.">Revert Palette</button>
   <button id="applyPaletteEdit"  title="Dismiss the palette editor and apply the palette from the editor to the main image.">Apply and Close</button>
   </td>
</tr>
</table>
</div>

</body>
</html>
