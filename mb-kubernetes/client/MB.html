<!DOCTYPE html>
<!--
    Web page written by David Eck, http://math.hws.edu/eck/index.html
    You can do anything you like with this web page and with the code, but
    if you use a substantial portion of it, you should include attribution.
   
    This is a fairly complete "Mandelbrot Set" viewer program, including
    the ability to do arbitrary precision computation (very slowly) when you
    zoom in too far to do the calculations with regular floating point numbers.

    It can save and load examples as XML in a clunky way, by copy-and-paste
    between files and a textarea that appears when "Show XML Input/Export"
    is clicked.  All of the ideas and some of the code were ported from
    an older program that was written in java.
    
    This file depends on the scripts mandelbrot-worker-remote.js and Daniel Trebbien's
    BigDecimal-all-last.min.js.
-->
<html>
<head>
<meta charset="UTF-8">
<title>Mandelbrot Viewer</title>
<!--
<meta property="og:image" content="https://mandelbrot.xxxxxx.com/thumbnail.png"/>
<meta property="og:url" content="https://mandelbrot.xxxxxx.com/MB.html"/>
-->
<meta property="og:type" content="website"/>
<meta property="og:title" content="Mandelbrot Viewer" />
<meta property="og:description" content="This Mandelbrot viewer, originally by David Eck, has been rewritten with a Rust backend, considerably speeding it up."/>
<style type="text/css">
   body {
       background-color: #D8D8D8;
   }
   canvas {
       display: block;
       background-color: #BBBBBB;
   }
   #canvas-holder {
       display: inline-block;
       border: 2px solid black;
       margin: 0;
       padding: 0;
   }
   #controls {
       display: inline-block;
       background-color:white;
       border-left: 2px solid black;
       border-right: 2px solid black;
       border-top: 2px solid black;
       padding: 0;
       margin-right:10px;
   }
   #controls p {
       margin: 12px 0;
       white-space: nowrap;
   }
   div.group {
       padding: 0 8px;
       border-bottom: 2px solid black;
   }
   #imagediv p {
       margin: 4px 0;
       white-space: nowrap;
   }
   #imagediv {
       margin-left: 20px;
       padding: 0;
   }
   #status {
       white-space: nowrap;
       font-weight: bold;
       color: #AA0000;
   }
   #xmlimportbg {
       position: fixed;
       z-index: 10;
       opacity: 0.7;
       background-color: black;
       left: 0;
       top: 0;
       width: 100%;
       height: 100%;
       display: none;
   }
   #xmlimport {
       position: absolute;
       left: 50px;
       top: 50px;
       z-index:20;
       padding: 10px;
       background-color: #D8D8FF;
       border: 2px solid #000099;
       border-radius: 16px;
       box-shadow: 5px 5px 8px black;
       display: none;
   }
   textarea {
     white-space: pre;
     word-wrap: normal;
     overflow-x: scroll;
   }
</style>
<script src="BigDecimal-all-last.min.js"></script>
<script>

"use strict";

var HP_CUTOFF_EXP = 15;
var HP_CUTOFF = new BigDecimal("1e-15");
var TEN = new BigDecimal("10");
var TWO = new BigDecimal("2");


var OSC;  // Off-screen canvas, holds the the Mandelbrot set.
var OSG;  // Graphics context for on-screen canvas.
var canvas;    // On-screen canvas -- shows OSC, with stuff possibly drawn on top.
var graphics;  // Graphics context for on-screen canvas.

var ArrayType = window.Uint32Array || Array;

var workers;
//var wokerCount = 1;
var jobNum = 0;

var running = false;
var repaintTimeout;

var /* BigDecimal */ xmin_requested, ymin_requested, xmax_requested, ymax_requested;
var /* BigDecimal */ xmin, ymin, xmax, ymax;
var /* BigDecimal */ dx, dy;
var /* Uint32Array */ xminArray, yvalArray, dxArray;

var jobs;
var jobsCompleted;
var workerCount = 1;
var jobStartTime, timePerJob;
var highPrecision;

var COMPUTING_FIRST_PASS = 1, DONE_FIRST_PASS = 2, COMPUTING_SECOND_PASS = 3, IDLE = 4;
var state = IDLE;

var dragbox = null;

var maxIterations;
var palette;
var stretchPalette = true;
var fixedPaletteLength = 250;
var paletteLength, paletteOffsetFraction;
var paletteColors;

var savedIterationCounts;
var savedIterationCounts2ndPass;

var imageData, hres, vres;  // for setting pixel colors.

var currentXML = null;

var undoList = null; // will be an array; null here prevents SetDefaults from adding a spurious undo item
var undoCount = 0;
var applyUndoInProgress = false;

var interlaced = true;
var interlaceOrder = (function() {
      var order = [127];
      for (var i = 64; i >= 1; i /= 2) {
          var ct = order.length;
          for (var j = 0; j < ct; j++) {
              order.push(order[j] - i);
          }
      }
      return order;
   })();

var digits, chunks;
var /* BigDecimal */ twoTo16 = new BigDecimal("65536");
var log2of10 = Math.log(10)/Math.log(2);


function convert( /* int[] */ x, /* BigDecimal */ X, /* int */ count) {
    var neg = false;
    if (X.signum() == -1) {
        neg = true;
        X = X.negate();
    }
    x[0] = Number(X.setScale(0,BigDecimal.ROUND_DOWN).toString());
    for (var i = 1; i < count; i++) {
        X = X.subtract(new BigDecimal(""+x[i-1]));
        X = X.multiply(twoTo16);
        x[i] = Number(X.setScale(0,BigDecimal.ROUND_DOWN).toString());
    }
    if (neg) {
        negate(x,count);
    }
    function negate( /* int[] */ x, /* int */ chunks) {
        for (var i = 0; i < chunks; i++)
            x[i] = 0xFFFF-x[i];
        ++x[chunks-1];
        for (var i = chunks-1; i > 0 && (x[i] & 0x10000) != 0; i--) {
            x[i] &= 0xFFFF;
            ++x[i-1];
        }
        x[0] &= 0xFFFF;
    }
}



function setLimits(x1, x2, y1, y2, recordUndo) {
    var oldLimits = [xmin_requested,xmax_requested,ymin_requested,ymax_requested];
    xmin_requested = x1;
    xmax_requested = x2;
    ymin_requested = y1;
    ymax_requested = y2;
    if (xmax_requested.compareTo(xmin_requested) < 0) {
       var temp = xmin_requested;
       xmin_requested = xmax_requested;
       xmax_requested = temp;
    }
    if (ymax_requested.compareTo(ymin_requested) < 0) {
       var temp = ymax_requested;
       ymax_requested = ymin_requested;
       ymin_requested = temp;
    }
    checkAspect();
    if (recordUndo) {
        addUndoItem("Change Limits", oldLimits, [xmin_requested,xmax_requested,ymin_requested,ymax_requested]);
    }
}

function checkAspect() {  // adjust requested x/y limits to match aspect ration of image
    xmin = xmin_requested;
    xmax = xmax_requested;
    ymin = ymin_requested;
    ymax = ymax_requested;
    if (xmin.scale() < HP_CUTOFF_EXP + 8)
        xmin.setScale(HP_CUTOFF_EXP + 8);
    if (xmax.scale() < HP_CUTOFF_EXP + 8)
        xmax.setScale(HP_CUTOFF_EXP + 8);
    if (ymin.scale() < HP_CUTOFF_EXP + 8)
        ymin.setScale(HP_CUTOFF_EXP + 8);
    if (ymax.scale() < HP_CUTOFF_EXP + 8)
        ymax.setScale(HP_CUTOFF_EXP + 8);
    var dx = xmax.subtract(xmin).setScale(Math.max(xmax.scale(),HP_CUTOFF_EXP)*2, BigDecimal.ROUND_HALF_EVEN);
    dx = dx.divide(new BigDecimal("" + canvas.width),BigDecimal.ROUND_HALF_EVEN);
    var precision = 0;
    while (dx.compareTo(TWO) < 0) {
       precision++;
       dx = dx.multiply(TEN);
    }
    if (precision < HP_CUTOFF_EXP)
        precision = HP_CUTOFF_EXP;
    var scale = precision + 5 + Math.floor((precision-10)/10);
    xmin = xmin.setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    xmax = xmax.setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    ymin = ymin.setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    ymax = ymax.setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    
    var width = xmax.subtract(xmin);
    var height = ymax.subtract(ymin);
    var aspect = width.divide(height,BigDecimal.ROUND_HALF_EVEN);
    var windowAspect = new BigDecimal( "" + canvas.width/canvas.height );
    if (aspect.compareTo(windowAspect) < 0) {
        var newWidth = width.multiply(windowAspect).divide(aspect,BigDecimal.ROUND_HALF_EVEN);
        var center = xmax.add(xmin).divide(TWO,BigDecimal.ROUND_HALF_EVEN);
        xmax = center.add(newWidth.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale, BigDecimal.ROUND_HALF_EVEN);
        xmin = center.subtract(newWidth.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    }
    else if (aspect.compareTo(windowAspect) > 0) {
        var newHeight = height.multiply(aspect).divide(windowAspect,BigDecimal.ROUND_HALF_EVEN);
        var center = ymax.add(ymin).divide(TWO,BigDecimal.ROUND_HALF_EVEN);
        ymax = center.add(newHeight.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale,BigDecimal.ROUND_HALF_EVEN);
        ymin = center.subtract(newHeight.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    }
}


function doDraw() {
    graphics.drawImage(OSC,0,0);
    if (dragbox && dragbox.width > 2 && dragbox.height > 2) {
       dragbox.draw();
    }
}

let rowsPerSecond;
let startTime;

function repaint() {
    doDraw();
    if (running) {
       repaintTimeout = setTimeout(repaint, 500);
       let pass = "";
       let elapsedSecs = (Date.now() - startTime)/1000.0;
       if (state == COMPUTING_SECOND_PASS) {
            pass = " second pass";
            //rowsPerSecond = ((canvas.height + jobsCompleted)/elapsedSecs).toPrecision(3) + " rows per second";
       } else {
            rowsPerSecond = (jobsCompleted/elapsedSecs).toPrecision(3) + " rows per second";
       }
       let prec = highPrecision? "high precision, " + digits + " digits" : "normal precision";
       document.getElementById("status").innerHTML =
                "Computing" + pass + ", " + prec + "...  Completed " + jobsCompleted + " of " + canvas.height + " rows at " + rowsPerSecond;
    }
    else {
        document.getElementById("status").innerHTML = "Idle (" + rowsPerSecond + ")";
    }
}

function newWorkers(count) {
    var i;
    if (workers) {
       for (i = 0; i < workers.length; i++) {
          workers[i].terminate();
       }
    }
    workers = [];
    for (i = 0; i < count; i++) {
        workers[i] = new Worker("mandelbrot-worker-remote.js");
        //workers[i] = new Worker("mandelbrot-worker-local.js");
        workers[i].onmessage = jobFinished;
    }
}

function stopJob() {
    if (running) {
       jobNum++;
       running = false;
       document.getElementById("stop").disabled = true;
       if (repaintTimeout)
          clearTimeout(repaintTimeout);
       repaintTimeout = null;
       repaint();
       if (timePerJob < 0 || timePerJob > 150) {
           //console.log("Making new workers");
           newWorkers(workerCount);
       }
    }
}

let maxRowsPerJob = 8;

function startJob() {
    if (running) {
       stopJob();
    }
    graphics.fillRect(0,0,canvas.width,canvas.height);
    OSG.fillStyle="#BBBBBB";
    OSG.fillRect(0,0,canvas.width,canvas.height);
    imageData = OSG.getImageData(0,0,canvas.width,1);
    hres = Math.round(imageData.width/canvas.width);
    vres = imageData.height;
    dx = xmax.subtract(xmin).divide(new BigDecimal(""+(canvas.width-1)),BigDecimal.ROUND_HALF_EVEN);
    dy = ymax.subtract(ymin).divide(new BigDecimal(""+(canvas.height-1)),BigDecimal.ROUND_HALF_EVEN);
    highPrecision = document.getElementById("highprecision").checked || dy.compareTo(HP_CUTOFF) < 0;
    jobs = [];
    var yVal = ymax.add(new BigDecimal("0"));
    var rows = canvas.height;
    var columns = canvas.width;
    savedIterationCounts = new Array(rows);
    savedIterationCounts2ndPass = new Array(rows+1);
    if (highPrecision) {
        digits = xmin.scale();
        chunks = Math.floor((digits * log2of10)/16 + 2);
        dxArray = new ArrayType(chunks+1);
        xminArray = new ArrayType(chunks+1);
        convert(xminArray, xmin, chunks+1);
        convert(dxArray,dx,chunks+1);
        for ( var row = 0; row < rows; row++) {
            let ytmp = yVal.subtract(dx.multiply(new BigDecimal(row.toString())));
            var yValArray = new ArrayType(chunks+1);
            convert(yValArray, ytmp, chunks+1);
            jobs[rows - 1- row] = {
                row: row,
                columns: columns,
                xmin: xminArray,
                dx: dxArray,
                yVal: yValArray,
                dy: 0,
                nrows: 1
            };
            //yVal = yVal.subtract(dy);
        }
    }
    else {
        var xmin_d = Number(xmin.toString());
        var yVal_d = Number(yVal.toString());
        var dx_d = Number(dx.toString());
        var dy_d = Number(dy.toString());
        //console.log(dx_d, dy_d, xmin_d, yVal_d);

        let rowsPerJob = Math.min(maxRowsPerJob, Math.floor(rows/workerCount));
        for (let row = 0; row < rows; row += rowsPerJob) {
            jobs.push({
                row: row,
                columns: columns,
                xmin: xmin_d,
                dx: dx_d,
                yVal: yVal_d,   // to reduce error calculate y in worker as yVal_d - (row + 0..nrows)*dy_d
                dy: dy_d,
                nrows: Math.min(rowsPerJob, rows - row)
            });
        }
        jobs.reverse();     // keep original order
    }
    if (interlaced) {
        var sortedJobs = jobs;
        jobs = [];
        for (var i = 0; i < interlaceOrder.length; i++) {
            for (var j = interlaceOrder[i]; j < sortedJobs.length; j += interlaceOrder.length) {
                jobs.push(sortedJobs[j]);
                //if (sortedJobs[j] == null) {  // for debugging
                //    throw "bad logic";
                //}
                //sortedJobs[j] = null;
            }
        }
    }
    rowsPerSecond = "many rows per second"
    startTime = Date.now();
    jobsCompleted = 0;
    for (var i = 0; i < workerCount; i++) {
        var j = jobs.pop();
        j.workerNum = i;
        workers[i].postMessage(["setup",jobNum, maxIterations,highPrecision,i]);
        workers[i].postMessage([
            "task", j.row, j.columns,
            j.xmin, j.dx, j.yVal, j.dy, j.nrows
        ]);
    }
    running = true;
    document.getElementById("stop").disabled = false;
    var prec = highPrecision? "high precision, " + digits + " digits" : "normal precision";
    document.getElementById("status").innerHTML = "Computing, " + prec + "...";
    repaintTimeout = setTimeout(repaint,333);
    timePerJob = -1;
    jobStartTime = new Date().getTime();
    state = COMPUTING_FIRST_PASS;
    currentXML = currentExampletoXML();
}

function jobFinished(msg) {
    var job = msg.data;
    if (job[0] != jobNum)
       return;
    if (jobs.length > 0) {
       var worker = workers[job[3]];
       var j = jobs.pop();
       worker.postMessage([
            "task", j.row, j.columns,
            j.xmin, j.dx, j.yVal, j.dy, j.nrows
        ]);
    }
    var iterationCounts = job[2];
    let nRows = job[4];
    for (let i = 0; i < nRows; i++) {
        let row = job[1] + i;
        if (state == COMPUTING_FIRST_PASS) {
           savedIterationCounts[row] = iterationCounts[i];
           putRow(row);
        }
        else {
            savedIterationCounts2ndPass[row] = iterationCounts[i];
            // all rows need to be present for averaging second pass if workerCount > 1
            //if (row > 0) {
            //   putRow(row-1);
            //}
        }
    }
    jobsCompleted += nRows;
    timePerJob = ( (new Date().getTime()) - jobStartTime) / jobsCompleted;
    if (state == COMPUTING_FIRST_PASS) {
        if (jobsCompleted == canvas.height) {
          state = DONE_FIRST_PASS;
          stopJob();
          if (document.getElementById("secondpass").checked) {
             startSecondPass();
          }
       }
    }
    else {
        if (jobsCompleted == canvas.height + 1) {
            // all rows need to be present for averaging second pass if workerCount > 1
            for (let row = 0; row < canvas.height; row++) {
                putRow(row);
            }
            state = IDLE;
            stopJob();
        }
    }
}

function startSecondPass() {
    if (running) {
       stopJob();
    }
    dx = xmax.subtract(xmin).divide(new BigDecimal(""+(canvas.width-1)),BigDecimal.ROUND_HALF_EVEN);
    dy = ymax.subtract(ymin).divide(new BigDecimal(""+(canvas.height-1)),BigDecimal.ROUND_HALF_EVEN);
    var dxHalf = dx.divide(TWO,BigDecimal.ROUND_HALF_EVEN);
    var dyHalf = dy.divide(TWO,BigDecimal.ROUND_HALF_EVEN);
    highPrecision = document.getElementById("highprecision").checked || dy.compareTo(HP_CUTOFF) < 0;
    jobs = [];
    var yVal = ymax.add(dyHalf);
    var xStart = xmin.subtract(dxHalf);
    var rows = canvas.height + 1;
    var columns = canvas.width + 1;
    if (highPrecision) {
        digits = xmin.scale();
        chunks = Math.floor((digits * log2of10)/16 + 2);
        dxArray = new ArrayType(chunks+1);
        xminArray = new ArrayType(chunks+1);
        convert(xminArray, xStart, chunks+1);
        convert(dxArray,dx,chunks+1);
        for ( var row = 0; row < rows; row++) {
            let ytmp = yVal.subtract(dx.multiply(new BigDecimal(row.toString())));
            var yValArray = new ArrayType(chunks+1);
            convert(yValArray, ytmp, chunks+1);
            jobs[rows - 1- row] = {
                row: row,
                columns: columns,
                xmin: xminArray,
                dx: dxArray,
                yVal: yValArray,
                dy: 0,
                nrows: 1
            };
            //yVal = yVal.subtract(dy);
        }
    }
    else {
        var xmin_d = Number(xStart.toString());
        var yVal_d = Number(yVal.toString());
        var dx_d = Number(dx.toString());
        var dy_d = Number(dy.toString());
        //var ymax_d = Number(ymax.toString()) + dy_d/2;

        let rowsPerJob = Math.min(maxRowsPerJob, Math.floor(rows/workerCount));
        for (let row = 0; row < rows; row += rowsPerJob) {
            jobs.push({
                row: row,
                columns: columns,
                xmin: xmin_d,
                dx: dx_d,
                yVal: yVal_d,   // to reduce error calculate y in worker as yVal_d - (row + 0..nrows)*dy_d
                dy: dy_d,
                nrows: Math.min(rowsPerJob, rows - row)
            });
        }
        //jobs.reverse();     // keep original order (don't need to since now we're waiting for all rows to finish before drawing)
    }
    jobsCompleted = 0;
    for (var i = 0; i < workerCount; i++) {
        var j = jobs.pop();
        j.workerNum = i;
        workers[i].postMessage(["setup",jobNum, maxIterations,highPrecision,i]);
        workers[i].postMessage([
            "task", j.row, j.columns,
            j.xmin, j.dx, j.yVal, j.dy, j.nrows
        ]);
    }
    running = true;
    document.getElementById("stop").disabled = false;
    var prec = highPrecision? "high precision, " + digits + " digits" : "normal precision";
    document.getElementById("status").innerHTML = "Computing 2nd Pass, " + prec + "...";
    repaintTimeout = setTimeout(repaint,500);
    timePerJob = -1;
    jobStartTime = new Date().getTime();
    state = COMPUTING_SECOND_PASS;
}

function putRow(row) {
    var iterationCounts = savedIterationCounts[row];
    var above = savedIterationCounts2ndPass[row];
    var below = savedIterationCounts2ndPass[row+1];
    var average = above && below;
    var secondPassColor;
    var ct;
    if (average) {
       ct = above[0];
       var c1 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
       ct = below[0];
       var c2 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
       secondPassColor = [c1[0]+c2[0],c1[1]+c2[1],c1[2]+c2[2]];
    }
    var columns = canvas.width;
    for (var i = 0; i < columns; i++) {
       ct = iterationCounts[i];
       var color;
       if (ct < 0) {
          color = [0,0,0];
       }
       else {
          var paletteIndex = iterationCounts[i] % paletteLength;
          color = paletteColors[paletteIndex];
       }
       if (average) {
           ct = above[i+1];
           var c1 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
           ct = below[i+1];
           var c2 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
           var secondPassColor2 = [c1[0]+c2[0],c1[1]+c2[1],c1[2]+c2[2]];
           color = [ // had a bug where I modified the color that was still in the palette array!
               ( 4*color[0] + secondPassColor[0] + secondPassColor2[0] ) / 8,
               ( 4*color[1] + secondPassColor[1] + secondPassColor2[1] ) / 8,
               ( 4*color[2] + secondPassColor[2] + secondPassColor2[2] ) / 8
           ];
           secondPassColor = secondPassColor2;
       }
       var p = 4*i*hres;
       for (var j = 0; j < hres; j++) {
           imageData.data[p] = color[0];
           imageData.data[p+1] = color[1];
           imageData.data[p+2] = color[2];
           imageData.data[p+3] = 255;
       }
    }
    for (var i = 0; i < vres; i++) {
        OSG.putImageData(imageData,0,row*vres+i);
    }
}

function setDefaults() {
    var oldXML = currentXML;
    stopJob();
    setLimits(new BigDecimal("-2.2"), new BigDecimal("0.8"), new BigDecimal("-1.2"), new BigDecimal("1.2"), false);
    stretchPalette = false;
    fixedPaletteLength = 250;
    maxIterations = 250;
    paletteOffsetFraction = 0;
    palette = new Palette();
    createPaletteColors();
    document.getElementById("maxIterSelect").value = "250";
    document.getElementById("custommaxiter").style.display = "none";
    document.getElementById("custompallen").style.display = "none";
    document.getElementById("custoffset").style.display = "none";
    document.getElementById("customsize").style.display = "none";
    document.getElementById("paletteLengthSelect").value = "250";
    document.getElementById("paletteOffsetSelect").value = "0";
    document.getElementById("imagesize").value = "800 600";
    if (canvas.width != 800 || canvas.height != 600) {
      canvas.width = 800;
      canvas.height = 600;
      OSC.width = 800;
      OSC.height = 600;
      checkAspect();
    }
    startJob();
    if (undoList) {
        addUndoItem("Restore Defaults", oldXML, currentXML);
    }
}

function remapColors() {
    for (var row = 0; row < canvas.height; row++) {
       if (savedIterationCounts[row]) {
           putRow(row);
       }
    }
    doDraw();
    currentXML = currentExampletoXML();
}

function createPaletteColors() {
    var length = stretchPalette ? maxIterations : fixedPaletteLength;
    paletteLength = length;
    var offset = Math.round(paletteOffsetFraction * paletteLength);
    paletteColors = palette.makeRGBs(paletteLength,offset);
}

function DragBox(x,y) {
    this.x = this.left = x;
    this.y = this.top = y;
    this.width = 0;
    this.height = 0;
}
DragBox.prototype.draw = function() {  // Draw the box on the on-screen canvas
    graphics.strokeStyle = "#FFFFFF";
    graphics.lineWidth = 4;
    graphics.strokeRect(this.left,this.top,this.width,this.height);
    graphics.strokeStyle = "#000000";
    graphics.lineWidth = 2;
    graphics.strokeRect(this.left,this.top,this.width,this.height);
}
DragBox.prototype.setCorner = function(x1,y1) {
    var w = Math.abs(x1 - this.x);
    var h = Math.abs(y1 - this.y);
    if (w < 3 || h < 3) {
        this.width = this.height = 0;
        return;
    }
    var aspect = canvas.width/canvas.height;
    var rectAspect = w / h;
    if (aspect > rectAspect)
        w = Math.round(w*aspect/rectAspect);
    else if (aspect < rectAspect)
        h = Math.round(h*rectAspect/aspect);
    if (this.x < x1) {
        this.left = this.x;
    }
    else {
        this.left = this.x - w;
    }
    if (this.y < y1) {
        this.top = this.y;
    }
    else {
        this.top = this.y - h;
    }
    this.width = w;
    this.height = h;
}
DragBox.prototype.zoom = function(zoomin) {
    if (this.width <= 2 || this.height <= 2)
       return;
    stopJob();
    if (zoomin == false) {
        doZoomOutFromRect(this.left, this.top, this.width, this.height);
    }
    else {
        doZoomInOnRect(this.left, this.top, this.width, this.height);
    }
    startJob();
}

function doZoomInOnRect(x,y,width,height) {
    var rectX = new BigDecimal("" + Math.round(x));  // (Firefox can have fractional parts)
    var rectY = new BigDecimal("" + Math.round(y));
    var rectW = new BigDecimal("" + Math.round(width));
    var rectH = new BigDecimal("" + Math.round(height));
    var ImageWidth = new BigDecimal("" + canvas.width);
    var ImageHeight = new BigDecimal("" + canvas.height);
    var pixelWidth = xmax.subtract(xmin).divide(ImageWidth,BigDecimal.ROUND_HALF_EVEN);
    var pixelHeight = ymax.subtract(ymin).divide(ImageHeight,BigDecimal.ROUND_HALF_EVEN);
    var newXmin,newXmax,newYmin,newYmax;
    newXmin = xmin.add(pixelWidth.multiply(rectX));
    newYmax = ymax.subtract(pixelHeight.multiply(rectY));
    var newWidth = pixelWidth.multiply(rectW);
    var newHeight = pixelHeight.multiply(rectH);
    newXmax = newXmin.add(newWidth);
    newYmin = newYmax.subtract(newHeight);
    setLimits(newXmin, newXmax, newYmin, newYmax, true);
}

function doZoomOutFromRect(x,y,width,height) {
    var rectX = new BigDecimal("" + Math.round(x));
    var rectY = new BigDecimal("" + Math.round(y));
    var rectW = new BigDecimal("" + Math.round(width));
    var rectH = new BigDecimal("" + Math.round(height));
    var ImageWidth = new BigDecimal("" + canvas.width);
    var ImageHeight = new BigDecimal("" + canvas.height);
    var newPixelWidth = xmax.subtract(xmin).divide(rectW,BigDecimal.ROUND_HALF_EVEN);
    var newPixelHeight = ymax.subtract(ymin).divide(rectH,BigDecimal.ROUND_HALF_EVEN);
    var newXmin,newXmax,newYmin,newYmax;
    newXmin = xmin.subtract(newPixelWidth.multiply(rectX));
    newYmax = ymax.add(newPixelHeight.multiply(rectY));
    var newWidth = newPixelWidth.multiply(ImageWidth);
    var newHeight = newPixelHeight.multiply(ImageHeight);
    newXmax = newXmin.add(newWidth);
    newYmin = newYmax.subtract(newHeight);
    setLimits(newXmin, newXmax, newYmin, newYmax, true);
}

function zoom(x, y, zoomFactor, recenter) {  // (x,y) is center of zoom, in pizels; recenter moves that point to center of image
    stopJob();
    var zf = new BigDecimal("" + zoomFactor);
    var X = new BigDecimal("" + Math.round(x));
    var Y = new BigDecimal("" + Math.round(y));
    var ImageWidth = new BigDecimal("" + canvas.width);
    var ImageHeight = new BigDecimal("" + canvas.height);
    var oldWidth = xmax.subtract(xmin);
    var oldHeight = ymax.subtract(ymin);
    var newWidth = oldWidth.multiply(zf);
    var newHeight = oldHeight.multiply(zf);
    if (newWidth.compareTo(new BigDecimal("100")) > 0) {
        document.getElementById("status").innerHTML =
            "Zooming out that far would reduce the whole Mandelbrot set to a dot.  Ignored.";
        return;
    }
    var pixelWidth = newWidth.divide(ImageWidth,BigDecimal.ROUND_HALF_EVEN);
    var pixelHeight = newHeight.divide(ImageHeight,BigDecimal.ROUND_HALF_EVEN);
    var centerX = xmin.add(X.multiply(oldWidth).divide(ImageWidth,BigDecimal.ROUND_HALF_EVEN));
    var centerY = ymax.subtract(Y.multiply(oldHeight).divide(ImageHeight,BigDecimal.ROUND_HALF_EVEN));
    var newXmin,newXmax,newYmin,newYmax;
    if (recenter) {
        newXmin = centerX.subtract(newWidth.divide(TWO,BigDecimal.ROUND_HALF_EVEN));
        newYmax = centerY.add(newHeight.divide(TWO,BigDecimal.ROUND_HALF_EVEN));
    }
    else {
        newXmin = centerX.subtract(X.multiply(pixelWidth));
        newYmax = centerY.add(Y.multiply(pixelHeight));
    }
    newYmin = newYmax.subtract(newHeight);
    newXmax = newXmin.add(newWidth);
    setLimits(newXmin, newXmax, newYmin, newYmax, true);
    startJob();
}


function setUpDragging() {
    var zoomin;
    var dragging = false; // for mouse only, to delay dragging until mouse moves.
    var startX, startY; // for mouse only
    dragbox = null;  // initially, the mouse is not being dragged.
    function startDrag(clientX,clientY) {
        var r = canvas.getBoundingClientRect();
        var x = clientX - r.left;
        var y = clientY - r.top;
        dragbox = new DragBox(x,y);
        doDraw();
    }
    function continueDrag(clientX,clientY) {
        var r = canvas.getBoundingClientRect();
        var x = clientX - r.left;
        var y = clientY - r.top;
        dragbox.setCorner(x,y);
        doDraw();
    }
    function endDrag() {
        dragbox.zoom(zoomin);
        dragbox = null;
    }
    function doMouseDoubleClick(evt) {
        if (dragbox || evt.button != 0) {
            return;
        }
        var r = canvas.getBoundingClientRect();
        var x = evt.clientX - r.left;
        var y = evt.clientY - r.top;
        var zoomFactor = evt.shiftKey? 2 : 0.5;
        zoom(x,y,zoomFactor,!evt.altKey);
    }
    function doMouseDown(evt) {
        if (dragging || evt.button != 0) {
            return;
        }
        dragging = true;
        startX = evt.clientX;
        startY = evt.clientY;
        dragbox = null;
        zoomin = !evt.shiftKey;
        canvas.addEventListener("mousemove",doMouseMove,false);
        document.addEventListener("mouseup",doMouseUp,false);
    }
    function doMouseMove(evt) {
        if (!dragging) {
            return;
        }
        if (dragbox == null) {
            if ( Math.abs(startX - evt.clientX) < 3 && Math.abs(startY - evt.clientY) < 3) {
                return;  // don't start drag until mouse has moved a bit.
            }
            startDrag(startX,startY);
        }
        continueDrag(evt.clientX,evt.clientY);
    }
    function doMouseUp(evt) {
        if (dragging) {
            dragging = false;
            if (dragbox) {
                endDrag();
            }
            canvas.removeEventListener("mousemove",doMouseMove,false);
            document.removeEventListener("mouseup",doMouseUp,false);
        }
    }
   function doTouchStart(evt){
        if (evt.touches.length != 1) {
           doTouchCancel();
           return;
        }
        if (dragbox) {
            return;
        }
        canvas.addEventListener("touchmove", doTouchMove);
        canvas.addEventListener("touchend", doTouchEnd);
        canvas.addEventListener("touchcancel", doTouchCancel);
        startDrag(evt.touches[0].clientX, evt.touches[0].clientY);
        evt.preventDefault();
    }
    function doTouchMove(evt){
        if (!dragbox)
           return;
        if (evt.touches.length != 1) {
           doTouchCancel();
           return;
        }
        continueDrag(evt.touches[0].clientX, evt.touches[0].clientY);
        evt.preventDefault();
    }
    function doTouchEnd(evt) {
        doTouchCancel();
    }
    function doTouchCancel() {
        if (dragbox) {
           canvas.removeEventListener("touchmove", doTouchMove);
           canvas.removeEventListener("touchend", doTouchEnd);
           canvas.removeEventListener("touchcancel", doTouchCancel);
           endDrag();
        }
    }
    canvas.addEventListener("mousedown",doMouseDown,false);
    canvas.addEventListener("dblclick",doMouseDoubleClick,false);
    canvas.addEventListener("touchstart",doTouchStart,false);
 }

function changeWorkerCount() {
    var ct = Number(document.getElementById("threadCountSelect").value);
    if (workers && ct == workers.length)
       return;
    var restart  = running;
    if (running) {
        stopJob();
    }
    workerCount = ct;
    newWorkers(ct);
    if (restart) {
        startJob();
    }
    try {
      if (window.sessionStorage) {
          window.sessionStorage.mandelbrotWorkerCount = "" + ct;
      }
    }
    catch(e) {
    }
}

function changeMaxIterations() {
    var val = document.getElementById("maxIterSelect").value;
    var iter;
    if (val == "Custom") {
        document.getElementById("maxiterinput").value = "" + maxIterations;
        document.getElementById("custommaxiter").style.display = "inline";
    }
    else {
        document.getElementById("custommaxiter").style.display = "none";
        iter = Number(val);
        setMaxIterations(iter);
    }
}
function setMaxIterations(iter) {
    if (iter == maxIterations)
       return;
    var oldval = maxIterations;
    stopJob();
    maxIterations = iter;
    createPaletteColors();
    startJob();
    addUndoItem("Change MaxIterations", oldval, maxIterations);
}
function doCustomMaxIterations() {
    var iter = Math.round(Number(document.getElementById("maxiterinput").value.trim()));
    if (isNaN(iter) || iter < 10) {
        document.getElementById("status").innerHTML = "Illegal value for max iterations.  Must be an integer greater than 9.";
        return;
    }
    setMaxIterations(iter);
}


function changePaletteLength() {
    var val = document.getElementById("paletteLengthSelect").value;
    var len;
    if (val == "Custom") {
        var length = stretchPalette ? maxIterations : fixedPaletteLength;
        stretchPalette = false;
        fixedPaletteLength = length;
        document.getElementById("palleninput").value = "" + length;
        document.getElementById("custompallen").style.display = "inline";
    }
    else if (val == "Match") {
        var oldval = [stretchPalette, paletteLength];
        stretchPalette = true;
        if (paletteLength != maxIterations) {
            stopJob();
            createPaletteColors();
            startJob();
            addUndoItem("Change PaletteLength", oldval, [stretchPalette,paletteLength]);
        }
        document.getElementById("custompallen").style.display = "none";
    }
    else {
       len = parseInt(val);
       if (len != paletteLength) {
          addUndoItem("Change PaletteLength", [stretchPalette, paletteLength], [false,len]);
       }
       setFixedPaletteLength(len);
       document.getElementById("custompallen").style.display = "none";
    }
}
function setFixedPaletteLength(len) {
    fixedPaletteLength = len;
    stretchPalette = false;
    if (fixedPaletteLength != paletteLength) {
       createPaletteColors();
       remapColors();
    }
}
function doCustomPaletteLength() {
    var val = Math.round(Number(document.getElementById("palleninput").value.trim()));
    if (isNaN(val) || val < 1) {
        document.getElementById("status").innerHTML = "Illegal value for number of colors.  Must be an integer greater than zero.";
        return;
    }
    setFixedPaletteLength(val);
}

function changePaletteOffset() {
    var val = document.getElementById("paletteOffsetSelect").value;
    if (val == "Custom") {
        var current = 100 * paletteOffsetFraction;
        document.getElementById("offsetinput").value = (current == Math.round(current))? current : current.toPrecision(3);
        document.getElementById("custoffset").style.display = "inline";
    }
    else {
        var fractionOffset = Number(val);
        setPaletteOffset(fractionOffset);
        document.getElementById("custoffset").style.display = "none";
    }
}
function doApplyCustomPaletteOffset() {
    var val = Number(document.getElementById("offsetinput").value.trim());
    if (isNaN(val) || val < 0 || val > 100) {
        document.getElementById("status").innerHTML =
             "Illegal value for percentage offset.  Must be a number in the range 0 to 100.";
    }
    else {
       setPaletteOffset(val/100);
    }
}
function setPaletteOffset(fractionOffset) {
    document.getElementById("status").innerHTML = "Idle";
    if (fractionOffset == paletteOffsetFraction) {
        return;
    }
    addUndoItem("Change PaletteOffset", paletteOffsetFraction, fractionOffset);
    paletteOffsetFraction = fractionOffset;
    createPaletteColors();
    remapColors();
}

function changeInterlaced() {
   var checked = document.getElementById("interlaced").checked;
   if (checked == interlaced) {
       return;
   }
   interlaced = checked;
   if (running) {
       stopJob();
       startJob();
   }
}

function changeImageSize() {
    var val = document.getElementById("imagesize").value;
    if (val == "Custom") {
        document.getElementById("customwidth").value = "" + canvas.width;
        document.getElementById("customheight").value = "" + canvas.height;
        document.getElementById("customsize").style.display = "inline";
    }
    else {
        document.getElementById("customsize").style.display = "none";
        var sizes = val.split(" ");
        var width = Number(sizes[0]);
        var height = Number(sizes[1]);
        setImageSize(width,height,true);
    }
}
function setImageSize(w,h) {
    if (w == canvas.width && h == canvas.height) {
        return;
    }
    var oldval = [canvas.width,canvas.height];
    stopJob();
    canvas.width = w;
    canvas.height = h;
    OSC.width = w;
    OSC.height = h;
    checkAspect();
    startJob();
    addUndoItem("Change Image Size", oldval, [canvas.width,canvas.height]);
}
function doCustomSize() {
    var width = Math.round(Number(document.getElementById("customwidth").value.trim()));
    var height = Math.round(Number(document.getElementById("customheight").value.trim()));
    if (isNaN(width) || width < 64 || width > 7680) {
        document.getElementById("status").innerHTML = "Illegal value for image width.  Must be an integer in the range 64 to 7680.";
        return;
    }
    if (isNaN(height) || height < 64 || height > 7680) {
        document.getElementById("status").innerHTML = "Illegal value for image height.  Must be an integer in the range 64 to 7680.";
        return;
    }
    setImageSize(width,height,true);
}

function doApplyStandardPalette() {
    var name = document.getElementById("standardPaletteSelect").value;
    var oldval = palette;
    palette = Palette.createStandardPalette(name);
    createPaletteColors();
    remapColors();
    addUndoItem("Change Palette", oldval, palette);
}

function changeSecondPass() {
    var checked = document.getElementById("secondpass").checked;
    if (checked && !running && state == DONE_FIRST_PASS) {
        startSecondPass();
    }
}

function changeHighPrecision() {
    var checked = document.getElementById("highprecision").checked;
    if (running && checked != highPrecision) {
        stopJob();
        startJob();
    }
}

function doZoomIn() {
    zoom(canvas.width/2, canvas.height/2, document.getElementById("zoomInAmount").value, false);
}

function doZoomOut() {
    zoom(canvas.width/2, canvas.height/2, document.getElementById("zoomOutAmount").value, false);
}

//---------------------- Undo/Redo ---------------------------------------

function doUndo() {
    if (undoCount > 0) {
        var item = undoList[undoCount-1];
        undoCount--;
        document.getElementById("undo").disabled = (undoCount == 0);
        document.getElementById("undo").innerHTML = undoCount? ("Undo " + undoList[undoCount-1].name) : "Undo";
        document.getElementById("redo").disabled = false;
        document.getElementById("redo").innerHTML = "Redo " + item.name;
        applyUndoItem(item.name, item.oldValue);
    }
}

function doRedo() {
    if (undoCount < undoList.length) {
        var item = undoList[undoCount];
        undoCount++;
        document.getElementById("undo").disabled = false;
        document.getElementById("undo").innerHTML = "Undo " + item.name;
        document.getElementById("redo").disabled = (undoCount == undoList.length);
        document.getElementById("redo").innerHTML = (undoCount < undoList.length)? ("Redo " + undoList[undoCount].name) : "Redo";
        applyUndoItem(item.name, item.newValue);
    }
}

function addUndoItem(name, oldValue, newValue) {
    if (applyUndoInProgress) {
        return;
    }
    undoList.length = undoCount;
    undoList.push( { name: name, oldValue: oldValue, newValue: newValue } );
    if (undoList.length > 100) {
        undoList.shift();
    }
    undoCount = undoList.length;
    document.getElementById("undo").disabled = false;
    document.getElementById("undo").innerHTML = "Undo " + name;
    document.getElementById("redo").disabled = true;
    document.getElementById("redo").innerHTML = "Redo";
}

function applyUndoItem(name, value) {
    applyUndoInProgress = true;
    switch (name) {
      case "Restore Defaults":
      case "Import Example":
         installExampleFromXML(value,false,true);
         break;
      case "Change PaletteOffset":
         paletteOffsetFraction = value;
         createPaletteColors();
         remapColors();
         if ([0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9].indexOf(value) < 0) {
              document.getElementById("paletteOffsetSelect").value = "Custom";
              document.getElementById("custoffset").style.display = "inline";
              value *= 100;
              document.getElementById("offsetinput").value = (value == Math.round(value))? value : value.toPrecision(3);
         }
         else {
              document.getElementById("paletteOffsetSelect").value = "" + value;
              document.getElementById("custoffset").style.display = "none";
         }
         break;
      case "Change Limits":
         stopJob();
         setLimits(value[0],value[1],value[2],value[3],false);
         startJob();
         break;
      case "Change Image Size":
         setImageSize(value[0],value[1]);
         var val = value[0] + " " + value[1];
         if (["200 150", "400 300", "640 480", "800 600", "1024 768", "1200 900", "1600 900", "425 550", "850 1100"].indexOf(val) < 0) {
             document.getElementById("imagesize").value = "Custom";
             document.getElementById("customsize").style.display = "inline";
             document.getElementById("customwidth").value = "" + value[0];
             document.getElementById("customheight").value = "" + value[1];
         }
         else {
             document.getElementById("imagesize").value = val;
             document.getElementById("customsize").style.display = "none";
         }
         break;
      case "Change PaletteLength":
         if (value[0]) {
            stretchPalette = true;
            document.getElementById("paletteLengthSelect").value = "Match MaxIter";
            document.getElementById("custompallen").style.display = "none";
         }
         else  {
             stretchPalette = false;
             fixedPaletteLength = value[1];
             if ([50,100,250,500,1000,2500,5000].indexOf(value[1]) < 0) {
                document.getElementById("custompallen").style.display = "inline";
                document.getElementById("paletteLengthSelect").value = "Custom";
                document.getElementById("palleninput").value = "" + value[1];
             }
             else {
                document.getElementById("custompallen").style.display = "none";
                document.getElementById("paletteLengthSelect").value = "" + value[1];
             }
         }
         createPaletteColors();
         remapColors();
         break;
      case "Change MaxIterations":
         setMaxIterations(value);
         if ([25,50,100,250,500,1000,2500,5000,10000,25000,50000].indexOf(value) < 0) {
             document.getElementById("custommaxiter").style.display = "inline";
             document.getElementById("maxIterSelect").value = "Custom";
             document.getElementById("maxiterinput").value = "" + value;
         }
         else {
             document.getElementById("custommaxiter").style.display = "none";
             document.getElementById("maxIterSelect").value = "" + value;
         }
         break;
      case "Change Palette":
         palette = value;
         createPaletteColors();
         remapColors();
         break;
    }
    applyUndoInProgress = false;
}

//--------------------- Palette ------------------------------------------
function Palette(colorType,divisionPoints,colors) {
   this.colorType = colorType || "HSB";
   this.divisionPoints = divisionPoints || [0,1];
   this.divisionColors = colors || (this.colorType == "HSB" ? [ [0,1,1], [1,1,1] ] : [ [1,1,1], [0,0,0] ]);
}
Palette.prototype.getColor = function(position) {  // 0.0 <= position <= 1.0
    var pt = 1;
    while (position > this.divisionPoints[pt])
        pt++;
    var ratio = (position - this.divisionPoints[pt-1]) /
                   (this.divisionPoints[pt] - this.divisionPoints[pt-1]);
    var c1 = this.divisionColors[pt-1];
    var c2 = this.divisionColors[pt];
    var a = c1[0] + ratio*(c2[0] - c1[0]);
    var b = c1[1] + ratio*(c2[1] - c1[1]);
    var c = c1[2] + ratio*(c2[2] - c1[2]);
    return this.toRGB(a,b,c);
}
Palette.prototype.toRGB = function(a,b,c) {  // 3 non-clamped color components.
    a = (this.colorType == "HSB")? (a - Math.floor(a)) : clamp(a);
    b = clamp(b);
    c = clamp(c);
    var color;
    if (this.colorType == "HSB")
        color = rgbFromHSV(a, b, c);
    else
        color = [a,b,c];
    color[0] = Math.round(color[0]*255);
    color[1] = Math.round(color[1]*255);
    color[2] = Math.round(color[2]*255);
    return color;
	function clamp(x) {
		x = 2*(x/2 - Math.floor(x/2));
		if (x > 1)
			x = 2 - x;
		return x;
	}
    function rgbFromHSV(h,s,v) {  // all components in range 0 to 1
        h *= 360;
        var r,g,b;
        var c,x;
        c = v*s;
        x = (h < 120)? h/60 : (h < 240)? (h-120)/60 : (h-240)/60;
        x = c * (1-Math.abs(x-1));
        x += (v-c);
        switch (Math.floor(h/60)) {
            case 0: r = v; g = x; b = v-c; break;
            case 1: r = x; g = v; b = v-c; break;
            case 2: r = v-c; g = v; b = x; break;
            case 3: r = v-c; g = x; b = v; break;
            case 4: r = x; g = v-c; b = v; break;
            case 5: r = v; g = v-c; b = x; break;
        }
        return [r,g,b];
    }
}
Palette.prototype.makeRGBs = function(paletteLength, offset) {
    var rgb = new Array(paletteLength);
    rgb[offset % paletteLength] =
             this.toRGB(this.divisionColors[0][0],this.divisionColors[0][1],this.divisionColors[0][2]);
    var dx = 1.0 / (paletteLength-1);
    for (var i = 1; i < paletteLength-1; i++) {
        rgb[(offset+i) % paletteLength] = this.getColor(i*dx);
    }
    var last = this.divisionColors.length - 1;
    rgb[(offset+paletteLength-1) % paletteLength] =
              this.toRGB(this.divisionColors[last][0],this.divisionColors[last][1],this.divisionColors[last][2]);
    return rgb;
}
Palette.prototype.toXMLString = function() {
   var xml = "<palette colorType='" + this.colorType + "'>\n";
   for (var i = 0; i < this.divisionPoints.length; i++) {
       xml += "   <divisionPoint position='" + this.divisionPoints[i] + "' color='" +
            this.divisionColors[i][0] + ";" + this.divisionColors[i][1] + ";" +this.divisionColors[i][2] +
            "'/>\n";
   }
   xml += "</palette>\n";
   return xml;
}
Palette.fromXML = function( paletteNode ) {  // can throw an exception
    try {
       var children = paletteNode.childNodes;
       var type = paletteNode.getAttribute("colorType") || "RBG";
       if (type != "HSB" && type != "RGB") {
           throw "Bad colorType.";
       }
       var points = [];
       var colors = [];
       for (var i = 0; i < children.length; i++) {
          var child = children.item(i);
          if (child.nodeType == 1 && child.tagName == "divisionPoint") { // element node
              var pt = child.getAttribute("position");
              var rgb = child.getAttribute("color");
              if (pt === null || rgb === null) {
                  throw "Missing data for divisionPoint";
              }
              pt = Number(pt);
              rgb = rgb.split(";");
              rgb = [Number(rgb[0]),Number(rgb[1]),Number(rgb[2])];
              if (isNaN(pt) || pt < 0 || pt > 1) {
                   throw "Bad data for divisionPoint";
              }
              for (var j = 0; j < 3; j++) {
                   if (isNaN(rgb[j]) || rgb[j] < 0 ){
                      throw "Bad data for divisionPoint color";
                   }
              }
              if (i > 0 && pt <= points[points.length-1]) {
                  throw "Division points out of order";
              }
              points.push(pt);
              colors.push(rgb);
          }
       }
       if (points.length < 2 || points[0] != 0 || points[points.length-1] != 1) {
           throw "Illegal divisionPoint data"
       }
       return new Palette(type, points, colors);
    }
    catch (e) {
        throw "Illegal palette definition: " + e;
    }
}
Palette.createStandardPalette = function(name) {
    var palette;
    switch (name) {
        case "Grayscale":
           palette = new Palette("RGB");
           break;
        case "CyclicGrayscale":
           palette = new Palette("RGB",[0,0.5,1],[[0,0,0],[1,1,1],[0,0,0]]);
           break;
        case "Red/Cyan":
           palette = new Palette("RGB",[0,0.5,1],[[1,0,0],[0,1,1],[1,0,0]]);
           break;
        case "Blue/Gold":
           palette = new Palette("RGB",[0,0.5,1],[[0.1,0.1,1],[1,0.6,0],[0.3,0.3,1]]);
           break;
        case "EarthAndSky":
           palette = new Palette("RGB",[0,0.15,0.33,0.67,0.85,1],
                     [[1,1,1],[1,0.8,0],[0.53,0.12,0.075],[0,0,0.6],[0,0.4,1],[1,1,1]]);
           break;
        case "HotAndCold":
           palette = new Palette("RGB",[0,0.16,0.5,0.84,1],
                     [[1,1,1],[0,0.4,1],[0.2,0.2,0.2],[1,0,0.8],[1,1,1]]);
           break;
        case "Fire":
           palette = new Palette("RGB",[0,0.17,0.83,1],
                     [[0,0,0],[1,0,0],[1,1,0],[1,1,1]]);
           break;
        case "TreeColors":
           palette = new Palette("HSB",[0,0.33,0.66,1],
                     [[0.1266,0.5955,0.2993],[0.0896,0.3566,0.6575],[0.6195,0.8215,0.4039],[0.1266,0.5955,0.2993]]);
           break;
        case "Seashore":
           palette = new Palette("RGB",[0,0.1667,0.3333,0.5,0.6667,0.8333,1],
                     [[0.7909,0.9961,0.7630],[0.8974,0.8953,0.6565],[0.9465,0.3161,0.1267],[0.5184,0.1109,0.0917],
                              [0.0198,0.4563,0.6839],[0.5385,0.8259,0.8177],[0.7909,0.9961,0.7630]]);
           break;
        case "Random":
           var c = [Math.random(),Math.random(),Math.random()];
           palette = new Palette("RGB",[],[]);
           palette.divisionPoints[0] = 0;
           palette.divisionColors[0] = c;
           for (var i = 1; i <= 5; i++) {
               palette.divisionPoints[i] = i/6;
               palette.divisionColors[i] = [Math.random(),Math.random(),Math.random()];
           }
           palette.divisionPoints[6] = 1;
           palette.divisionColors[6] = c;
           break;
        default: // "Spectrum"
           palette = new Palette();
    }
    return palette;
}

//-------------------------------------------------------------------------------------------

function currentExampletoXML() {
    var offset = Math.round(paletteOffsetFraction * paletteLength);
    return "<?xml version='1.0'?>\n<mandelbrot_settings_2>\n" +
            "<image_size width='" + canvas.width + "' height='" + canvas.height + "'/>\n" +
            "<limits>\n   <xmin>" + xmin_requested.toString() + "</xmin>\n" +
            "   <xmax>" + xmax_requested.toString() + "</xmax>\n" +
            "   <ymin>" + ymin_requested.toString() + "</ymin>\n" +
            "   <ymax>" + ymax_requested.toString() + "</ymax>\n</limits>\n" +
            palette.toXMLString() +
            "<palette_mapping length='" + paletteLength + "' offset='" + offset + "'/>\n" +
            "<max_iterations value='" + maxIterations + "'/>\n" +
            "</mandelbrot_settings_2>\n";
}

function installExampleFromXML(xmlString, recordUndo, respectSize) {
    var oldXML = currentXML;
    stopJob();
    try {
      var parser = new DOMParser();
      var doc = parser.parseFromString(xmlString,"text/xml").documentElement;
      var width,height,xmin,xmax,ymin,ymax,colors,length,offset,iterations;
      if (respectSize) {
          var size = doc.getElementsByTagName("image_size");
          if (size == 0) {
              respectSize = false;
          }
          else {
              width = Number(size[0].getAttribute("width"));
              height = Number(size[0].getAttribute("height"));
              if (isNaN(width) || width > 4096 || width < 64 || isNaN(height) || height > 4096 || height < 64) {
                   respectSize = false;
              }
          }
      }
      xmin = doc.getElementsByTagName("xmin").item(0).textContent;
      xmax = doc.getElementsByTagName("xmax").item(0).textContent;
      ymin = doc.getElementsByTagName("ymin").item(0).textContent;
      ymax = doc.getElementsByTagName("ymax").item(0).textContent;
      colors = Palette.fromXML( doc.getElementsByTagName("palette").item(0));
      var map = doc.getElementsByTagName("palette_mapping");
      if (map.length > 0) {
          length = Number(map.item(0).getAttribute("length"));
          offset = Number(map.item(0).getAttribute("offset"));
      }
      else {
          length = 250;
          offset = 0;
      }
      iterations = Number(doc.getElementsByTagName("max_iterations").item(0).getAttribute("value"));
      xmin = new BigDecimal(xmin);
      xmax = new BigDecimal(xmax);
      ymin = new BigDecimal(ymin);
      ymax = new BigDecimal(ymax);
      if (isNaN(length) || isNaN(offset) || isNaN(iterations)) {
          throw "Bad number.";
      }
      if (length == 0) {
          length = iterations;
      }
      palette = colors;
      maxIterations = Math.round(iterations);
      if ([25,50,100,250,500,1000,2500,5000,10000,25000,50000].indexOf(maxIterations) < 0) {
          document.getElementById("custommaxiter").style.display = "inline";
          document.getElementById("maxIterSelect").value = "Custom";
          document.getElementById("maxiterinput").value = "" + iterations;
      }
      else {
          document.getElementById("custommaxiter").style.display = "none";
          document.getElementById("maxIterSelect").value = "" + maxIterations;
      }
      length = Math.round(length);
      if (length == 0) {
         stretchPalette = true;
         document.getElementById("paletteLengthSelect").value = "Match MaxIter";
         document.getElementById("custompallen").style.display = "none";
      }
      else  {
          stretchPalette = false;
          fixedPaletteLength = length;
          if ([50,100,250,500,1000,2500,5000].indexOf(length) < 0) {
             document.getElementById("custompallen").style.display = "inline";
             document.getElementById("paletteLengthSelect").value = "Custom";
             document.getElementById("palleninput").value = "" + length;
          }
          else {
             document.getElementById("custompallen").style.display = "none";
             document.getElementById("paletteLengthSelect").value = "" + length;
          }
      }
      paletteOffsetFraction = offset/length;
      paletteOffsetFraction = paletteOffsetFraction - Math.floor(paletteOffsetFraction);
      paletteOffsetFraction = Math.round(10000*paletteOffsetFraction)/10000;
      if (offset == 0) {
           document.getElementById("custoffset").style.display = "none";
           document.getElementById("paletteOffsetSelect").value = "0";
      }
      else {
           document.getElementById("custoffset").style.display = "inline";
           document.getElementById("paletteOffsetSelect").value = "Custom";
           var current = 100*paletteOffsetFraction;
           document.getElementById("offsetinput").value = (current == Math.round(current))? current : current.toPrecision(3);
      }
      createPaletteColors();
      if (respectSize) {
         setImageSize(width,height);
         var val = width + " " + height;
         if (["200 150", "400 300", "640 480", "800 600", "1024 768", "1200 900", "1600 900", "425 550", "850 1100"].indexOf(val) < 0) {
             document.getElementById("imagesize").value = "Custom";
             document.getElementById("customsize").style.display = "inline";
             document.getElementById("customwidth").value = "" + width;
             document.getElementById("customheight").value = "" + height;
         }
         else {
             document.getElementById("imagesize").value = val;
             document.getElementById("customsize").style.display = "none";
         }
      }
      setLimits(xmin,xmax,ymin,ymax,false);
      startJob();
      if (recordUndo && undoList) {
          addUndoItem("Import Example", oldXML, currentXML);
      }
    }
    catch (e) {
        document.getElementById("status").innerHTML = "Illegal data in XML example string: " + e;
    }
}

function installExampleWithAjax(url) {
    document.getElementById("status").innerHTML = "Trying to Fetch example from " + url;
    var ajaxTimeout;
    var ajax = new XMLHttpRequest();
    ajax.open("GET",url);
    ajax.overrideMimeType("text/plain");
    ajax.addEventListener("error",function() {
        clearTimeout(ajaxTimeout);
        document.getElementById("status").innerHTML = "Error: Example could not be loaded from " + url;
    });
    ajax.addEventListener("load",function() {
        clearTimeout(ajaxTimeout);
        installExampleFromXML(ajax.responseText, false, false);
    });
    ajaxTimeout = setTimeout(function() {
        ajax.abort();
        document.getElementById("status").innerHTML = "Error: Request timed out while trying to load from " + url;
    }, 10000);
    try {
       ajax.send();
    } catch(e) {
        clearTimeout(ajaxTimeout);
        document.getElementById("status").innerHTML = "Error while trying to send request for example: " + url;
    }
}

function importXML() {
    document.getElementById("XMLtextinput").value = "";
    document.getElementById("xmlimportbg").style.display = "block";
    document.getElementById("xmlimport").style.display = "block";
    document.addEventListener("keydown", doKey, false);
    document.getElementById("cancelXMLimport").onclick = dismiss;
    document.getElementById("applyXMLimport").onclick = apply;
    document.getElementById("grabcurrent").onclick = grabCurrent;
    function apply() {
        var text = document.getElementById("XMLtextinput").value.trim();
        dismiss();
        if (text != "") {
            installExampleFromXML(text,true,false);
        }
    }
    function dismiss() {
        document.getElementById("xmlimportbg").style.display = "none";
        document.getElementById("xmlimport").style.display = "none";
        document.removeEventListener("keydown", doKey, false);
    }
    function grabCurrent() {
        document.getElementById("XMLtextinput").value = currentXML;
    }
    function doKey(evt) {
        var code = evt.keyCode;
        if (code == 27) {
            dismiss();
        }
    }
}

function checkForExample() {
    var ex = window.location.search.match("^\\?ex=([a-zA-Z0-9/.%_+-]+)");
    if (ex) {
       stopJob();
       installExampleWithAjax(decodeURIComponent(ex[1]), false);
    }
}

function init() {
    try {
        canvas = document.getElementById("canvas");
        graphics = canvas.getContext("2d");
        OSC = document.createElement("canvas");
        OSC.width = canvas.width;
        OSC.height = canvas.height;
        OSG = OSC.getContext("2d");
    }
    catch (e) {
         document.getElementById("message").innerHTML =
             "Sorry, this page requires canvas support, which is not available in your browser.";
         return;
    }
    if (! window.Worker ) {
         document.getElementById("message").innerHTML =
             "Sorry, this page requires WebWorker support, which is not available in your browser.";
         return;
    }
    palette = new Palette();
    document.getElementById("restoreButton").onclick = setDefaults;
    document.getElementById("stop").onclick = stopJob;
    document.getElementById("interlaced").onchange = changeInterlaced;
    document.getElementById("interlaced").checked = interlaced;
    document.getElementById("imagesize").onchange = changeImageSize;
    document.getElementById("applysize").onclick = doCustomSize;
    try {
      if (window.sessionStorage && window.sessionStorage.mandelbrotWorkerCount) {
          var ct = Math.round(Number(window.sessionStorage.mandelbrotWorkerCount));
          if (!isNaN(ct) && ct > 0 && ct <= 8) {
              workerCount = ct;
          }
      }
    }
    catch(e) {
    }
    document.getElementById("threadCountSelect").value = "" + workerCount;
    document.getElementById("threadCountSelect").onchange = changeWorkerCount;
    document.getElementById("maxIterSelect").value = "100";
    document.getElementById("maxIterSelect").onchange = changeMaxIterations;
    document.getElementById("maxiterapply").onclick = doCustomMaxIterations;
    document.getElementById("paletteLengthSelect").onchange = changePaletteLength;
    document.getElementById("pallenapply").onclick = doCustomPaletteLength;
    document.getElementById("paletteOffsetSelect").onchange = changePaletteOffset;
    document.getElementById("offsetapply").onclick = doApplyCustomPaletteOffset;
    document.getElementById("standardPaletteButton").onclick = doApplyStandardPalette;
    document.getElementById("standardPaletteSelect").value = "EarthAndSky";
    document.getElementById("secondpass").checked = false;
    document.getElementById("secondpass").onchange = changeSecondPass;
    document.getElementById("highprecision").checked = false;
    document.getElementById("highprecision").onchange = changeHighPrecision;
    document.getElementById("zoomInAmount").value = "0.1";
    document.getElementById("zoomOutAmount").value = "10";
    document.getElementById("zoomin").onclick = doZoomIn;
    document.getElementById("zoomout").onclick = doZoomOut;
    document.getElementById("importXML").onclick = importXML;
    document.getElementById("undo").onclick = doUndo;
    document.getElementById("undo").disabled = true;
    document.getElementById("redo").onclick = doRedo;
    document.getElementById("redo").disabled = true;
    setUpDragging();
    changeWorkerCount(); // has to be done before setDefaults
    setDefaults();
    checkForExample();
    undoList = [];
    undoCount = 0;
}
</script>
</head>
<body onload="init()">

<noscript><b>Sorry, this page requires JavaScript.</b></noscript>

<h2>Explore the Mandelbrot Set</h2>
<p>
    Based on a browser-only Mandelbrot Set viewer by <a href=http://math.hws.edu/eck/index.html>David Eck</a>,
    this revised client/server viewer can be hosted on a Kubernetes cluster,
    which provides a scalable backend API to perform the calculations.  
    Double-clicking the image (or dragging on it to draw a box) will zoom it in.
    <br><br>
    Calculating the Mandelbrot Set can be very computationally intensive, however it is parallelizable.
    Each "Worker" roughly corresponds to a Kubernetes pod which calculates rows of the image.
    As more workers are added, Kubernetes automatically scales and load balances, bringing in more pods to meet the demand and speed up the computation.
    <p>To see how Kubernetes scales, click on <a href="MB.html?ex=java%2FMandelbrotSettings%2FMandelbrotSettings_25_May_2009_3.xml">this link</a>, 
	    then vary the number of "Workers" to speed it up or slow it down.</p>
</p>
<p id="message"></p>

<table border=0 cellpadding=0 cellspacing=0>
<tr valign="top"><td>
<div id="controls">
   <div class="group">
      <p><button id="restoreButton" title="Restore default limits, image size, palette, max iterations.">Restore Defaults</button><button id="stop" style="margin-left:20px" title="Abort the current computation, if any, leaving an incomplete image.">Stop</button></p>
   </div>
   <div class="group">
      <p><label title="If checked, lines in image are computed out of order."><input type="checkbox" id="interlaced">Interlaced Drawing</label></p>
      <p><label title="If checked, extra computations are done that can often give the completed image a smoother look."><input type="checkbox" id="secondpass">Do a Second Pass</label></p>
      <p><label title="Increasing this can speed up the computation by bringing in more Kubernetes resources.">Workers: <select id="threadCountSelect">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7</option>
          <option value="8">8</option>
          <option value="12">12</option>
          <option value="16">16</option>
          <option value="24">24</option>
          <option value="32">32</option>
      </select></label></p>
      <p><label title="If checked, high precision arithmetic will be used even when its not strictly necessary in order to to retain image quality (slower)."><input type="checkbox" id="highprecision">High Precision</label></p>
   </div>
   <div class="group">
      <p><button id="undo">Undo</button></p>
      <p><button id="redo">Redo</button></p>
   </div>
   <div class="group">
      <p><label title="Width and height of the Mandelbrot picture, in pixels.">Image Size: <select id="imagesize">
          <option value="640 480">640x480</option>
          <option value="800 600">800x600</option>
          <option value="1024 768">1024x768</option>
          <option value="1600 1200">1600x1200</option>
          <option value="1920 1080">1920x1080 (HD)</option>
          <option value="1920 1200">1920x1200</option>
          <option value="2560 1440">2560x1440</option>
          <option value="2880 1800">2880x1800</option>
          <option value="3840 2160">3840x2160 (4K)</option>
          <option value="5120 1440">5120x1440</option>
          <option value="Custom">Custom</option>
      </select></label><span id="customsize" style="display:none"><br><input type="text" maxlength="4" size="4" id="customwidth">x<input type="text" maxlength="4" size="4" id="customheight"> <button id="applysize">Apply</button></span></p>
   </div>
   <div class="group">
      <p><label title="How many steps in the Mandelbrot iteration before giving up and coloring the pixel black.">MaxIterations: <select id="maxIterSelect">
         <option value="25">25</option>
         <option value="50">50</option>
         <option value="100">100</option>
         <option value="250">250</option>
         <option value="500">500</option>
         <option value="1000">1000</option>
         <option value="2500">2500</option>
         <option value="5000">5000</option>
         <option value="10000">10000</option>
         <option value="25000">25000</option>
         <option value="50000">50000</option>
         <option value="Custom">Custom</option>
      </select></label><span id="custommaxiter" style="display:none"><br><input type="text" maxlength="6" size="5" id="maxiterinput"> <button id="maxiterapply">Apply</button></span></p>
   </div>
   <div class="group">
      <p><label title="Size of the color palette for pixels outside the Mandebrot set.">PaletteLength: <select id="paletteLengthSelect">
            <option value="Match">= MaxIter</option>
            <option value="50">50</option>
            <option value="100">100</option>
            <option value="250">250</option>
            <option value="500">500</option>
            <option value="1000">1000</option>
            <option value="2500">2500</option>
            <option value="5000">5000</option>
            <option value="Custom">Custom</option>
      </select></label><span id="custompallen" style="display:none"><br><input type="text" maxlength="5" size="4" id="palleninput"><button id="pallenapply">Apply</button></span>
      <p><label title="Offsets the colors within the palette to get a different mapping">PaletteOffset:</label> <select id="paletteOffsetSelect">
            <option value="0">None</option>
            <option value="0.1">10%</option>
            <option value="0.2">20%</option>
            <option value="0.3">30%</option>
            <option value="0.4">40%</option>
            <option value="0.5">50%</option>
            <option value="0.6">60%</option>
            <option value="0.7">70%</option>
            <option value="0.8">80%</option>
            <option value="0.9">90%</option>
            <option value="Custom">Custom</option>
      </select><span id="custoffset" style="display:none"><br><input type="text" id="offsetinput" maxlength="6" size="5"><b>%</b> &nbsp;<button id="offsetapply">Apply</button></span></p>
      <p style="margin-bottom:4px"><button id="standardPaletteButton">Apply Standard Palette:</button></p>
      <p style="margin-top:0"><select id="standardPaletteSelect" style="margin-left:70px">
            <option value="Spectrum">Spectrum</option>
            <option value="EarthAndSky">EarthAndSky</option>
            <option value="HotAndCold">HotAndCold</option>
            <option value="TreeColors">Forest</option>
            <option value="Seashore">Seashore</option>
            <option value="Fire">Fire</option>
            <option value="Red/Cyan">Red/Cyan</option>
            <option value="Blue/Gold">Blue/Gold</option>
            <option value="Grayscale">Grayscale</option>
            <option value="CyclicGrayscale">CyclicGrayscale</option>
            <option value="Random">Random</option>
      </select></p>
   </div>
   <div class="group">
      <p><button id="zoomin">Zoom in by: </button> <select id="zoomInAmount">
           <option value="0.5">2 X</option>
           <option value="0.2">5 X</option>
           <option value="0.1">10 X</option>
           <option value="0.05">20 X</option>
           <option value="0.02">50 X</option>
           <option value="0.01">100 X</option>
           <option value="0.001">1,000 X</option>
           <option value="0.00001">10,000 X</option>
           <option value="0.000001">100,000 X</option>
      </select></p>
      <p><button id="zoomout">Zoom out by: </button> <select id="zoomOutAmount">
           <option value="2">2 X</option>
           <option value="5">5 X</option>
           <option value="10">10 X</option>
           <option value="20">20 X</option>
           <option value="50">50 X</option>
           <option value="100">100 X</option>
           <option value="1000">1,000 X</option>
           <option value="10000">10,000 X</option>
           <option value="100000">100,000 X</option>
      </select></p>
   </div>
   <div class="group">
      <p><button id="importXML" title="Put up an input box into which you can copy-and-paste the XML code for an example, or get the XML for the current example.">Show XML Import/Export</button></p>
   </div>
</div>
<td>
  <div id="imagediv">
  <p id="status">Image size 800x600.  Idle.</p>
  <p><div id="canvas-holder">
     <canvas id="canvas" width="800" height="600"></canvas>
  </div></p>
  </div>
</td>
</tr>
</table>

<div id="xmlimportbg">
</div>
<div id="xmlimport">
<p>Mandelbrot examples can be coded as "XML documents."<br>
You can copy-and-paste the XML code for an example<br>
into this text input box.  Click "Apply" to import the<br>
example.  Click "Cancel" or press ESC to cancel. The <br>
"Grab Current Example" button loads the XML for the<br>
example that is currently shown in the program; this<br>
allows you to save the example (or even edit it by hand).</p>
<p><button style="margin-left:50px" id="applyXMLimport">Apply</button>
<button style="margin-left:20px" id="cancelXMLimport">Cancel</button>
<button style="margin-left:20px" id="grabcurrent">Grab Current Example</button></p>
<p><textarea rows="21" cols="55" id="XMLtextinput" placeholder="XML code goes here"></textarea>
</div>
<p>
    For more info, instructions, and examples, <a href="MB-info.html">click here</a>.
    The github repository is <a href="https://github.com/wpwoodjr/Mandelbrot-for-Kubernetes">here</a>.
</p>
</body>
</html>
