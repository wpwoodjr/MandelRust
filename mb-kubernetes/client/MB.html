<!DOCTYPE html>
<!--
    Web page written by David Eck, http://math.hws.edu/eck/index.html
    You can do anything you like with this web page and with the code, but
    if you use a substantial portion of it, you should include attribution.

    This is a fairly complete "Mandelbrot Set" viewer program, including
    the ability to do arbitrary precision computation (very slowly) when you
    zoom in too far to do the calculations with regular floating point numbers.

    It can save and load examples as XML in a clunky way, by copy-and-paste
    between files and a textarea that appears when "Show XML Input/Export"
    is clicked.  All of the ideas and some of the code were ported from
    an older program that was written in java.

    This file depends on the scripts mandelbrot-worker-remote.js, mandelbrot-worker-local.js, and Daniel Trebbien's
    BigDecimal-all-last.min.js.

    August, 2019. Added Palette Editor.
    January, 2020. Improved Palette Editor.
    April, 2020.  Cleaned up standard palettes, removed a few, added Dark Colors palette.
    May, 2020.  Change maximum image width and height from 2500 to 10000 (but that
        doesn't necessarily mean very large images will work on every device).
    October, 2021.  Fixed a bug in startJob() and startSecondPass() that showed up
        when the change in y-value from one line to the next is very small.  This was
        done previously by successive subtraction, which introduced errors.  Thanks to
        Robert Munafo for finding and fixing the bug.
    August, 2022.  Use localStorage to save workerCount between sessions.

    Changes by Bill Wood:
    Jul/Aug 2019: Rewrote job processing to be client/server, also fixed y-value issue
    Jul/Aug 2019: Changed HP_CUTOFF from 16 to 15 to avoid artifacts at the limits of f64 precision
    Jul/Aug 2019: Added "High Precision" toggle
    Jan/Feb 2023: Rewrote JavaScript server in Rust to get 10 times speedup in high precision computations
                  When zooming, the zoomed area is displayed using image interpolation while calculations are done
                  Left, right, up, and down arrows shift the image appropriately; page down and page up zoom in and out
                  Max image width/height is now 7680 (8K)
                  Fixed off by factor of 10 error in zoom out by 10,000 and 100,000
                  Added option to run calculations locally on the browser in JavaScript, or on the backend Rust server

-->
<html>
<head>
<meta charset="UTF-8">
<title>Mandelbrot Viewer</title>
<!--
<meta property="og:image" content="https://mandelbrot.xxxxxx.com/thumbnail.png"/>
<meta property="og:url" content="https://mandelbrot.xxxxxx.com/MB.html"/>
-->
<meta property="og:type" content="website"/>
<meta property="og:title" content="Mandelbrot Viewer" />
<meta property="og:description" content="This Mandelbrot viewer, originally by David Eck, has been rewritten with a Rust backend, considerably speeding it up."/>
<style type="text/css">
   body {
       background-color: #D8D8D8;
   }
   canvas {
       display: block;
       background-color: #BBBBBB;
   }
   #canvas-holder {
       display: inline-block;
       border: 2px solid black;
       margin: 0;
       padding: 0;
   }
   #controls {
       display: inline-block;
       background-color:white;
       border-left: 2px solid black;
       border-right: 2px solid black;
       border-top: 2px solid black;
       padding: 0;
       margin-right:10px;
   }
   #controls p {
       margin: 12px 0;
       white-space: nowrap;
   }
   div.group {
       padding: 0 8px;
       border-bottom: 2px solid black;
   }
   #imagediv p {
       margin: 4px 0;
       white-space: nowrap;
   }
   #imagediv {
       margin-left: 20px;
       padding: 0;
   }
   #status {
       white-space: nowrap;
       font-weight: bold;
       color: #AA0000;
   }
   #xmlimportbg {
       position: fixed;
       z-index: 10;
       opacity: 0.7;
       background-color: black;
       left: 0;
       top: 0;
       width: 100%;
       height: 100%;
       display: none;
   }
   #xmlimport, #paletteEditor {
       position: absolute;
       left: 50px;
       top: 50px;
       z-index:20;
       padding: 10px;
       background-color: #D8D8FF;
       border: 2px solid #000099;
       border-radius: 16px;
       box-shadow: 5px 5px 8px black;
       display: none;
   }
   textarea {
     white-space: pre;
     word-wrap: normal;
     overflow-x: scroll;
   }
</style>
<script src="BigDecimal-all-last.min.js"></script>
<script>

"use strict";

var HP_CUTOFF_EXP = 15;
var HP_CUTOFF = new BigDecimal("1e-15");
var TEN = new BigDecimal("10");
var TWO = new BigDecimal("2");


var OSC;  // Off-screen canvas, holds the the Mandelbrot set.
var OSG;  // Graphics context for off-screen canvas.
var canvas;    // On-screen canvas -- shows OSC, with stuff possibly drawn on top.
var graphics;  // Graphics context for on-screen canvas.

var ArrayType = window.Uint32Array || Array;

var workers;
var jobNum = 0;

var running = false;
var repaintTimeout;

var /* BigDecimal */ xmin_requested, ymin_requested, xmax_requested, ymax_requested;
var /* BigDecimal */ xmin, ymin, xmax, ymax;
var /* BigDecimal */ dx, dy;
var /* Uint32Array */ xminArray, yvalArray, dxArray;

var jobs;
var jobsCompleted;
var workerCount = 1;
var jobStartTime, timePerJob;
var highPrecision;

var COMPUTING_FIRST_PASS = 1, DONE_FIRST_PASS = 2, COMPUTING_SECOND_PASS = 3, IDLE = 4;
var state = IDLE;

var dragbox = null;

var maxIterations;
var palette;
var stretchPalette;
var fixedPaletteLength;
var paletteLength, paletteOffsetFraction;
var paletteColors;

var savedIterationCounts;
var savedIterationCounts2ndPass;

var imageData, hres, vres;  // for setting pixel colors.

var currentXML = null;

var undoList = null; // will be an array; null here prevents SetDefaults from adding a spurious undo item
var undoCount = 0;
var applyUndoInProgress = false;

var paletteEditInProgress = false;

var interlaced = true;
var interlaceOrder = (function() {
      var order = [127];
      for (var i = 64; i >= 1; i /= 2) {
          var ct = order.length;
          for (var j = 0; j < ct; j++) {
              order.push(order[j] - i);
          }
      }
      return order;
   })();

var digits, chunks;
var /* BigDecimal */ twoTo16 = new BigDecimal("65536");
var log2of10 = Math.log(10)/Math.log(2);


function convert( /* int[] */ x, /* BigDecimal */ X, /* int */ count) {
    var neg = false;
    if (X.signum() == -1) {
        neg = true;
        X = X.negate();
    }
    x[0] = Number(X.setScale(0,BigDecimal.ROUND_DOWN).toString());
    for (var i = 1; i < count; i++) {
        X = X.subtract(new BigDecimal(""+x[i-1]));
        X = X.multiply(twoTo16);
        x[i] = Number(X.setScale(0,BigDecimal.ROUND_DOWN).toString());
    }
    if (neg) {
        negate(x,count);
    }
    function negate( /* int[] */ x, /* int */ chunks) {
        for (var i = 0; i < chunks; i++)
            x[i] = 0xFFFF-x[i];
        ++x[chunks-1];
        for (var i = chunks-1; i > 0 && (x[i] & 0x10000) != 0; i--) {
            x[i] &= 0xFFFF;
            ++x[i-1];
        }
        x[0] &= 0xFFFF;
    }
}



function setLimits(x1, x2, y1, y2, recordUndo) {
    var oldLimits = [xmin_requested,xmax_requested,ymin_requested,ymax_requested];
    xmin_requested = x1;
    xmax_requested = x2;
    ymin_requested = y1;
    ymax_requested = y2;
    if (xmax_requested.compareTo(xmin_requested) < 0) {
       var temp = xmin_requested;
       xmin_requested = xmax_requested;
       xmax_requested = temp;
    }
    if (ymax_requested.compareTo(ymin_requested) < 0) {
       var temp = ymax_requested;
       ymax_requested = ymin_requested;
       ymin_requested = temp;
    }
    checkAspect();
    if (recordUndo) {
        addUndoItem("Change Limits", oldLimits, [xmin_requested,xmax_requested,ymin_requested,ymax_requested]);
    }
}

function checkAspect() {  // adjust requested x/y limits to match aspect ratio of image
    xmin = xmin_requested;
    xmax = xmax_requested;
    ymin = ymin_requested;
    ymax = ymax_requested;
    if (xmin.scale() < HP_CUTOFF_EXP + 8)
        xmin = xmin.setScale(HP_CUTOFF_EXP + 8);
    if (xmax.scale() < HP_CUTOFF_EXP + 8)
        xmax = xmax.setScale(HP_CUTOFF_EXP + 8);
    if (ymin.scale() < HP_CUTOFF_EXP + 8)
        ymin = ymin.setScale(HP_CUTOFF_EXP + 8);
    if (ymax.scale() < HP_CUTOFF_EXP + 8)
        ymax = ymax.setScale(HP_CUTOFF_EXP + 8);
    var dx = xmax.subtract(xmin).setScale(Math.max(xmax.scale(),HP_CUTOFF_EXP)*2, BigDecimal.ROUND_HALF_EVEN);
    dx = dx.divide(new BigDecimal("" + canvas.width),BigDecimal.ROUND_HALF_EVEN);
    var precision = 0;
    while (dx.compareTo(TWO) < 0) {
       precision++;
       dx = dx.multiply(TEN);
    }
    if (precision < HP_CUTOFF_EXP)
        precision = HP_CUTOFF_EXP;
    var scale = precision + 5 + Math.floor((precision-10)/10);
    xmin = xmin.setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    xmax = xmax.setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    ymin = ymin.setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    ymax = ymax.setScale(scale,BigDecimal.ROUND_HALF_EVEN);

    var width = xmax.subtract(xmin);
    var height = ymax.subtract(ymin);
    var aspect = width.divide(height,BigDecimal.ROUND_HALF_EVEN);
    var windowAspect = new BigDecimal( "" + canvas.width/canvas.height );
    if (aspect.compareTo(windowAspect) < 0) {
        var newWidth = width.multiply(windowAspect).divide(aspect,BigDecimal.ROUND_HALF_EVEN);
        var center = xmax.add(xmin).divide(TWO,BigDecimal.ROUND_HALF_EVEN);
        xmax = center.add(newWidth.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale, BigDecimal.ROUND_HALF_EVEN);
        xmin = center.subtract(newWidth.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    }
    else if (aspect.compareTo(windowAspect) > 0) {
        var newHeight = height.multiply(aspect).divide(windowAspect,BigDecimal.ROUND_HALF_EVEN);
        var center = ymax.add(ymin).divide(TWO,BigDecimal.ROUND_HALF_EVEN);
        ymax = center.add(newHeight.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale,BigDecimal.ROUND_HALF_EVEN);
        ymin = center.subtract(newHeight.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    }
}


function doDraw() {
    // console.log("doDraw from", (new Error()).stack.split("\n")[2].trim().split(" ")[1]);
    if (zoomTimeout) {
        clearInterval(zoomTimeout);
        zoomTimeout = null;
    }
    graphics.drawImage(OSC,0,0);
    if (dragbox && dragbox.width > 2 && dragbox.height > 2) {
       dragbox.draw();
    }
}

let startTime, rowsCompleted;

function repaint() {
    // console.log("repaint from", (new Error()).stack.split("\n")[2].trim().split(" ")[1]);
    doDraw();
    let elapsedSecs = (Date.now() - startTime)/1000.0;
    let rowsPerSecond = (rowsCompleted/elapsedSecs).toPrecision(3) + " rows per second";
    if (running) {
        repaintTimeout = setTimeout(repaint, 500);
        let pass = state == COMPUTING_SECOND_PASS ? " second pass" : "";
        rowsPerSecond = " at " + rowsPerSecond;
        let prec = highPrecision? "high precision, " + digits + " digits" : "normal precision";
        document.getElementById("status").innerHTML =
                    "Computing" + pass + ", " + prec + 
                    (elapsedSecs == 0 ? "" : ("...  Completed " + jobsCompleted + " of " + canvas.height + " rows" + rowsPerSecond));
    }
    else {
        document.getElementById("status").innerHTML = "Idle (" + rowsPerSecond + ")";
    }
}

function newWorkers(count) {
    var i;
    if (workers) {
       for (i = 0; i < workers.length; i++) {
          workers[i].terminate();
       }
    }
    workers = [];
    let jsWorker = "mandelbrot-worker-remote.js";
    if (document.getElementById("local").checked) {
        jsWorker = "mandelbrot-worker-local.js"
    }
    for (i = 0; i < count; i++) {
       workers[i] = new Worker(jsWorker);
       workers[i].onmessage = jobFinished;
    }
}

function stopJob() {
    // console.log("stopJob", running, "from", (new Error()).stack.split("\n")[2].trim().split(" ")[1]);
    if (running) {
        if (zoomTimeout) {
            clearInterval(zoomTimeout);
            zoomTimeout = null;
        }
       jobNum++;
       running = false;
       document.getElementById("stop").disabled = true;
       if (repaintTimeout)
          clearTimeout(repaintTimeout);
       repaintTimeout = null;
       repaint();
       if (timePerJob < 0 || timePerJob > 150) {
           //console.log("Making new workers");
           newWorkers(workerCount);
       }
    }
}

let maxRowsPerJob = 32;

function startJob() {
    // console.log("startJob",zoomTimeout != null,running, "from", (new Error()).stack.split("\n")[2].trim().split(" ")[1]);
    if (running) {
       stopJob();
    }
    if (! zoomTimeout) {
        graphics.fillStyle = "#BBBBBB";
        graphics.fillRect(0,0,canvas.width,canvas.height);
        OSG.fillStyle = "#BBBBBB";
        OSG.fillRect(0,0,canvas.width,canvas.height);
    }
    imageData = OSG.getImageData(0,0,canvas.width,1);
    hres = Math.round(imageData.width/canvas.width);
    vres = imageData.height;
    dx = xmax.subtract(xmin).divide(new BigDecimal(""+(canvas.width-1)),BigDecimal.ROUND_HALF_EVEN);
    dy = ymax.subtract(ymin).divide(new BigDecimal(""+(canvas.height-1)),BigDecimal.ROUND_HALF_EVEN);
    highPrecision = document.getElementById("highPrecision").checked || dy.compareTo(HP_CUTOFF) < 0;
    jobs = [];
    var yVal = ymax.add(new BigDecimal("0"));
    var rows = canvas.height;
    var columns = canvas.width;
    savedIterationCounts = new Array(rows);
    savedIterationCounts2ndPass = new Array(rows+1);
    if (highPrecision) {
        digits = xmin.scale();
        chunks = Math.floor((digits * log2of10)/16 + 2);
        dxArray = new ArrayType(chunks+1);
        xminArray = new ArrayType(chunks+1);
        convert(xminArray, xmin, chunks+1);
        convert(dxArray,dx,chunks+1);
        for ( var row = 0; row < rows; row++) {
            let ytmp = yVal.subtract(dx.multiply(new BigDecimal(row.toString())));
            var yValArray = new ArrayType(chunks+1);
            convert(yValArray, ytmp, chunks+1);
            jobs[rows - 1- row] = {
                row: row,
                columns: columns,
                xmin: xminArray,
                dx: dxArray,
                yVal: yValArray,
                dy: 0,
                nrows: 1
            };
            //yVal = yVal.subtract(dy);
        }
    }
    else {
        var xmin_d = Number(xmin.toString());
        var yVal_d = Number(yVal.toString());
        var dx_d = Number(dx.toString());
        var dy_d = Number(dy.toString());
        //console.log(dx_d, dy_d, xmin_d, yVal_d);

        let rowsPerJob = Math.min(maxRowsPerJob, Math.floor(rows/workerCount));
        for (let row = 0; row < rows; row += rowsPerJob) {
            jobs.push({
                row: row,
                columns: columns,
                xmin: xmin_d,
                dx: dx_d,
                yVal: yVal_d,   // to reduce error calculate y in worker as yVal_d - (row + 0..nrows)*dy_d
                dy: dy_d,
                nrows: Math.min(rowsPerJob, rows - row)
            });
        }
        jobs.reverse();     // keep original order
    }
    if (interlaced) {
        var sortedJobs = jobs;
        jobs = [];
        for (var i = 0; i < interlaceOrder.length; i++) {
            for (var j = interlaceOrder[i]; j < sortedJobs.length; j += interlaceOrder.length) {
                jobs.push(sortedJobs[j]);
                //if (sortedJobs[j] == null) {  // for debugging
                //    throw "bad logic";
                //}
                //sortedJobs[j] = null;
            }
        }
    }
    startTime = Date.now();
    rowsCompleted = 0;
    jobsCompleted = 0;
    for (var i = 0; i < workerCount; i++) {
        var j = jobs.pop();
        j.workerNum = i;
        workers[i].postMessage(["setup",jobNum, maxIterations,highPrecision,i]);
        workers[i].postMessage([
            "task", j.row, j.columns,
            j.xmin, j.dx, j.yVal, j.dy, j.nrows
        ]);
    }
    running = true;
    document.getElementById("stop").disabled = false;
    var prec = highPrecision? "high precision, " + digits + " digits" : "normal precision";
    document.getElementById("status").innerHTML = "Computing, " + prec + "...";
    if (! zoomTimeout) {
        repaintTimeout = setTimeout(repaint,333);
    }
    timePerJob = -1;
    jobStartTime = new Date().getTime();
    state = COMPUTING_FIRST_PASS;
    currentXML = currentExampletoXML();
}

function jobFinished(msg) {
    var job = msg.data;
    if (job[0] != jobNum)
       return;
    if (jobs.length > 0) {
       var worker = workers[job[3]];
       var j = jobs.pop();
       worker.postMessage([
            "task", j.row, j.columns,
            j.xmin, j.dx, j.yVal, j.dy, j.nrows
        ]);
    }
    var iterationCounts = job[2];
    let nRows = job[4];
    for (let i = 0; i < nRows; i++) {
        let row = job[1] + i;
        if (state == COMPUTING_FIRST_PASS) {
           savedIterationCounts[row] = iterationCounts[i];
           putRow(row);
        }
        else {
            savedIterationCounts2ndPass[row] = iterationCounts[i];
            // all rows need to be present for averaging second pass if workerCount > 1
            //if (row > 0) {
            //   putRow(row-1);
            //}
        }
    }
    jobsCompleted += nRows;
    rowsCompleted += nRows;
    timePerJob = ( (new Date().getTime()) - jobStartTime) / jobsCompleted;
    if (state == COMPUTING_FIRST_PASS) {
        if (jobsCompleted == canvas.height) {
          state = DONE_FIRST_PASS;
          stopJob();
          if (document.getElementById("secondpass").checked) {
             startSecondPass();
          }
       }
    }
    else {
        if (jobsCompleted == canvas.height + 1) {
            // all rows need to be present for averaging second pass if workerCount > 1
            for (let row = 0; row < canvas.height; row++) {
                putRow(row);
            }
            state = IDLE;
            stopJob();
        }
    }
}

function startSecondPass() {
    if (running) {
       stopJob();
    }
    dx = xmax.subtract(xmin).divide(new BigDecimal(""+(canvas.width-1)),BigDecimal.ROUND_HALF_EVEN);
    dy = ymax.subtract(ymin).divide(new BigDecimal(""+(canvas.height-1)),BigDecimal.ROUND_HALF_EVEN);
    var dxHalf = dx.divide(TWO,BigDecimal.ROUND_HALF_EVEN);
    var dyHalf = dy.divide(TWO,BigDecimal.ROUND_HALF_EVEN);
    highPrecision = document.getElementById("highPrecision").checked || dy.compareTo(HP_CUTOFF) < 0;
    jobs = [];
    var yVal = ymax.add(dyHalf);
    var xStart = xmin.subtract(dxHalf);
    var rows = canvas.height + 1;
    var columns = canvas.width + 1;
    if (highPrecision) {
        digits = xmin.scale();
        chunks = Math.floor((digits * log2of10)/16 + 2);
        dxArray = new ArrayType(chunks+1);
        xminArray = new ArrayType(chunks+1);
        convert(xminArray, xStart, chunks+1);
        convert(dxArray,dx,chunks+1);
        for ( var row = 0; row < rows; row++) {
            let ytmp = yVal.subtract(dx.multiply(new BigDecimal(row.toString())));
            var yValArray = new ArrayType(chunks+1);
            convert(yValArray, ytmp, chunks+1);
            jobs[rows - 1- row] = {
                row: row,
                columns: columns,
                xmin: xminArray,
                dx: dxArray,
                yVal: yValArray,
                dy: 0,
                nrows: 1
            };
            //yVal = yVal.subtract(dy);
        }
    }
    else {
        var xmin_d = Number(xStart.toString());
        var yVal_d = Number(yVal.toString());
        var dx_d = Number(dx.toString());
        var dy_d = Number(dy.toString());
        //var ymax_d = Number(ymax.toString()) + dy_d/2;

        let rowsPerJob = Math.min(maxRowsPerJob, Math.floor(rows/workerCount));
        for (let row = 0; row < rows; row += rowsPerJob) {
            jobs.push({
                row: row,
                columns: columns,
                xmin: xmin_d,
                dx: dx_d,
                yVal: yVal_d,   // to reduce error calculate y in worker as yVal_d - (row + 0..nrows)*dy_d
                dy: dy_d,
                nrows: Math.min(rowsPerJob, rows - row)
            });
        }
        //jobs.reverse();     // keep original order (don't need to since now we're waiting for all rows to finish before drawing)
    }
    jobsCompleted = 0;
    for (var i = 0; i < workerCount; i++) {
        var j = jobs.pop();
        j.workerNum = i;
        workers[i].postMessage(["setup",jobNum, maxIterations,highPrecision,i]);
        workers[i].postMessage([
            "task", j.row, j.columns,
            j.xmin, j.dx, j.yVal, j.dy, j.nrows
        ]);
    }
    running = true;
    document.getElementById("stop").disabled = false;
    var prec = highPrecision? "high precision, " + digits + " digits" : "normal precision";
    document.getElementById("status").innerHTML = "Computing 2nd Pass, " + prec + "...";
    repaintTimeout = setTimeout(repaint,500);
    timePerJob = -1;
    jobStartTime = new Date().getTime();
    state = COMPUTING_SECOND_PASS;
}

function putRow(row) {
    var iterationCounts = savedIterationCounts[row];
    var above = savedIterationCounts2ndPass[row];
    var below = savedIterationCounts2ndPass[row+1];
    var average = above && below;
    var secondPassColor;
    var ct;
    if (average) {
       ct = above[0];
       var c1 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
       ct = below[0];
       var c2 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
       secondPassColor = [c1[0]+c2[0],c1[1]+c2[1],c1[2]+c2[2]];
    }
    var columns = canvas.width;
    for (var i = 0; i < columns; i++) {
       ct = iterationCounts[i];
       var color;
       if (ct < 0) {
          color = [0,0,0];
       }
       else {
          var paletteIndex = iterationCounts[i] % paletteLength;
          color = paletteColors[paletteIndex];
       }
       if (average) {
           ct = above[i+1];
           var c1 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
           ct = below[i+1];
           var c2 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
           var secondPassColor2 = [c1[0]+c2[0],c1[1]+c2[1],c1[2]+c2[2]];
           color = [ // had a bug where I modified the color that was still in the palette array!
               ( 4*color[0] + secondPassColor[0] + secondPassColor2[0] ) / 8,
               ( 4*color[1] + secondPassColor[1] + secondPassColor2[1] ) / 8,
               ( 4*color[2] + secondPassColor[2] + secondPassColor2[2] ) / 8
           ];
           secondPassColor = secondPassColor2;
       }
       var p = 4*i*hres;
       for (var j = 0; j < hres; j++) {
           imageData.data[p] = color[0];
           imageData.data[p+1] = color[1];
           imageData.data[p+2] = color[2];
           imageData.data[p+3] = 255;
       }
    }
    for (var i = 0; i < vres; i++) {
        OSG.putImageData(imageData,0,row*vres+i);
    }
}

function setDefaults() {
    var oldXML = currentXML;
    stopJob();
    setLimits(new BigDecimal("-2.2"), new BigDecimal("0.8"), new BigDecimal("-1.2"), new BigDecimal("1.2"), false);
    stretchPalette = false;
    fixedPaletteLength = 250;
    maxIterations = 500;
    paletteOffsetFraction = 0;
    palette = new Palette();
    createPaletteColors();
    document.getElementById("maxIterSelect").value = "500";
    document.getElementById("custommaxiter").style.display = "none";
    document.getElementById("custompallen").style.display = "none";
    document.getElementById("custoffset").style.display = "none";
    document.getElementById("customsize").style.display = "none";
    document.getElementById("paletteLengthSelect").value = "250";
    document.getElementById("paletteOffsetSelect").value = "0";
    document.getElementById("imagesize").value = "800 600";
    if (canvas.width != 800 || canvas.height != 600) {
      canvas.width = 800;
      canvas.height = 600;
      OSC.width = 800;
      OSC.height = 600;
      checkAspect();
    }
    startJob();
    if (undoList) {
        addUndoItem("Restore Defaults", oldXML, currentXML);
    }
}

function remapColors() {
    for (var row = 0; row < canvas.height; row++) {
       if (savedIterationCounts[row]) {
           putRow(row);
       }
    }
    doDraw();
    currentXML = currentExampletoXML();
}

function createPaletteColors() {
    var length = stretchPalette ? maxIterations : fixedPaletteLength;
    paletteLength = length;
    var offset = Math.round(paletteOffsetFraction * paletteLength);
    paletteColors = palette.makeRGBs(paletteLength,offset);
}

function DragBox(x,y) {
    this.x = this.left = x;
    this.y = this.top = y;
    this.width = 0;
    this.height = 0;
}
DragBox.prototype.draw = function() {  // Draw the box on the on-screen canvas
    graphics.strokeStyle = "#FFFFFF";
    graphics.lineWidth = 4;
    graphics.strokeRect(this.left,this.top,this.width,this.height);
    graphics.strokeStyle = "#000000";
    graphics.lineWidth = 2;
    graphics.strokeRect(this.left,this.top,this.width,this.height);
}
DragBox.prototype.setCorner = function(x1,y1) {
    var w = Math.abs(x1 - this.x);
    var h = Math.abs(y1 - this.y);
    if (w < 3 || h < 3) {
        this.width = this.height = 0;
        return;
    }
    var aspect = canvas.width/canvas.height;
    var rectAspect = w / h;
    if (aspect > rectAspect)
        w = Math.round(w*aspect/rectAspect);
    else if (aspect < rectAspect)
        h = Math.round(h*rectAspect/aspect);
    if (this.x < x1) {
        this.left = this.x;
    }
    else {
        this.left = this.x - w;
    }
    if (this.y < y1) {
        this.top = this.y;
    }
    else {
        this.top = this.y - h;
    }
    this.width = w;
    this.height = h;
}
DragBox.prototype.zoom = function(zoomin) {
    if (this.width <= 2 || this.height <= 2)
       return;
    stopJob();
    if (zoomin == false) {
        doZoomOutFromRect(this.left, this.top, this.width, this.height);
    }
    else {
        doZoomInOnRect(this.left, this.top, this.width, this.height, true);
    }
    startJob();
}

var zoomTimeout;
var OSZC;  // Zoom canvas.
var OSZG;  // Graphics context for zoom canvas.
const FPS = 60;
const ZOOMTIME = 250;   // zoom time in ms
const NFRAMES = Math.floor(ZOOMTIME/1000*FPS);
const FRAMEINTERVAL = ZOOMTIME/NFRAMES;

function drawZoom(left, top, width, height) {
    // console.log("drawZoom from", (new Error()).stack.split("\n")[2].trim().split(" ")[1], left, top, width, height, NFRAMES, FRAMEINTERVAL);

    // draw latest OSC
    graphics.drawImage(OSC,0,0);

    // scale image into OSG with gray surround if needed
    OSG.fillStyle = "#BBBBBB";
    OSG.fillRect(0, 0, canvas.width, canvas.height);
    OSG.drawImage(canvas, left, top, width, height, 0, 0, canvas.width, canvas.height);

    // save the un-zoomed image
    if (! OSZC) {
        OSZC = document.createElement("canvas");
        OSZG = OSZC.getContext("2d");
    }
    OSZC.width = canvas.width;
    OSZC.height = canvas.height;
    OSZG.drawImage(canvas, 0, 0);

    let frameCount = 1;
    zoomDrawFrame(left, top, width, height, frameCount);
    frameCount++;
    zoomTimeout = setInterval(function () {
        if (frameCount < NFRAMES) {
            zoomDrawFrame(left, top, width, height, frameCount);
            frameCount++;
        } else {
            clearInterval(zoomTimeout);
            zoomTimeout = null;
            repaint();
        }
    }, FRAMEINTERVAL);
}

function zoomDrawFrame(left, top, width, height, frameCount) {
    const zoomFactor = frameCount/NFRAMES;
    const leftZ = left*zoomFactor;
    const topZ = top*zoomFactor;
    const widthZ = canvas.width - (canvas.width - width)*zoomFactor;
    const heightZ = canvas.height - (canvas.height - height)*zoomFactor;
    graphics.fillStyle = "#BBBBBB";
    graphics.fillRect(0,0,canvas.width,canvas.height);
    graphics.drawImage(OSZC, leftZ, topZ, widthZ, heightZ, 0, 0, canvas.width, canvas.height);
}

function doZoomInOnRect(x,y,width,height,undo) {
    // console.log("doZoomInOnRect", x, y, width, height);
    var rectX = new BigDecimal("" + Math.round(x));  // (Firefox can have fractional parts)
    var rectY = new BigDecimal("" + Math.round(y));
    var rectW = new BigDecimal("" + Math.round(width));
    var rectH = new BigDecimal("" + Math.round(height));
    var ImageWidth = new BigDecimal("" + canvas.width);
    var ImageHeight = new BigDecimal("" + canvas.height);
    var pixelWidth = xmax.subtract(xmin).divide(ImageWidth,BigDecimal.ROUND_HALF_EVEN);
    var pixelHeight = ymax.subtract(ymin).divide(ImageHeight,BigDecimal.ROUND_HALF_EVEN);
    var newXmin,newXmax,newYmin,newYmax;
    newXmin = xmin.add(pixelWidth.multiply(rectX));
    newYmax = ymax.subtract(pixelHeight.multiply(rectY));
    var newWidth = pixelWidth.multiply(rectW);
    var newHeight = pixelHeight.multiply(rectH);
    newXmax = newXmin.add(newWidth);
    newYmin = newYmax.subtract(newHeight);
    setLimits(newXmin, newXmax, newYmin, newYmax, undo);
    drawZoom(x, y, width, height);
}

function doZoomOutFromRect(x,y,width,height) {
    // console.log("doZoomOutFromRect", x, y, width, height);
    var rectX = new BigDecimal("" + Math.round(x));
    var rectY = new BigDecimal("" + Math.round(y));
    var rectW = new BigDecimal("" + Math.round(width));
    var rectH = new BigDecimal("" + Math.round(height));
    var ImageWidth = new BigDecimal("" + canvas.width);
    var ImageHeight = new BigDecimal("" + canvas.height);
    var newPixelWidth = xmax.subtract(xmin).divide(rectW,BigDecimal.ROUND_HALF_EVEN);
    var newPixelHeight = ymax.subtract(ymin).divide(rectH,BigDecimal.ROUND_HALF_EVEN);
    var newXmin,newXmax,newYmin,newYmax;
    newXmin = xmin.subtract(newPixelWidth.multiply(rectX));
    newYmax = ymax.add(newPixelHeight.multiply(rectY));
    var newWidth = newPixelWidth.multiply(ImageWidth);
    var newHeight = newPixelHeight.multiply(ImageHeight);
    newXmax = newXmin.add(newWidth);
    newYmin = newYmax.subtract(newHeight);
    setLimits(newXmin, newXmax, newYmin, newYmax, true);

    let zoomFactor = (canvas.width/width + canvas.height/height)/2;
    drawZoom(-zoomFactor*x, -zoomFactor*y, zoomFactor*canvas.width, zoomFactor*canvas.height);
}

function zoom(x, y, zoomFactor, recenter) {  // (x,y) is center of zoom, in pizels; recenter moves that point to center of image
    // console.log("zoom:", x, y, zoomFactor, recenter);
    stopJob();
    var zf = new BigDecimal("" + zoomFactor);
    var X = new BigDecimal("" + Math.round(x));
    var Y = new BigDecimal("" + Math.round(y));
    var ImageWidth = new BigDecimal("" + canvas.width);
    var ImageHeight = new BigDecimal("" + canvas.height);
    var oldWidth = xmax.subtract(xmin);
    var oldHeight = ymax.subtract(ymin);
    var newWidth = oldWidth.multiply(zf);
    var newHeight = oldHeight.multiply(zf);
    if (newWidth.compareTo(new BigDecimal("100")) > 0) {
        document.getElementById("status").innerHTML =
            "Zooming out that far would reduce the whole Mandelbrot set to a dot.  Ignored.";
        return;
    }
    var pixelWidth = newWidth.divide(ImageWidth,BigDecimal.ROUND_HALF_EVEN);
    var pixelHeight = newHeight.divide(ImageHeight,BigDecimal.ROUND_HALF_EVEN);
    var centerX = xmin.add(X.multiply(oldWidth).divide(ImageWidth,BigDecimal.ROUND_HALF_EVEN));
    var centerY = ymax.subtract(Y.multiply(oldHeight).divide(ImageHeight,BigDecimal.ROUND_HALF_EVEN));
    var newXmin,newXmax,newYmin,newYmax;
    if (recenter) {
        newXmin = centerX.subtract(newWidth.divide(TWO,BigDecimal.ROUND_HALF_EVEN));
        newYmax = centerY.add(newHeight.divide(TWO,BigDecimal.ROUND_HALF_EVEN));
    }
    else {
        newXmin = centerX.subtract(X.multiply(pixelWidth));
        newYmax = centerY.add(Y.multiply(pixelHeight));
    }
    newYmin = newYmax.subtract(newHeight);
    newXmax = newXmin.add(newWidth);
    setLimits(newXmin, newXmax, newYmin, newYmax, true);

    let width = canvas.width*zoomFactor;
    let height = canvas.height*zoomFactor;
    let left, top;
    if (recenter) {
        left = x - width/2;
        top = y - height/2;
    } else {
        left = x*(1 - zoomFactor);
        top = y*(1 - zoomFactor);
    }
    drawZoom(left, top, width, height);
    startJob();
}


function setUpDragging() {  // for image canvas
    var zoomin;
    var startX, startY; // for mouse only
    dragbox = null;  // initially, the mouse is not being dragged.
    canvas.addEventListener("dblclick",doMouseDoubleClick,false);
    new Mouser(canvas, startDrag, continueDrag, endDrag, true);
    function startDrag(x,y,evt) {
        if (evt && evt.button != 0)  // only allow left button to start drag
            return false;
        startX = x;
        startY = y;
        dragbox = null;
        zoomin = ! (evt && evt.shiftKey); 
        return true;
    }
    function continueDrag(x,y) {  
        if (dragbox == null) {
            if ( Math.abs(startX - x) < 3 && Math.abs(startY - y) < 3) {
                return;  // don't show zoombox until mouse/touch has moved a bit.
            }
            dragbox = new DragBox(startX,startY);
        }
        dragbox.setCorner(x,y);
        doDraw();
    }
    function endDrag() {
        if (dragbox != null) {
            doDraw();
            dragbox.zoom(zoomin);
            dragbox = null;
        }
    }
    function doMouseDoubleClick(evt) { 
        if (dragbox || evt.button != 0) {
            return;
        }
        var r = canvas.getBoundingClientRect();
        var x = evt.clientX - r.left;
        var y = evt.clientY - r.top;
        var zoomFactor = evt.shiftKey? 2 : 0.5;
        zoom(x,y,zoomFactor,!evt.altKey && !evt.ctrlKey);
    }
 }

function Mouser(canvas, startDrag, continueDrag, endDrag, mouseMoveOnCanvasOnly) {
      // functions startDrag, continueDrag take canvas coords (x,y); for a mouse event event object is also passed.
      // function endDrag takes no parameter for touched, mouse event for mouse actions.
      // function startDrag returns a boolean, true if the down action should start a drag.
    var dragging = false;
    canvas.addEventListener("mousedown",doMouseDown,false);
    canvas.addEventListener("touchstart",doTouchStart,false);
    function doMouseDown(evt) { 
        if (dragging) {
            return;
        }
        var r = canvas.getBoundingClientRect();
        var x = evt.clientX - r.left;
        var y = evt.clientY - r.top;
        if (startDrag(x,y,evt)) {
            dragging = true;
            (mouseMoveOnCanvasOnly? canvas : document).addEventListener("mousemove",doMouseMove,false);
            document.addEventListener("mouseup",doMouseUp,false);
        }
    }
    function doMouseMove(evt) {
        if (!dragging) {
            return;
        }
        var r = canvas.getBoundingClientRect();
        var x = evt.clientX - r.left;
        var y = evt.clientY - r.top;
        continueDrag(x,y,evt); 
    }
    function doMouseUp(evt) {
        if (dragging) {  
            dragging = false;
            (mouseMoveOnCanvasOnly? canvas : document).removeEventListener("mousemove",doMouseMove,false);
            document.removeEventListener("mouseup",doMouseUp,false);
            endDrag(evt);
        }
    }
    function doTouchStart(evt){
        if (evt.touches.length != 1) {
           doTouchCancel();
           return;
        }
        evt.preventDefault();
        if (dragging) {
            return;
        }
        var r = canvas.getBoundingClientRect();
        var x = evt.touches[0].clientX - r.left;
        var y = evt.touches[0].clientY - r.top;
        if (startDrag(x,y)) {
            dragging = true;
            canvas.addEventListener("touchmove", doTouchMove);
            canvas.addEventListener("touchend", doTouchEnd);
            canvas.addEventListener("touchcancel", doTouchCancel);
        }
    }
    function doTouchMove(evt){
        if (!dragging)
           return;
        evt.preventDefault();
        if (evt.touches.length != 1) {
           doTouchCancel();
           return;
        }
        var r = canvas.getBoundingClientRect();
        var x = evt.touches[0].clientX - r.left;
        var y = evt.touches[0].clientY - r.top;
        continueDrag(x,y);
    }
    function doTouchEnd(evt) {
        doTouchCancel();
    }
    function doTouchCancel() {
        if (dragging) {
           canvas.removeEventListener("touchmove", doTouchMove);
           canvas.removeEventListener("touchend", doTouchEnd);
           canvas.removeEventListener("touchcancel", doTouchCancel);
           endDrag();
           dragging = false;
        }
    }
}

function changeWorkerCount() {
    var ct = Number(document.getElementById("threadCountSelect").value);
    if (workers && ct == workers.length)
       return;
    var restart  = running;
    if (running) {
        stopJob();
    }
    workerCount = ct;
    newWorkers(ct);
    if (restart) {
        startJob();
    }
    try {
      localStorage.setItem("mandelbrotWorkerCount" + (document.getElementById("local").checked ? "local" : "remote"), "" + ct);
    //   console.log("workers set " + (document.getElementById("local").checked ? "local" : "remote") + " " + ct);
    }
    catch(e) {
    }
}

async function pageExists(url) {
    try {
        const response = await fetch(url);
        // console.log(response);
        return response.ok;
    } catch (error) {
        return false;
    }
}

function checkRemoteCanComputeMB() {
    pageExists("/remoteCanComputeMB").then(result => {
        if (! result) {
            console.log("remote web server does not support Mandelbrot calculations");
            document.getElementById("local").checked = true;
            changeLocalOrRemote();
        }
    });
}

function changeLocalOrRemote() {
    let newWorkerCount = workerCount;
    let localOrRemote = document.getElementById("local").checked ? "local" : "remote";
    try {
        localStorage.setItem("mandelbrotLocalOrRemote", localOrRemote);
        let ct = Number(localStorage.getItem("mandelbrotWorkerCount" + localOrRemote));
        // console.log("workers get " + (document.getElementById("local").checked ? "local" : "remote") + " " + ct);
        if (! isNaN(ct) && ct > 0) {
            newWorkerCount = ct;
        }
    }
    catch(e) {
    }
    if (running) {
        stopJob();
        workerCount = newWorkerCount;
        newWorkers(workerCount);
        startJob();
    } else {
        workerCount = newWorkerCount;
        newWorkers(workerCount);
    }
    document.getElementById("threadCountSelect").value = "" + newWorkerCount;

    if (localOrRemote == "remote") {
        checkRemoteCanComputeMB();
    }
}

function changeMaxIterations() {
    var val = document.getElementById("maxIterSelect").value;
    var iter;
    if (val == "Custom") {
        document.getElementById("maxiterinput").value = "" + maxIterations;
        document.getElementById("custommaxiter").style.display = "inline";
    }
    else {
        document.getElementById("custommaxiter").style.display = "none";
        iter = Number(val);
        setMaxIterations(iter);
    }
}
function setMaxIterations(iter) {
    if (iter == maxIterations)
       return;
    var oldval = maxIterations;
    stopJob();
    maxIterations = iter;
    createPaletteColors();
    startJob();
    addUndoItem("Change MaxIterations", oldval, maxIterations);
}
function doCustomMaxIterations() {
    var iter = Math.round(Number(document.getElementById("maxiterinput").value.trim()));
    if (isNaN(iter) || iter < 10) {
        document.getElementById("status").innerHTML = "Illegal value for max iterations.  Must be an integer greater than 9.";
        return;
    }
    setMaxIterations(iter);
}


function changePaletteLength() {
    var val = document.getElementById("paletteLengthSelect").value;
    var len;
    if (val == "Custom") {
        var length = stretchPalette ? maxIterations : fixedPaletteLength;
        stretchPalette = false;
        fixedPaletteLength = length;
        document.getElementById("palleninput").value = "" + length;
        document.getElementById("custompallen").style.display = "inline";
    }
    else if (val == "Match") {
        var oldval = [stretchPalette, stretchPalette ? maxIterations : fixedPaletteLength];
        stretchPalette = true;
        if (paletteLength != maxIterations) {
            stopJob();
            createPaletteColors();
            startJob();
            addUndoItem("Change PaletteLength", oldval, [stretchPalette,paletteLength]);
        }
        document.getElementById("custompallen").style.display = "none";
    }
    else {
       len = parseInt(val);
       if (len != paletteLength) {
          addUndoItem("Change PaletteLength", [stretchPalette, paletteLength], [false,len]);
       }
       setFixedPaletteLength(len);
       document.getElementById("custompallen").style.display = "none";
    }
}
function setFixedPaletteLength(len) {
    fixedPaletteLength = len;
    stretchPalette = false;
    if (fixedPaletteLength != paletteLength) {
       createPaletteColors();
       remapColors();
    }
}
function doCustomPaletteLength() {
    var val = Math.round(Number(document.getElementById("palleninput").value.trim()));
    if (val == fixedPaletteLength)
        return;
    if (isNaN(val) || val < 1) {
        document.getElementById("status").innerHTML = "Illegal value for number of colors.  Must be an integer greater than zero.";
        return;
    }
    var oldval = [false,fixedPaletteLength];
    var newval = [false,val];
    addUndoItem("Change PaletteLength", oldval, newval);
    setFixedPaletteLength(val);
}

function changePaletteOffset() {
    var val = document.getElementById("paletteOffsetSelect").value;
    if (val == "Custom") {
        var current = 100 * paletteOffsetFraction;
        document.getElementById("offsetinput").value = (current == Math.round(current))? current : current.toPrecision(3);
        document.getElementById("custoffset").style.display = "inline";
    }
    else {
        var fractionOffset = Number(val);
        setPaletteOffset(fractionOffset);
        document.getElementById("custoffset").style.display = "none";
    }
}
function doApplyCustomPaletteOffset() {
    var val = Number(document.getElementById("offsetinput").value.trim());
    if (isNaN(val) || val < 0 || val > 100) {
        document.getElementById("status").innerHTML =
             "Illegal value for percentage offset.  Must be a number in the range 0 to 100.";
    }
    else {
       setPaletteOffset(val/100);
    }
}
function setPaletteOffset(fractionOffset) {
    document.getElementById("status").innerHTML = "Idle";
    if (fractionOffset == paletteOffsetFraction) {
        return;
    }
    addUndoItem("Change PaletteOffset", paletteOffsetFraction, fractionOffset);
    paletteOffsetFraction = fractionOffset;
    createPaletteColors();
    remapColors();
}

function changeInterlaced() {
   var checked = document.getElementById("interlaced").checked;
   if (checked == interlaced) {
       return;
   }
   interlaced = checked;
   if (running) {
       stopJob();
       startJob();
   }
}

function changeImageSize() {
    var val = document.getElementById("imagesize").value;
    if (val == "Custom") {
        document.getElementById("customwidth").value = "" + canvas.width;
        document.getElementById("customheight").value = "" + canvas.height;
        document.getElementById("customsize").style.display = "inline";
    }
    else {
        document.getElementById("customsize").style.display = "none";
        var sizes = val.split(" ");
        var width = Number(sizes[0]);
        var height = Number(sizes[1]);
        setImageSize(width,height,true);
    }
}
function setImageSize(w,h) {
    if (w == canvas.width && h == canvas.height) {
        return;
    }
    var oldval = [canvas.width,canvas.height];
    stopJob();
    canvas.width = w;
    canvas.height = h;
    OSC.width = w;
    OSC.height = h;
    checkAspect();
    startJob();
    addUndoItem("Change Image Size", oldval, [canvas.width,canvas.height]);
}
function doCustomSize() {
    var width = Math.round(Number(document.getElementById("customwidth").value.trim()));
    var height = Math.round(Number(document.getElementById("customheight").value.trim()));
    if (isNaN(width) || width < 64 || width > 7680) {
        document.getElementById("status").innerHTML = "Illegal value for image width.  Must be an integer in the range 64 to 7680.";
        return;
    }
    if (isNaN(height) || height < 64 || height > 7680) {
        document.getElementById("status").innerHTML = "Illegal value for image height.  Must be an integer in the range 64 to 7680.";
        return;
    }
    setImageSize(width,height,true);
}

function doApplyStandardPalette() {
    var name = document.getElementById("standardPaletteSelect").value;
    var oldval = palette;
    palette = Palette.createStandardPalette(name);
    createPaletteColors();
    remapColors();
    addUndoItem("Change Palette", oldval.copy(), palette.copy());
}

function changeSecondPass() {
    var checked = document.getElementById("secondpass").checked;
    if (checked && !running && state == DONE_FIRST_PASS) {
        startSecondPass();
    }
}

function changeHighPrecision() {
    var checked = document.getElementById("highPrecision").checked;
    if (running && checked != highPrecision) {
        stopJob();
        startJob();
    }
}

function doZoomIn() {
    zoom(canvas.width/2, canvas.height/2, document.getElementById("zoomInAmount").value, false);
}

function doZoomOut() {
    zoom(canvas.width/2, canvas.height/2, document.getElementById("zoomOutAmount").value, false);
}

//---------------------- Undo/Redo ---------------------------------------

function doUndo() {
    if (undoCount > 0) {
        var item = undoList[undoCount-1];
        undoCount--;
        document.getElementById("undo").disabled = (undoCount == 0);
        document.getElementById("undo").innerHTML = undoCount? ("Undo " + undoList[undoCount-1].name) : "Undo";
        document.getElementById("redo").disabled = false;
        document.getElementById("redo").innerHTML = "Redo " + item.name;
        applyUndoItem(item.name, item.oldValue);
    }
}

function doRedo() {
    if (undoCount < undoList.length) {
        var item = undoList[undoCount];
        undoCount++;
        document.getElementById("undo").disabled = false;
        document.getElementById("undo").innerHTML = "Undo " + item.name;
        document.getElementById("redo").disabled = (undoCount == undoList.length);
        document.getElementById("redo").innerHTML = (undoCount < undoList.length)? ("Redo " + undoList[undoCount].name) : "Redo";
        applyUndoItem(item.name, item.newValue);
    }
}

function addUndoItem(name, oldValue, newValue) {
    if (applyUndoInProgress) {
        return;
    }
    undoList.length = undoCount;
    undoList.push( { name: name, oldValue: oldValue, newValue: newValue } );
    if (undoList.length > 100) {
        undoList.shift();
    }
    undoCount = undoList.length;
    document.getElementById("undo").disabled = false;
    document.getElementById("undo").innerHTML = "Undo " + name;
    document.getElementById("redo").disabled = true;
    document.getElementById("redo").innerHTML = "Redo";
}

function applyUndoItem(name, value) {
    applyUndoInProgress = true;
    switch (name) {
      case "Restore Defaults":
      case "Import Example":
         installExampleFromXML(value,false,true);
         break;
      case "Change PaletteOffset":
         setPaletteOffset(value);
         createPaletteColors();
         remapColors();
         break;
      case "Change Limits":
         stopJob();
         setLimits(value[0],value[1],value[2],value[3],false);
         startJob();
         break;
      case "Change Image Size":
         setImageSize(value[0],value[1]);
         var val = value[0] + " " + value[1];
         if (["640 480", "800 600", "1024 768", "1600 1200", "1920 1080", "1920 1200", "2560 1440", "2880 1800", "3840 1080", "3840 2160", "5120 1440", "7680 4320"].indexOf(val) < 0) {
             document.getElementById("imagesize").value = "Custom";
             document.getElementById("customsize").style.display = "inline";
             document.getElementById("customwidth").value = "" + value[0];
             document.getElementById("customheight").value = "" + value[1];
         }
         else {
             document.getElementById("imagesize").value = val;
             document.getElementById("customsize").style.display = "none";
         }
         break;
      case "Change PaletteLength":
         setPaletteLength(value[0],value[1]);
         createPaletteColors();
         remapColors();
         break;
      case "Change MaxIterations":
         setMaxIterations(value);
         if ([25,50,100,250,500,1000,2500,5000,10000,25000,50000].indexOf(value) < 0) {
             document.getElementById("custommaxiter").style.display = "inline";
             document.getElementById("maxIterSelect").value = "Custom";
             document.getElementById("maxiterinput").value = "" + value;
         }
         else {
             document.getElementById("custommaxiter").style.display = "none";
             document.getElementById("maxIterSelect").value = "" + value;
         }
         break;
      case "Change Palette":
         palette = value.copy();
         createPaletteColors();
         remapColors();
         break;
      case "Edit Palette":
        palette = value[0].copy();
        setPaletteLength(value[1],value[2]);
        setPaletteOffset(value[3]);
        createPaletteColors();
        remapColors();
        break;
    }
    applyUndoInProgress = false;
    function setPaletteLength(stretch,length) {
         if (stretch) {
            stretchPalette = true;
            document.getElementById("paletteLengthSelect").value = "Match";
            document.getElementById("custompallen").style.display = "none";
         }
         else  {
             stretchPalette = false;
             fixedPaletteLength = length;
             if ([50,100,250,500,1000,2500,5000].indexOf(length) < 0) {
                document.getElementById("custompallen").style.display = "inline";
                document.getElementById("paletteLengthSelect").value = "Custom";
                document.getElementById("palleninput").value = "" + length;
             }
             else {
                document.getElementById("custompallen").style.display = "none";
                document.getElementById("paletteLengthSelect").value = "" + length;
             }
         }
    }
    function setPaletteOffset(fraction) {
         paletteOffsetFraction = fraction;
         if ([0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9].indexOf(fraction) < 0) {
              document.getElementById("paletteOffsetSelect").value = "Custom";
              document.getElementById("custoffset").style.display = "inline";
              fraction *= 100;
              document.getElementById("offsetinput").value = (fraction == Math.round(fraction))? fraction : fraction.toPrecision(3);
         }
         else {
              document.getElementById("paletteOffsetSelect").value = "" + fraction;
              document.getElementById("custoffset").style.display = "none";
         }
    }
}

//--------------------- Palette ------------------------------------------
function Palette(colorType,divisionPoints,colors) {
   this.colorType = colorType || "HSB";
   this.divisionPoints = divisionPoints || [0,1];
   this.divisionColors = colors || (this.colorType == "HSB" ? [ [0,1,1], [1,1,1] ] : [ [1,1,1], [0,0,0] ]);
}
Palette.prototype.getColor = function(position) {  // 0.0 <= position <= 1.0
    var pt = 1;
    while (position > this.divisionPoints[pt])
        pt++;
    var ratio = (position - this.divisionPoints[pt-1]) /
                   (this.divisionPoints[pt] - this.divisionPoints[pt-1]);
    var c1 = this.divisionColors[pt-1];
    var c2 = this.divisionColors[pt];
    var a = c1[0] + ratio*(c2[0] - c1[0]);
    var b = c1[1] + ratio*(c2[1] - c1[1]);
    var c = c1[2] + ratio*(c2[2] - c1[2]);
    return this.toRGB(a,b,c);
};
Palette.prototype.toRGB = function(a,b,c) {  // 3 non-clamped color components.
    a = (this.colorType == "HSB")? (a - Math.floor(a)) : clamp(a);
    b = clamp(b);
    c = clamp(c);
    var color;
    if (this.colorType == "HSB")
        color = rgbFromHSV(a, b, c);
    else
        color = [a,b,c];
    color[0] = Math.round(color[0]*255);
    color[1] = Math.round(color[1]*255);
    color[2] = Math.round(color[2]*255);
    return color;
	function clamp(x) {
		x = 2*(x/2 - Math.floor(x/2));
		if (x > 1)
			x = 2 - x;
		return x;
	}
    function rgbFromHSV(h,s,v) {  // all components in range 0 to 1
        h *= 360;
        var r,g,b;
        var c,x;
        c = v*s;
        x = (h < 120)? h/60 : (h < 240)? (h-120)/60 : (h-240)/60;
        x = c * (1-Math.abs(x-1));
        x += (v-c);
        switch (Math.floor(h/60)) {
            case 0: r = v; g = x; b = v-c; break;
            case 1: r = x; g = v; b = v-c; break;
            case 2: r = v-c; g = v; b = x; break;
            case 3: r = v-c; g = x; b = v; break;
            case 4: r = x; g = v-c; b = v; break;
            case 5: r = v; g = v-c; b = x; break;
        }
        return [r,g,b];
    }
};
Palette.prototype.makeRGBs = function(paletteLength, offset) {
    var rgb = new Array(paletteLength);
    rgb[offset % paletteLength] =
             this.toRGB(this.divisionColors[0][0],this.divisionColors[0][1],this.divisionColors[0][2]);
    var dx = 1.0 / (paletteLength-1);
    for (var i = 1; i < paletteLength-1; i++) {
        rgb[(offset+i) % paletteLength] = this.getColor(i*dx);
    }
    var last = this.divisionColors.length - 1;
    rgb[(offset+paletteLength-1) % paletteLength] =
              this.toRGB(this.divisionColors[last][0],this.divisionColors[last][1],this.divisionColors[last][2]);
    return rgb;
};
Palette.prototype.makeCanvasColors = function(paletteLength, offset) {
    var rgb = this.makeRGBs(paletteLength,offset);
    var colors = new Array(rgb.length);
    for (var i = 0; i < rgb.length; i++)
        colors[i] = "rgb(" + rgb[i][0] + "," + rgb[i][1] + "," + rgb[i][2] + ")";
    return colors;
};
Palette.prototype.toXMLString = function() {
   var xml = "<palette colorType='" + this.colorType + "'>\n";
   for (var i = 0; i < this.divisionPoints.length; i++) {
       xml += "   <divisionPoint position='" + this.divisionPoints[i] + "' color='" +
            this.divisionColors[i][0] + ";" + this.divisionColors[i][1] + ";" +this.divisionColors[i][2] +
            "'/>\n";
   }
   xml += "</palette>\n";
   return xml;
};
Palette.prototype.copy = function() {
    var divColors = [];
    for (var i = 0; i < this.divisionColors.length; i++) {
        divColors.push(this.divisionColors[i].slice(0));
    }
    return new Palette(this.colorType,this.divisionPoints.slice(0),divColors);
};
Palette.fromXML = function( paletteNode ) {  // can throw an exception
    try {
       var children = paletteNode.childNodes;
       var type = paletteNode.getAttribute("colorType") || "RBG";
       if (type != "HSB" && type != "RGB") {
           throw "Bad colorType.";
       }
       var points = [];
       var colors = [];
       for (var i = 0; i < children.length; i++) {
          var child = children.item(i);
          if (child.nodeType == 1 && child.tagName == "divisionPoint") { // element node
              var pt = child.getAttribute("position");
              var rgb = child.getAttribute("color");
              if (pt === null || rgb === null) {
                  throw "Missing data for divisionPoint";
              }
              pt = Number(pt);
              rgb = rgb.split(";");
              rgb = [Number(rgb[0]),Number(rgb[1]),Number(rgb[2])];
              if (isNaN(pt) || pt < 0 || pt > 1) {
                   throw "Bad data for divisionPoint";
              }
              for (var j = 0; j < 3; j++) {
                   if (isNaN(rgb[j]) || rgb[j] < 0 ){
                      throw "Bad data for divisionPoint color";
                   }
                   else if (rgb[j] < 0) {
                      throw "Color component number " + (j+1) + " can't be less than zero.";
                   }
                   else if (rgb[j] > 1 && (j > 0 || type == "RGB")) {
                      throw "Color component number " + (j+1) + " can't be greater than one.";
                   }
              }
              if (i > 0 && pt <= points[points.length-1]) {
                  throw "Division points out of order";
              }
              points.push(pt);
              colors.push(rgb);
          }
       }
       if (points.length < 2 || points[0] != 0 || points[points.length-1] != 1) {
           throw "Illegal divisionPoint data";
       }
       return new Palette(type, points, colors);
    }
    catch (e) {
        throw "Illegal palette definition: " + e;
    }
};
Palette.createStandardPalette = function(name) {
    var palette;
    switch (name) {
        case "Grayscale":
           palette = new Palette("RGB");
           break;
        case "CyclicGrayscale":
           palette = new Palette("RGB",[0,0.5,1],[[0,0,0],[1,1,1],[0,0,0]]);
           break;
        case "Red/Cyan":
           palette = new Palette("RGB",[0,0.5,1],[[1,0,0],[0,1,1],[1,0,0]]);
           break;
        case "Blue/Gold":
           palette = new Palette("RGB",[0,0.5,1],[[0.1,0.1,1],[1,0.6,0],[0.3,0.3,1]]);
           break;
        case "EarthAndSky":
           palette = new Palette("RGB",[0,0.15,0.33,0.67,0.85,1],
                     [[1,1,1],[1,0.8,0],[0.53,0.12,0.075],[0,0,0.6],[0,0.4,1],[1,1,1]]);
           break;
        case "HotAndCold":
           palette = new Palette("RGB",[0,0.16,0.5,0.84,1],
                     [[1,1,1],[0,0.4,1],[0.2,0.2,0.2],[1,0,0.8],[1,1,1]]);
           break;
        case "Fire":
           palette = new Palette("RGB",[0,0.17,0.83,1],
                     [[0,0,0],[1,0,0],[1,1,0],[1,1,1]]);
           break;
        case "Cyclic Fire":
           palette = new Palette("RGB",[0,0.2,0.4,0.5,0.6,0.8,1],
                     [[0,0,0],[1,0,0],[1,1,0],[1,1,1],[1,1,0],[1,0,0],[0,0,0]]);
           break;
        case "TreeColors":
           palette = new Palette("HSB",[0,0.33,0.66,1],
                     [[0.1266,0.5955,0.2993],[0.0896,0.3566,0.6575],[0.6195,0.8215,0.4039],[0.1266,0.5955,0.2993]]);
           break;
        case "Seashore":
           palette = new Palette("RGB",[0,0.1667,0.3333,0.5,0.6667,0.8333,1],
                     [[0.7909,0.9961,0.7630],[0.8974,0.8953,0.6565],[0.9465,0.3161,0.1267],[0.5184,0.1109,0.0917],
                              [0.0198,0.4563,0.6839],[0.5385,0.8259,0.8177],[0.7909,0.9961,0.7630]]);
           break;
        case "Pastels":
           palette = new Palette("RGB",[0,0.180781,0.418566,0.627035,0.858306,1],
                     [ [ 0.80585,0.81648,0.82180 ], [ 0.43882,0.52393,1 ], [ 1,0.35904,0.58244 ],
                       [ 1,1,0.52127 ], [ 0.54787,0.93351,0.56914 ], [ 0.80585,0.81648,0.82180 ] ]);
           break;
        case "Dark":
           palette = new Palette("RGB",['0','0.18241042','0.38599348','0.57166123','0.78338762','1'],
                         [  [0.65957446,0,0],[0,0.30585106,0.58776595],[0.81648936,0.41489361,0.07180851],
                                [0,0.48670212,0.16489361],[0.29787234,0.13829787,0.75],[0.65957446,0,0] ]);
//           palette = new Palette("RGB",[0,0.18241,0.38599,0.57166,0.78338,1],
//                       [ [0.65957,0,0],[0,0.40159,0.74734],[0.87234,0.49202,0.07180],
//                           [0,0.48670,0.16489],[0.29787,0.13829,0.75], [0.65957,0,0] ]);
           break;
        case "Random":
           var c = [Math.random(),Math.random(),Math.random()];
           palette = new Palette("RGB",[],[]);
           palette.divisionPoints[0] = 0;
           palette.divisionColors[0] = c;
           for (var i = 1; i <= 5; i++) {
               palette.divisionPoints[i] = i/6;
               palette.divisionColors[i] = [Math.random(),Math.random(),Math.random()];
           }
           palette.divisionPoints[6] = 1;
           palette.divisionColors[6] = c;
           break;
        default: // "Spectrum"
           palette = new Palette();
    }
    return palette;
};

//----- Palette Editor ---------------------------------------------------------------

function showPaletteEditor() {
    if (!colorEditCanvas) {  // showing for the first time, do initialization
        document.getElementById("applyPaletteEdit").onclick = applyAndClose;
        document.getElementById("revertPaletteEdit").onclick = revert;
        document.getElementById("dismissPaletteEdit").onclick = dismiss;
        document.getElementById("addcolorstop").onclick = function() { colorEditCanvas.addColorStop(); };
        document.getElementById("deletecolorstop").onclick = function() { colorEditCanvas.deleteColorStop(); };
        document.getElementById("lockcolors").onchange = setLeftRightColorsLocked;
        document.getElementById("paletteEditStandardInstall").onclick = installStandard;
        document.getElementById("paletteEditStandardSelect").value = "EarthAndSky";
        document.addEventListener("keydown", doKey, false);
        updateDuringDrag = document.getElementById("updateWhileDraggingCheck").checked;
        document.getElementById("updateWhileDraggingCheck").oninput = function() { 
           updateDuringDrag =document.getElementById("updateWhileDraggingCheck").checked;
        };
        histogramPalette = document.getElementById("histogrampalette");
        colorEditCanvas = new ColorEditCanvas();
        colorSliders = [ 
           new SliderAndInput(document.getElementById("colorslider0"), document.getElementById("colorinput0"), 0, 1),
           new SliderAndInput(document.getElementById("colorslider1"), document.getElementById("colorinput1"), 0, 1),
           new SliderAndInput(document.getElementById("colorslider2"), document.getElementById("colorinput2"), 0, 1)
        ];
        colorSliders[0].onchange = function(v) { newColorSliderValue(0,v); };
        colorSliders[1].onchange = function(v) { newColorSliderValue(1,v); };
        colorSliders[2].onchange = function(v) { newColorSliderValue(2,v); };
        paletteLengthSlider = new SliderAndInput(document.getElementById("lengthslider"), document.getElementById("editorlengthinput"), 1, maxIterations, paletteLength, true, true);
        paletteOffsetSlider = new SliderAndInput(document.getElementById("offsetslider"), document.getElementById("editoroffsetinput"), 0, 100, paletteOffsetFraction*100);
        paletteLengthSlider.onchange = newPaletteMappingInEditor;
        paletteOffsetSlider.onchange = newPaletteMappingInEditor;
    }
    paletteEditInProgress = true;
    document.getElementById("paletteEditor").style.display="block";
    document.getElementById("xmlimportbg").style.display = "block";
    copyOfCurrentPalette = palette.copy();
    histogram = new Histogram();
    palettePreview = new PalettePreview();
    installPaletteInEditor(palette);
    paletteLengthSlider.reset(1,maxIterations,paletteLength);
    paletteOffsetSlider.setValue(paletteOffsetFraction*100);
    document.getElementById("applyPaletteEdit").disabled = true;
    document.getElementById("revertPaletteEdit").disabled = true;
    function applyAndClose() {
        var newval = [paletteInEditor, false, paletteLengthInEditor, paletteOffsetFractionInEditor];
        addUndoItem("Edit Palette", 
                       [copyOfCurrentPalette, stretchPalette, fixedPaletteLength, paletteOffsetFraction], 
                       newval);
        applyUndoItem("Edit Palette", newval);
        dismiss();
    }
    function dismiss() {
        document.getElementById("xmlimportbg").style.display = "none";
        document.getElementById("paletteEditor").style.display = "none";
        document.removeEventListener("keydown", doKey, false);
        paletteEditInProgress = false;
        histogram = null;
        palettePreview = null;
        paletteInEditor = null;
        colorsInEditor = null;
    }
    function revert() { 
        installPaletteInEditor( copyOfCurrentPalette );
        palettePreview.redraw();
        document.getElementById("applyPaletteEdit").disabled = true;
        document.getElementById("revertPaletteEdit").disabled = true;
    }
    function installStandard() {
        var name = document.getElementById("paletteEditStandardSelect").value;
        var p = Palette.createStandardPalette(name);
        installPaletteInEditor( p, paletteLengthInEditor, paletteOffsetFractionInEditor );
        document.getElementById("applyPaletteEdit").disabled = false;
        document.getElementById("revertPaletteEdit").disabled = false;
        palettePreview.redraw();
    }
    function doKey(evt) {
        var code = evt.keyCode;
        if (code == 27) {
            dismiss();
        }
    }
}

var copyOfCurrentPalette;
var paletteInEditor;
var paletteLengthInEditor;
var paletteOffsetFractionInEditor;
var histogram;
var histogramPalette;
var palettePreview;
var colorEditCanvas = null;
var leftRightColorsLocked;
var saveRightColorWhileLocked;
var colorsInEditor;
var colorSliders;
var paletteLengthSlider;
var paletteOffsetSlider;
var updateDuringDrag;

function installPaletteInEditor(palette,length,offsetFraction) {
    paletteInEditor = palette.copy();
    var leftCol = paletteInEditor.divisionColors[0];
    var rightCol = paletteInEditor.divisionColors[paletteInEditor.divisionColors.length-1];
    var locked = leftCol[1] == rightCol[1] && leftCol[2] == rightCol[2] &&
           (leftCol[0] == rightCol[0] || (paletteInEditor.colorType == "HSB" &&
                leftCol[0] - Math.floor(leftCol[0]) == rightCol[0] - Math.floor(rightCol[0])));
    colorEditCanvas.setLocked(locked,true);
    document.getElementById("lockcolors").checked = locked;
    paletteLengthInEditor = (typeof length != "undefined")? length : paletteLength;
    paletteLengthSlider.setValue(paletteLengthInEditor);
    paletteOffsetFractionInEditor = (typeof offsetFraction != "undefined")? offsetFraction : paletteOffsetFraction;
    paletteOffsetSlider.setValue(paletteOffsetFractionInEditor*100);
    colorEditCanvas.colorsChanged();
    colorEditCanvas.select(0);
    newColorsInEditor();
    if (!updateDuringDrag)
        palettePreview.redraw();
    if (palette.colorType == "RGB") {
        document.getElementById("colorlabel0").innerHTML = "Red";
        document.getElementById("colorlabel1").innerHTML = "Green";
        document.getElementById("colorlabel2").innerHTML = "Blue";
    }
    else {
        document.getElementById("colorlabel0").innerHTML = "Hue";
        document.getElementById("colorlabel1").innerHTML = "Saturation";
        document.getElementById("colorlabel2").innerHTML = "Brightness";
    }
    if (palette.colorType == "HSB")
        colorSliders[0].setAllowOutOfRange( true, true  );
    else
        colorSliders[0].setAllowOutOfRange( false, false);
    if (palette.colorType == "HSB") { 
       var n = Math.floor(palette.divisionColors[0][0]);
       colorSliders[0].reset(n,n+1,palette.divisionColors[0][0]);
       colorSliders[0].canvas.title = "Drag the slider to set the hue of the selected color stop to a value in the range " +
                                       n + " to " + (n+1) + ". Values outside this range can be set in the textbox.";
    }
    else {
       colorSliders[0].reset(0,1,palette.divisionColors[0][0]);
       colorSliders[0].canvas.title = "Drag the slider to set the red component of the selected color stop to a value in the range 0.0 to 1.0.";
    }
    colorSliders[1].setValue(palette.divisionColors[0][1]);
    colorSliders[2].setValue(palette.divisionColors[0][2]);
}

function newColorsInEditor() {
    var offset = Math.round(paletteLengthInEditor * paletteOffsetFractionInEditor);
    colorsInEditor = paletteInEditor.makeCanvasColors(paletteLengthInEditor,offset);
    colorEditCanvas.draw();
    if (updateDuringDrag)
        palettePreview.redraw();
    redrawHistogramPalette();
    document.getElementById("applyPaletteEdit").disabled = false;
    document.getElementById("revertPaletteEdit").disabled = false;
}

function newPaletteMappingInEditor() {
    paletteLengthInEditor = paletteLengthSlider.value;
    paletteOffsetFractionInEditor = paletteOffsetSlider.value / 100;
    var offset = Math.round(paletteLengthInEditor * paletteOffsetFractionInEditor);
    colorsInEditor = paletteInEditor.makeCanvasColors(paletteLengthInEditor,offset);
    if (updateDuringDrag)
        palettePreview.redraw();
    redrawHistogramPalette();
    document.getElementById("applyPaletteEdit").disabled = false;
    document.getElementById("revertPaletteEdit").disabled = false;
}

function newColorSliderValue(componentIndex,value) {
   var colorNum = colorEditCanvas.getSelected();
   var color = paletteInEditor.divisionColors[colorNum];
   color[componentIndex] = value;
   var color2 = null;
   if (leftRightColorsLocked) {
       if (colorNum == 0) {
           color2 = paletteInEditor.divisionColors[paletteInEditor.divisionColors.length-1];
       }
       else if (colorNum == paletteInEditor.divisionColors.length-1) {
           color2 = paletteInEditor.divisionColors[0];
       }
   }
   if (color2 != null) {
       if (componentIndex == 0 && paletteInEditor.colorType == "HSB") {
           var n = Math.floor(color2[0]);
           color2[0] = n + (value - Math.floor(value));
       }
       else {
           color2[componentIndex] = value;
       }
       saveRightColorWhileLocked = null;
   }
   colorEditCanvas.colorsChanged();
   newColorsInEditor();
}

function redrawHistogramPalette() {
     var hg = histogramPalette.getContext('2d');
     var onecopy = paletteLengthInEditor/maxIterations * (histogramPalette.width-2);
     for (var i = 1; i < histogramPalette.width-1; i++) {
         var fraction = ((i-1) % onecopy) / onecopy;
         var index = Math.max(0, Math.min(colorsInEditor.length,Math.round(fraction * colorsInEditor.length)));
         hg.fillStyle = colorsInEditor[index];
         hg.fillRect(i,0,1,histogramPalette.height);
     }
     hg.strokeStyle = "black";
     hg.strokeRect(0.5,0.5,histogramPalette.width-1,histogramPalette.height-1);
}

function setLeftRightColorsLocked() {
    var locked = document.getElementById("lockcolors").checked;
    colorEditCanvas.setLocked(locked);
}

function ColorEditCanvas() {
    var canvas = document.getElementById("coloredit");
    var g = canvas.getContext('2d');
    var size = canvas.width - 16;
    var colors = null;
    var selected;
    var prevX;
    var me = this;
    new Mouser(canvas, 
       function(x,y) {
           for (var i = 0; i < paletteInEditor.divisionPoints.length; i++) {
              var p = 8 + Math.floor(paletteInEditor.divisionPoints[i] * size);
              if ((x > p-2 && x < p+3) || (y > 48 && (x > p-6 & x < p+7))) {
                  prevX = x;
                  if (i != selected) {
                      me.select(i);
                      me.draw();
                  }
                  return i > 0 && i < paletteInEditor.divisionPoints.length - 1;
              }
           }
           return false;
       },
       function (x,y) {
            var position = 8 + Math.floor(paletteInEditor.divisionPoints[selected] * size);
            var left = 8 + Math.floor(paletteInEditor.divisionPoints[selected-1] * size);
            var right = 8 + Math.floor(paletteInEditor.divisionPoints[selected+1] * size);
            var change = x - prevX;
            prevX = x;
            var newposition = Math.min(right-10,Math.max(left+10,position + change));
            if (newposition != position) {
                paletteInEditor.divisionPoints[selected] = (newposition-8)/size;
                colors = null;
                newColorsInEditor();
            }
       },
       function () {
               if (!updateDuringDrag)
                   palettePreview.redraw();
           }
     );
     canvas.ondblclick = function(evt) {
        if (evt.button != 0)
           return;
        var r = canvas.getBoundingClientRect();
        var x = evt.clientX - r.left;
        var y = evt.clientY - r.top;    
        if (y > 50)
           return;
        for (var i = 1; i < paletteInEditor.divisionPoints.length; i++) {
            var leftDP = paletteInEditor.divisionPoints[i-1];
            var rightDP = paletteInEditor.divisionPoints[i];
            var left = 8 + Math.floor( leftDP * size);
            var right = 8 + Math.floor(rightDP * size);
            if (x > left+9 && x < right-9) {
                var divisionPt = (x-8)/size;
                var t = (divisionPt - leftDP) / (rightDP - leftDP);
                var leftCol = paletteInEditor.divisionColors[i-1];
                var rightCol = paletteInEditor.divisionColors[i];
                var col = [ (1-t)*leftCol[0]+t*rightCol[0], (1-t)*leftCol[1]+t*rightCol[1], (1-t)*leftCol[2]+t*rightCol[2] ];
                paletteInEditor.divisionPoints.splice(i,0,divisionPt);
                paletteInEditor.divisionColors.splice(i,0,col);
                me.select(i);
                me.draw();
                break;
            }
        }
     };
     this.addColorStop = function() {
         var left = selected - 1;
         var right = selected + 1; 
         while (left >= 0 || right < paletteInEditor.divisionPoints.length) {
                // try to find room alternately to left and to right of selected stop
            if (placeColorStopBetween(right-1,right))
               return;
            right++;
            if (placeColorStopBetween(left,left+1))
                return;
            left--;
         }
         alert("Sorry, can't find room for another color stop.");
         function placeColorStopBetween( a, b ) {  // b - a = 1
             if (a < 0 || b >= paletteInEditor.divisionPoints.length)
                return false;
             var leftDP = paletteInEditor.divisionPoints[a];
             var rightDP = paletteInEditor.divisionPoints[b];
             if ( (rightDP-leftDP)*size > 19) {
                var divisionPt = (leftDP + rightDP)/2;
                var leftCol = paletteInEditor.divisionColors[a];
                var rightCol = paletteInEditor.divisionColors[b];
                var col = [ (leftCol[0]+rightCol[0])/2, (leftCol[1]+rightCol[1])/2, (leftCol[2]+rightCol[2])/2 ];
                paletteInEditor.divisionPoints.splice(b,0,divisionPt);
                paletteInEditor.divisionColors.splice(b,0,col);
                me.select(b);
                me.draw();
                return true;
             }
             return false;
         }
     };
     this.deleteColorStop = function() {
         if (selected > 0 && selected < paletteInEditor.divisionPoints.length-1) {
             paletteInEditor.divisionPoints.splice(selected,1);
             paletteInEditor.divisionColors.splice(selected,1);
             me.select(selected-1);
             colors = null;
             newColorsInEditor();
             me.draw();
         }
     };
     this.setLocked = function(lock,onInstall) {
         leftRightColorsLocked = lock;
         if (onInstall) {
             saveRightColorWhileLocked = null;
             return;
         }
         var leftCol = paletteInEditor.divisionColors[0];
         var rightCol = paletteInEditor.divisionColors[paletteInEditor.divisionColors.length-1];
         if (leftRightColorsLocked) {
            var save = [];
            save.push(rightCol[0]);
            save.push(rightCol[1]);
            save.push(rightCol[2]);
            rightCol[1] = leftCol[1];
            rightCol[2] = leftCol[2];
            if (paletteInEditor.colorType == "HSB") {
                var n = Math.floor(rightCol[0]);
                rightCol[0] = n + (leftCol[0] - Math.floor(leftCol[0]));
            }
            else {
                rightCol[0] = leftCol[0];
            }
            colors = null;
            newColorsInEditor();
            if (selected == paletteInEditor.divisionColors.length-1)
               me.select(selected);
            saveRightColorWhileLocked = save;
         }
         else if (saveRightColorWhileLocked != null) {
            rightCol[0] = saveRightColorWhileLocked[0];
            rightCol[1] = saveRightColorWhileLocked[1];
            rightCol[2] = saveRightColorWhileLocked[2];
            saveRightColorWhileLocked = null;
            colors = null;
            newColorsInEditor();
            if (selected == paletteInEditor.divisionColors.length-1)
               me.select(selected);
         }
     };
     this.select = function(colorIndex) {
         selected = colorIndex;
         if (paletteInEditor.colorType == "HSB") { 
            var n = Math.floor(paletteInEditor.divisionColors[selected][0]); 
            colorSliders[0].reset(n,n+1,paletteInEditor.divisionColors[selected][0]);
            colorSliders[0].canvas.title = "Drag the slider to set the hue of the selected color stop to a value in the range " +
                                            n + " to " + (n+1) + ". Values outside this range can be set in the textbox.";
         }
         else {
             colorSliders[0].setValue(paletteInEditor.divisionColors[selected][0]);
         }
         colorSliders[1].setValue(paletteInEditor.divisionColors[selected][1]);
         colorSliders[2].setValue(paletteInEditor.divisionColors[selected][2]);
         document.getElementById("deletecolorstop").disabled = !(selected > 0 && selected < paletteInEditor.divisionPoints.length-1);
     };
     this.getSelected = function() {
        return selected;
     };
     this.colorsChanged = function() {
        colors = null;
     };
     this.draw = function() {
         g.fillStyle = "#e8e8e8";
         g.fillRect(0,0,canvas.width,canvas.height);
         if (colors == null)
             colors = paletteInEditor.makeCanvasColors(size,0);
         for (var i = 0; i < size; i++) {
             g.fillStyle = colors[i];
             g.fillRect(8+i,3,1,40);
         }
         g.lineWidth = 2;
         g.strokeRect(7,2,size+2,41);
         for (var i = 0; i < paletteInEditor.divisionPoints.length; i++) {
            var x = 8 + Math.floor(paletteInEditor.divisionPoints[i] * size);
            var c = paletteInEditor.divisionColors[i]; 
            c = paletteInEditor.toRGB(c[0],c[1],c[2]); 
            c = "rgb(" + c[0] + "," + c[1] + "," + c[2] + ")";
            if ( i == selected ) {
                g.fillStyle = "black";
                g.fillRect(x-3,1,6,42);
                g.fillRect(x-7,51,14,29);
                g.fillStyle = "lightgray";
                g.fillRect(x-2,2,4,40);
                g.fillRect(x-6,52,12,27);
                g.fillStyle = c;
                g.fillRect(x-1,3,2,38);
            }
            g.fillStyle = "black";
            g.fillRect(x-1,43,2,10);
            g.fillRect(x-5,53,10,25);
            g.fillStyle = c;
            g.fillRect(x-4,54,8,23);
         }
     };
}

function PalettePreview() {
   var previewIterationCounts;
   var previewRect;
   var preview = document.getElementById("preview");
   var g = preview.getContext("2d");
   if (canvas.width >= canvas.height) {
       var h = Math.round(canvas.height/canvas.width * (preview.height-2));
       previewRect = { left:1, top: 1+Math.floor((preview.height-h)/2), width: preview.width-2, height: h };
   }
   else {
       var w = Math.round(canvas.width/canvas.height * (preview.width-2));
       previewRect = { left: 1+Math.floor((preview.width-w)/2), top: 1, width: w, height: preview.height-2 };
   }
   var previewCounts = new Array(previewRect.height);
   var desiredRow = new Array(previewRect.height+1);
   var currentRow = new Array(previewRect.height);
   var i,j;
   for (i = 0; i < previewRect.height; i++) {
       desiredRow[i] = Math.floor( i * canvas.height/previewRect.height );
       currentRow[i] = -1;
   }
   desiredRow[previewRect.height+1] = canvas.height;
   for (i = 0; i < previewRect.height; i++) {
       for (j = desiredRow[i]; j < desiredRow[i+1]; j++) {
           if (savedIterationCounts[j]) {
               currentRow[i] = j;
               previewCounts[i] = new Int32Array(previewRect.width);
               for (var k = 0; k < previewRect.width; k++) {
                   var index = Math.floor( k / previewRect.width * savedIterationCounts[j].length );
                   previewCounts[i][k] = savedIterationCounts[j][index];
               }
               break;
           }
       }
   }
   this.update = function(newRowNumber, newRowCounts) {
      for (var k = 0; k < previewRect.height; k++) { 
          if (newRowNumber < desiredRow[k+1]) { 
             if (currentRow[k] == -1 || (currentRow[k] != desiredRow[k] && newRowNumber < currentRow[k])) { 
                 currentRow[k] = newRowNumber;
                 newColors(k,newRowCounts);
             }
             break;
          }
      }
   };
   function newColors(row,counts) {
       previewCounts[row] = new Int32Array(previewRect.width);
       for (var k = 0; k < previewRect.width; k++) {
           var index = Math.floor( k / previewRect.width * counts.length );
           previewCounts[row][k] = counts[index];
       }
       showRow(row);
   }
   function showRow(row) { 
       for (var k = 0; k < previewRect.width; k++) {
           if (previewCounts[row][k] == -1)
               g.fillStyle="black";
           else {
               var index = previewCounts[row][k] % paletteLengthInEditor;
               g.fillStyle = colorsInEditor[index];
           }
           g.fillRect(k+previewRect.left,row+previewRect.top,1,1);
       }
   }
   function drawBG() {
      g.fillStyle="#e8e8e8";
      g.fillRect(0,0,preview.width,preview.height);
      g.lineWidth = 1;
      g.strokeStyle = "black";
      g.strokeRect( previewRect.left-0.5, previewRect.top-0.5, previewRect.width+1, previewRect.height );
   }
   this.redraw = function() {
      drawBG();
      for (var i = 0; i < previewCounts.length; i++) {
         if (previewCounts[i])
             showRow(i);
      }
   };
}

function Histogram() {
   var canvas = document.getElementById("histogram");
   var histogramWidth = canvas.width - 15;
   var histogramHeight = canvas.height - 15;
   var histogramCounts = new Int32Array(maxIterations+1);
   for (var j = 0; j < savedIterationCounts.length; j++) {
       if (savedIterationCounts[j]) {
          var counts = savedIterationCounts[j];
          for (var k = 0; k < counts.length; k++)
              histogramCounts[counts[k]] ++;
       }
   }
   this.update = function(newcounts) {
       for (var i = 0; i < newcounts.length; i++) {
           histogramCounts[newcounts[i]] ++;
       }
       redraw();
   };
   function redraw() {
       var g = canvas.getContext("2d");
       g.fillStyle = "white";
       g.fillRect(0,0,canvas.width,canvas.height);
       g.lineWidth = 2;
       g.strokeStyle = "red";
       g.beginPath();
       g.moveTo(8,5);
       g.lineTo(8,canvas.height-8);
       g.lineTo(canvas.width-5,canvas.height-8);
       g.stroke();
       var i,a,b;
       var maxct = 0;
       for (i = 1; i < histogramCounts.length; i++)
           maxct = Math.max(histogramCounts[i],maxct);
       if (maxct == 0)
           return;
       g.lineWidth=1;
       g.strokeStyle="black";
       g.beginPath();
       for (i = 1; i < histogramCounts.length; i++) {
           if (histogramCounts[i] > 0) {
               a = Math.round(i/histogramCounts.length * histogramWidth) + 10.5;
               b = Math.ceil(histogramCounts[i]/maxct * histogramHeight) + 0.5; 
               g.moveTo(a,canvas.height-10);
               g.lineTo(a,canvas.height-10-b);
           }
       }
       g.stroke();
   }
   redraw();
}

function SliderAndInput(canvas,textbox,min,max,val,integerOnly,allowOutOfRange) {
    this.canvas = canvas;
    this.textbox = textbox;
    this.min = (typeof min == "number")? min : 0.0;    
    this.max = (typeof max == "number")? max : this.min + 100.0;    
    this.value = (typeof val == "number")? val : this.min;
    this.integerOnly = (typeof integerOnly == "undefined")? false : integerOnly;
    this.allowOutOfRange = (typeof allowOutOfRange == "undefined")? false : allowOutOfRange;
    this.allowLessThanMin = false;
    this.g = this.canvas.getContext("2d");
    this.g.translate(0,-8);  // fudge for resuing old code
    this.size = this.canvas.width - 25;
    if (this.allowOutOfRange)
       this.size -= 20;
    this.setTabLeft();
    this.valueToTextbox();
    this.draw();
    this.onchange = null;
    var me = this;
    var valueInTextbox, savedValueWhileEditing, saveTitle;
    textbox.style.color = "black";
    textbox.style.backgroundColor = "white";
    textbox.style.padding = "2px";
    textbox.onfocus = function() { 
        valueInTextbox = savedValueWhileEditing = this.value; 
        textbox.style.backgroundColor="#d8ffd8";
        saveTitle = textbox.title;
        textbox.title = "Editing slider value. Press return or move to another input box to apply the new value, if legal.";
    };
    textbox.onblur = function() { 
        textbox.style.backgroundColor="white";
        if (checkTextbox())
            me.setValue(valueInTextbox);
        else
            me.setValue(savedValueWhileEditing);
        if (!updateDuringDrag)
            palettePreview.redraw();
        me.valueToTextbox();
        textbox.title = saveTitle;
        textbox.style.backgroundColor = "white";
    };
    textbox.oninput = function() { 
        checkTextbox();
    };
    textbox.onkeydown = function(evt) {
       if (evt.keyCode == 13 && checkTextbox()) {
          me.setValue(valueInTextbox);
          valueInTextbox = me.value;
          if (!updateDuringDrag)
              palettePreview.redraw();
       }
    };
    function checkTextbox() {
       var val = Number(textbox.value);
       if (isNaN(val)) {
           textbox.style.backgroundColor = "#ff9090";
           textbox.title = "The value in the input box is not a number!";
           return false;
       }
       if (me.integerOnly)
          val = Math.round(val);
       if (val < 0 || (val < me.min && !me.allowLessThanMin) || (val > me.max && !me.allowOutOfRange)) {
           textbox.style.backgroundColor = "#ffff90";
           textbox.title = "The value in the textbox is not in the legal range for the slider";
           return false;
       }
       valueInTextbox = val;
       textbox.style.backgroundColor="#d8ffd8";
       textbox.title = "Editing slider value. Press return or move to another input box to apply the new value, if legal.";
       return true;
    }
    var offset;
    new Mouser(this.canvas,
        function(x,y) {
           if (y < 23 && x > me.tabLeft - 2 && x < me.tabLeft + 22) {
              offset = x - (me.tabLeft+10);
              return true;
           }
           else if (y > 20 && x > 14 && x < me.canvas.width - 5) {
              var val = (x - 15)/me.size * (me.max-me.min) + me.min;
              me.setValue(val);
              return false;
           }
        },
        function(x,y) {
           x = x - offset;
           var val = (x - 15)/me.size * (me.max-me.min) + me.min;
           if (val > me.max)
              val = me.max;
           if (val < me.min)
              val = me.min;
           me.setValue(val); 
        },
        function() {
            if (!updateDuringDrag)
                palettePreview.redraw();
        }
    );
}
SliderAndInput.prototype.setAllowOutOfRange = function( allow, allowLessThanMin ) {
    if (this.allowOutOfRange == allow && this.allowLessThanMin == allowLessThanMin)
       return;
    this.allowOutOfRange = allow;
    if (allowLessThanMin)
        this.allowLessThanMin = true;
    else
        this.allowLessThanMin = false;
    this.size = this.canvas.width - 25;
    if (this.allowOutOfRange)
       this.size -= 20;
    this.setTabLeft();
    this.draw();
};
SliderAndInput.prototype.reset = function(min,max,val) {
//    if (this.min != min || this.max != max) {
        this.min = min;
        this.max = max;
        this.value = "none";
        this.setValue(val);
//    }
};
SliderAndInput.prototype.setValue = function(val) { 
    var newval = this.integerOnly? Math.round(val) : val;
    if ( ! this.allowOutOfRange ) {
        newval = Math.min(this.max,newval);
    }
    if ( ! this.allowOutOfRange ) {
        newval = Math.max(this.min,newval);
    }
    newval = Math.max(0,newval);
    if (this.value != newval) { 
        this.value = newval;
        this.valueToTextbox();
        this.changed();
    }
};
SliderAndInput.prototype.valueToTextbox = function() {
    if (this.integerOnly)
        this.textbox.value = "" + this.value;
    else
        this.textbox.value = this.value.toPrecision(3);
};
SliderAndInput.prototype.setTabLeft = function() {
   if (this.value > this.max  || this.value < this.min)
      this.tabLeft = this.size + 20;
   else
      this.tabLeft = 5 + Math.floor((this.value - this.min)/(this.max - this.min) * this.size);
};
SliderAndInput.prototype.changed = function() {
   this.setTabLeft();
   this.draw();
   if (this.onchange)
      this.onchange(this.value);
};
SliderAndInput.prototype.draw = function() {
    var graphics = this.g;
    graphics.save();
    graphics.fillStyle = "#e8e8e8";
    graphics.fillRect(0,8,this.canvas.width,this.canvas.height);
    graphics.beginPath();
    graphics.moveTo(15, 35);
    graphics.lineTo(15 + this.size, 35);
    graphics.strokeStyle = "black";
    graphics.lineWidth = 10;
    graphics.lineCap = "round";
    graphics.stroke();
    graphics.strokeStyle = "gray";
    graphics.lineWidth = 7.5;
    graphics.lineCap = "butt";
    graphics.stroke();
    graphics.beginPath();
    graphics.moveTo(15, 35);
    graphics.lineTo(Math.min(this.tabLeft + 10,15+this.size), 35);
    graphics.strokeStyle = "lightgray";
    graphics.stroke();
    graphics.fillStyle = "black";
    graphics.lineWidth = 1;
    graphics.beginPath();
    graphics.moveTo(this.tabLeft + 10, 36);
    graphics.lineTo(this.tabLeft + 20, 30);
    graphics.lineTo(this.tabLeft + 20, 10);
    graphics.lineTo(this.tabLeft, 10);
    graphics.lineTo(this.tabLeft, 30);
    graphics.closePath();
    graphics.fillStyle = "#9090FF";
    graphics.fill();
    graphics.strokeStyle = "#000099";
    graphics.stroke();
    graphics.beginPath();
    graphics.moveTo(this.tabLeft + 4.5, 14);
    graphics.lineTo(this.tabLeft + 4.5, 26);
    graphics.moveTo(this.tabLeft + 9.5, 14);
    graphics.lineTo(this.tabLeft + 9.5, 26);
    graphics.moveTo(this.tabLeft + 14.5, 14);
    graphics.lineTo(this.tabLeft + 14.5, 26);
    graphics.stroke();
    graphics.beginPath();
    graphics.moveTo(this.tabLeft + 6, 16);
    graphics.lineTo(this.tabLeft + 6, 28);
    graphics.moveTo(this.tabLeft + 11, 16);
    graphics.lineTo(this.tabLeft + 11, 28);
    graphics.moveTo(this.tabLeft + 16, 16);
    graphics.lineTo(this.tabLeft + 16, 28);
    graphics.strokeStyle = "white";
    graphics.stroke();
    graphics.restore();
};



//-------------------------------------------------------------------------------------------

function currentExampletoXML() {
    var offset = Math.round(paletteOffsetFraction * paletteLength);
    return "<?xml version='1.0'?>\n<mandelbrot_settings_2>\n" +
            "<image_size width='" + canvas.width + "' height='" + canvas.height + "'/>\n" +
            "<limits>\n   <xmin>" + xmin_requested.toString() + "</xmin>\n" +
            "   <xmax>" + xmax_requested.toString() + "</xmax>\n" +
            "   <ymin>" + ymin_requested.toString() + "</ymin>\n" +
            "   <ymax>" + ymax_requested.toString() + "</ymax>\n</limits>\n" +
            palette.toXMLString() +
            "<palette_mapping length='" + paletteLength + "' offset='" + offset + "'/>\n" +
            "<max_iterations value='" + maxIterations + "'/>\n" +
            "</mandelbrot_settings_2>\n";
}

function installExampleFromXML(xmlString, recordUndo, respectSize, dontShowError) {
    var oldXML = currentXML;
    stopJob();
    try {
      var parser = new DOMParser();
      var doc = parser.parseFromString(xmlString,"text/xml").documentElement;
      var width,height,xmin,xmax,ymin,ymax,colors,length,offset,iterations;
      if (respectSize) {
          var size = doc.getElementsByTagName("image_size");
          if (size == 0) {
              respectSize = false;
          }
          else {
              width = Number(size[0].getAttribute("width"));
              height = Number(size[0].getAttribute("height"));
              if (isNaN(width) || width > 7680 || width < 64 || isNaN(height) || height > 7680 || height < 64) {
                   respectSize = false;
              }
          }
      }
      xmin = doc.getElementsByTagName("xmin").item(0).textContent;
      xmax = doc.getElementsByTagName("xmax").item(0).textContent;
      ymin = doc.getElementsByTagName("ymin").item(0).textContent;
      ymax = doc.getElementsByTagName("ymax").item(0).textContent;
      colors = Palette.fromXML( doc.getElementsByTagName("palette").item(0));
      var map = doc.getElementsByTagName("palette_mapping");
      if (map.length > 0) {
          length = Number(map.item(0).getAttribute("length"));
          offset = Number(map.item(0).getAttribute("offset"));
      }
      else {
          length = 250;
          offset = 0;
      }
      iterations = Number(doc.getElementsByTagName("max_iterations").item(0).getAttribute("value"));
      xmin = new BigDecimal(xmin);
      xmax = new BigDecimal(xmax);
      ymin = new BigDecimal(ymin);
      ymax = new BigDecimal(ymax);
      if (isNaN(length) || isNaN(offset) || isNaN(iterations)) {
          throw "Bad number.";
      }
      if (length == 0) {
          length = iterations;
      }
      palette = colors;
      maxIterations = Math.round(iterations);
      if ([25,50,100,250,500,1000,2500,5000,10000,25000,50000].indexOf(maxIterations) < 0) {
          document.getElementById("custommaxiter").style.display = "inline";
          document.getElementById("maxIterSelect").value = "Custom";
          document.getElementById("maxiterinput").value = "" + iterations;
      }
      else {
          document.getElementById("custommaxiter").style.display = "none";
          document.getElementById("maxIterSelect").value = "" + maxIterations;
      }
      length = Math.round(length);
      if (length == 0) {
         stretchPalette = true;
         document.getElementById("paletteLengthSelect").value = "Match MaxIter";
         document.getElementById("custompallen").style.display = "none";
      }
      else  {
          stretchPalette = false;
          fixedPaletteLength = length;
          if ([50,100,250,500,1000,2500,5000].indexOf(length) < 0) {
             document.getElementById("custompallen").style.display = "inline";
             document.getElementById("paletteLengthSelect").value = "Custom";
             document.getElementById("palleninput").value = "" + length;
          }
          else {
             document.getElementById("custompallen").style.display = "none";
             document.getElementById("paletteLengthSelect").value = "" + length;
          }
      }
      paletteOffsetFraction = offset/length;
      paletteOffsetFraction = paletteOffsetFraction - Math.floor(paletteOffsetFraction);
      paletteOffsetFraction = Math.round(10000*paletteOffsetFraction)/10000;
      if (offset == 0) {
           document.getElementById("custoffset").style.display = "none";
           document.getElementById("paletteOffsetSelect").value = "0";
      }
      else {
           document.getElementById("custoffset").style.display = "inline";
           document.getElementById("paletteOffsetSelect").value = "Custom";
           var current = 100*paletteOffsetFraction;
           document.getElementById("offsetinput").value = (current == Math.round(current))? current : current.toPrecision(3);
      }
      createPaletteColors();
      if (respectSize) {
         setImageSize(width,height);
         var val = width + " " + height;
         if (["640 480", "800 600", "1024 768", "1600 1200", "1920 1080", "1920 1200", "2560 1440", "2880 1800", "3840 1080", "3840 2160", "5120 1440", "7680 4320"].indexOf(val) < 0) {
             document.getElementById("imagesize").value = "Custom";
             document.getElementById("customsize").style.display = "inline";
             document.getElementById("customwidth").value = "" + width;
             document.getElementById("customheight").value = "" + height;
         }
         else {
             document.getElementById("imagesize").value = val;
             document.getElementById("customsize").style.display = "none";
         }
      }
      setLimits(xmin,xmax,ymin,ymax,false);
      startJob();
      if (recordUndo && undoList) {
          addUndoItem("Import Example", oldXML, currentXML);
      }
      return null;
    }
    catch (e) {
        var error =  "Illegal data in XML example string: " + e;
        if ( ! dontShowError )
           document.getElementById("status").innerHTML = error;
        return error;
    }
}

function installExampleWithAjax(url) {
    document.getElementById("status").innerHTML = "Trying to Fetch example from " + url;
    var ajaxTimeout;
    var ajax = new XMLHttpRequest();
    ajax.open("GET",url);
    ajax.overrideMimeType("text/plain");
    ajax.addEventListener("error",function() {
        clearTimeout(ajaxTimeout);
        document.getElementById("status").innerHTML = "Error: Example could not be loaded from " + url;
    });
    ajax.addEventListener("load",function() {
        clearTimeout(ajaxTimeout);
        installExampleFromXML(ajax.responseText, false, false);
    });
    ajaxTimeout = setTimeout(function() {
        ajax.abort();
        document.getElementById("status").innerHTML = "Error: Request timed out while trying to load from " + url;
    }, 10000);
    try {
       ajax.send();
    } catch(e) {
        clearTimeout(ajaxTimeout);
        document.getElementById("status").innerHTML = "Error while trying to send request for example: " + url;
    }
}

function importXML() {
    document.getElementById("XMLtextinput").value = "";
    document.getElementById("xmlimportbg").style.display = "block";
    document.getElementById("xmlimport").style.display = "block";
    document.addEventListener("keydown", doKey, false);
    document.getElementById("cancelXMLimport").onclick = dismiss;
    document.getElementById("applyXMLimport").onclick = apply;
    document.getElementById("grabcurrent").onclick = grabCurrent;
    function apply() {
        var text = document.getElementById("XMLtextinput").value.trim();
        if (text == "") {
            dismiss();
        }
        else {
            var errorMsg = installExampleFromXML(text,true,false);
            if (errorMsg == null)
               dismiss();
            else
               alert("Error in input: " + errorMsg);
        }
    }
    function dismiss() {
        document.getElementById("xmlimportbg").style.display = "none";
        document.getElementById("xmlimport").style.display = "none";
        document.removeEventListener("keydown", doKey, false);
    }
    function grabCurrent() {
        document.getElementById("XMLtextinput").value = currentXML;
    }
    function doKey(evt) {
        var code = evt.keyCode;
        if (code == 27) {
            dismiss();
        }
    }
}

function checkForExample() {
    var ex = window.location.search.match("^\\?ex=([a-zA-Z0-9/.%_+-]+)");
    if (ex) {
       stopJob();
       installExampleWithAjax(decodeURIComponent(ex[1]), false);
    }
}

function init() {
    try {
        canvas = document.getElementById("canvas");
        graphics = canvas.getContext("2d");
        OSC = document.createElement("canvas");
        OSC.width = canvas.width;
        OSC.height = canvas.height;
        OSG = OSC.getContext("2d", { willReadFrequently: true });
    }
    catch (e) {
         document.getElementById("message").innerHTML =
             "Sorry, this page requires canvas support, which is not available in your browser.";
         return;
    }
    if (! window.Worker ) {
         document.getElementById("message").innerHTML =
             "Sorry, this page requires WebWorker support, which is not available in your browser.";
         return;
    }
    palette = new Palette();
    document.getElementById("restoreButton").onclick = setDefaults;
    document.getElementById("stop").onclick = stopJob;
    document.getElementById("interlaced").onchange = changeInterlaced;
    document.getElementById("interlaced").checked = interlaced;
    document.getElementById("imagesize").onchange = changeImageSize;
    document.getElementById("applysize").onclick = doCustomSize;
    try {
        let item = localStorage.getItem("mandelbrotLocalOrRemote");
        if (item == "remote") {
            document.getElementById("remote").checked = true;
        } else {
            document.getElementById("local").checked = true;
        }
    }
    catch(e) {
    }
    try {
      var ct = Number(localStorage.getItem("mandelbrotWorkerCount" + (document.getElementById("local").checked ? "local" : "remote")));
    //   console.log("workers get (init) " + (document.getElementById("local").checked ? "local" : "remote") + " " + ct);
      if (!isNaN(ct) && ct > 0) {
          workerCount = ct;
      }
    }
    catch(e) {
    }
    document.getElementById("threadCountSelect").value = "" + workerCount;
    document.getElementById("threadCountSelect").onchange = changeWorkerCount;
    document.getElementById("maxIterSelect").onchange = changeMaxIterations;
    document.getElementById("maxiterapply").onclick = doCustomMaxIterations;
    document.getElementById("paletteLengthSelect").onchange = changePaletteLength;
    document.getElementById("pallenapply").onclick = doCustomPaletteLength;
    document.getElementById("paletteOffsetSelect").onchange = changePaletteOffset;
    document.getElementById("offsetapply").onclick = doApplyCustomPaletteOffset;
    document.getElementById("standardPaletteButton").onclick = doApplyStandardPalette;
    document.getElementById("standardPaletteSelect").value = "EarthAndSky";
    document.getElementById("showpaletteedit").onclick=showPaletteEditor;
    document.getElementById("secondpass").checked = true;
    document.getElementById("secondpass").onchange = changeSecondPass;
    document.getElementById("highPrecision").checked = false;
    document.getElementById("highPrecision").onchange = changeHighPrecision;
    document.getElementById("local").onchange = changeLocalOrRemote;
    document.getElementById("remote").onchange = changeLocalOrRemote;
    document.getElementById("zoomInAmount").value = "0.1";
    document.getElementById("zoomOutAmount").value = "10";
    document.getElementById("zoomin").onclick = doZoomIn;
    document.getElementById("zoomout").onclick = doZoomOut;
    document.getElementById("importXML").onclick = importXML;
    document.getElementById("undo").onclick = doUndo;
    document.getElementById("undo").disabled = true;
    document.getElementById("redo").onclick = doRedo;
    document.getElementById("redo").disabled = true;
    setUpDragging();
    setUpArrowKeys();
    changeWorkerCount(); // has to be done before setDefaults
    setDefaults();
    checkForExample();
    undoList = [];
    undoCount = 0;
    let localOrRemote = document.getElementById("local").checked ? "local" : "remote";
    if (localOrRemote == "remote") {
        checkRemoteCanComputeMB();
    }
}

var arrowTimeout;
function setUpArrowKeys() {
    document.addEventListener("keydown", function(event) {
        // quit when in a text box
        if (event.target.nodeName === "INPUT" && event.target.type === "text") {
            return;
        }
        switch (event.key) {
            case "ArrowLeft":
            case "ArrowRight":
            case "ArrowUp":
            case "ArrowDown":
            case "PageDown":
            case "PageUp":
                break;
            default:
                // quit when this doesn't handle the key event
                return;
        }

        // Cancel the default action to avoid it being handled twice
        event.preventDefault();
        // prevent too many of these slowing down response
        if (arrowTimeout) {
            return;
        }
        stopJob();

        const shiftLR = Math.max(1, Math.round(canvas.width/32));
        const shiftUD = Math.max(1, Math.round(canvas.height/32));
        switch (event.key) {
            case "ArrowLeft":
                doZoomInOnRect(-shiftLR, 0, canvas.width, canvas.height, false);
                break;

            case "ArrowRight":
                doZoomInOnRect(shiftLR, 0, canvas.width, canvas.height, false);
                break;

            case "ArrowUp":
                doZoomInOnRect(0, -shiftUD, canvas.width, canvas.height, false);
                break;

            case "ArrowDown":
                doZoomInOnRect(0, shiftUD, canvas.width, canvas.height, false);
                break;

            case "PageUp":
                doZoomInOnRect(-shiftLR, -shiftUD, canvas.width + shiftLR*2, canvas.height + shiftUD*2, false);
                break;

            case "PageDown":
                doZoomInOnRect(shiftLR, shiftUD, canvas.width - shiftLR*2, canvas.height - shiftUD*2, false);
                break;
        }

        arrowTimeout = setTimeout(function () {
            arrowTimeout = null;
            startJob();
        }, 0);
    });
}
</script>
</head>
<body onload="init()">

<noscript><b>Sorry, this page requires JavaScript.</b></noscript>

<h2>Explore the <a href=MB.html>Mandelbrot Set</a></h2>
<p>
Use page down and page up to zoom in and out, or the arrow keys to pan.  Double-clicking the image zooms 2X, or drag on it to draw a box.  For more info, instructions, and examples, <a href="MB-info.html">click here</a>.
</p><p>
Based on a browser-only Mandelbrot Set viewer by <a href=http://math.hws.edu/eck/index.html>David Eck</a>,
this revised version can run calculations on a web server installed locally on a PC, in Docker, or on a Kubernetes cluster.
By default it runs only in the browser; if the web server is installed then selecting "Remote" below will run calculations on the remote web server.
The GitHub repository is <a href="https://github.com/wpwoodjr/Mandelbrot-for-Docker-and-Kubernetes/tree/master/mb-kubernetes">here</a>.
</p><p>
Calculating the Mandelbrot Set is very computationally intensive, however it is parallelizable.
Increasing the number of "Workers" below brings in more CPU threads to calculate rows of the image. 
<br>
To see, click on <a href="MB.html?ex=java%2FMandelbrotSettings%2FMandelbrotSettings_25_May_2009_3.xml">this link</a>, 
then vary the number of "Workers" to speed it up or slow it down.
When the web server is hosted on Kubernetes, increasing the workers also brings in more pods to speed up the computation.
</p>

<p id="message"></p>

<table border=0 cellpadding=0 cellspacing=0>
<tr valign="top"><td>
<div id="controls">
   <div class="group">
      <p><button id="restoreButton" title="Restore default limits, image size, palette, max iterations.">Restore Defaults</button><button id="stop" style="margin-left:20px" title="Abort the current computation, if any, leaving an incomplete image.">Stop</button></p>
   </div>
   <div class="group">
      <p><label title="If checked, lines in image are computed out of order.  This can give a general idea of the image more quickly."><input type="checkbox" id="interlaced">Interlaced Drawing</label></p>
      <p><label title="If checked, extra computations are done that can often give the completed image a smoother look, by computing two samples per pixel and averaging the resulting colors."><input type="checkbox" id="secondpass">Do a Second Pass</label></p>
      <p><label title="Increasing this can speed up the computation by utilizing more CPUs.">Workers: <select id="threadCountSelect">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7</option>
          <option value="8">8</option>
          <option value="10">10</option>
          <option value="12">12</option>
          <option value="16">16</option>
          <option value="24">24</option>
          <option value="32">32</option>
          <option value="48">48</option>
          <option value="64">64</option>
      </select></label></p>
      <p>
        <label title="Run calculations locally in the browser or on the remote web server.">
        <input type="radio" id="local" name="location" value="local">
        <label for="local">Local</label>
        <input type="radio" id="remote" name="location" value="remote">
        <label for="remote">Remote</label></label>
      </p>
      <p>
        <label title="If checked, high precision arithmetic will be used even when its not needed (slower).">
        <input type="checkbox" id="highPrecision">High Precision</label>
      </p>
   </div>
   <div class="group">
      <p><button id="undo">Undo</button></p>
      <p><button id="redo">Redo</button></p>
   </div>
   <div class="group">
      <p><label title="Width and height of the Mandelbrot picture, in pixels.">Image Size: <select id="imagesize">
          <option value="640 480">640x480</option>
          <option value="800 600">800x600</option>
          <option value="1024 768">1024x768</option>
          <option value="1600 1200">1600x1200</option>
          <option value="1920 1080">1920x1080</option>
          <option value="1920 1200">1920x1200</option>
          <option value="2560 1440">2560x1440</option>
          <option value="2880 1800">2880x1800</option>
          <option value="3840 1080">3840x1080</option>
          <option value="3840 2160">3840x2160</option>
          <option value="5120 1440">5120x1440</option>
          <option value="7680 4320">7680x4320</option>
          <option value="Custom">Custom</option>
      </select></label><span id="customsize" style="display:none"><br><input type="text" maxlength="4" size="4" id="customwidth">x<input type="text" maxlength="4" size="4" id="customheight"> <button id="applysize">Apply</button></span></p>
   </div>
   <div class="group">
      <p><label title="How many steps in the Mandelbrot iteration before giving up and coloring the pixel black.">MaxIterations: <select id="maxIterSelect">
         <option value="25">25</option>
         <option value="50">50</option>
         <option value="100">100</option>
         <option value="250">250</option>
         <option value="500">500</option>
         <option value="1000">1000</option>
         <option value="2500">2500</option>
         <option value="5000">5000</option>
         <option value="10000">10000</option>
         <option value="25000">25000</option>
         <option value="50000">50000</option>
         <option value="Custom">Custom</option>
      </select></label><span id="custommaxiter" style="display:none"><br><input type="text" maxlength="6" size="5" id="maxiterinput"> <button id="maxiterapply">Apply</button></span></p>
   </div>
   <div class="group">
      <p><button id="showpaletteedit" title="Show a popup dialog box that gives greater control over the palette.">Show Palette Editor</button>
            &nbsp;(<a href="palette-editor-info.png" target="_blank" title="Opens a guide to the Palette Editor in a separate tab or window.">info</a>)</p>
      <p><label title="Size of the color palette for pixels outside the Mandebrot set.">PaletteLength: <select id="paletteLengthSelect">
            <option value="Match">= MaxIter</option>
            <option value="50">50</option>
            <option value="100">100</option>
            <option value="250">250</option>
            <option value="500">500</option>
            <option value="1000">1000</option>
            <option value="2500">2500</option>
            <option value="5000">5000</option>
            <option value="Custom">Custom</option>
      </select></label><span id="custompallen" style="display:none"><br><input type="text" maxlength="5" size="4" id="palleninput"><button id="pallenapply">Apply</button></span>
      <p><label title="Offsets the colors within the palette to get a different mapping.">PaletteOffset: <select id="paletteOffsetSelect">
            <option value="0">None</option>
            <option value="0.1">10%</option>
            <option value="0.2">20%</option>
            <option value="0.3">30%</option>
            <option value="0.4">40%</option>
            <option value="0.5">50%</option>
            <option value="0.6">60%</option>
            <option value="0.7">70%</option>
            <option value="0.8">80%</option>
            <option value="0.9">90%</option>
            <option value="Custom">Custom</option>
      </select></label><span id="custoffset" style="display:none"><br><input type="text" id="offsetinput" maxlength="6" size="5"><b>%</b> &nbsp;<button id="offsetapply">Apply</button></span></p>
      <p style="margin-bottom:4px"><button id="standardPaletteButton" title="Click here to apply the palette of colors selected in the popup menu below.">Apply Standard Palette:</button></p>
      <p style="margin-top:0"><select id="standardPaletteSelect" style="margin-left:70px" title="Some palettes of colors to be applied to the Mandelbrot image.  Click the above button to apply the selected palette.">
            <option value="Spectrum">Spectrum</option>
            <option value="EarthAndSky">EarthAndSky</option>
            <option value="Cyclic Fire">Fire</option>
            <option value="Seashore">Seashore</option>
            <option value="TreeColors">Forest</option>
            <option value="Pastels">Pastel Colors</option>
            <option value="Dark">Dark Colors</option>
            <option value="HotAndCold">HotAndCold</option>
            <option value="CyclicGrayscale">Grayscale</option>
            <option value="Random">Random</option>
            <!--<option value="Red/Cyan">Red/Cyan</option>
                <option value="Blue/Gold">Blue/Gold</option>
                <option value="Grayscale">Grayscale</option> -->
      </select></p>
   </div>
   <div class="group">
      <p><button id="zoomin">Zoom in by: </button> <select id="zoomInAmount">
           <option value="0.5">2 X</option>
           <option value="0.2">5 X</option>
           <option value="0.1">10 X</option>
           <option value="0.05">20 X</option>
           <option value="0.02">50 X</option>
           <option value="0.01">100 X</option>
           <option value="0.001">1,000 X</option>
           <option value="0.0001">10,000 X</option>
           <option value="0.00001">100,000 X</option>
      </select></p>
      <p><button id="zoomout">Zoom out by: </button> <select id="zoomOutAmount">
           <option value="2">2 X</option>
           <option value="5">5 X</option>
           <option value="10">10 X</option>
           <option value="20">20 X</option>
           <option value="50">50 X</option>
           <option value="100">100 X</option>
           <option value="1000">1,000 X</option>
           <option value="10000">10,000 X</option>
           <option value="100000">100,000 X</option>
      </select></p>
   </div>
   <div class="group">
      <p><button id="importXML" title="Put up an input box into which you can copy-and-paste the XML code for an example, or get the XML for the current example.">Show XML Import/Export</button></p>
   </div>
</div>
<td>
  <div id="imagediv">
  <p id="status">Image size 800x600.  Idle.</p>
  <p><div id="canvas-holder">
     <canvas id="canvas" width="800" height="600"></canvas>
  </div></p>
  </div>
</td>
</tr>
</table>

<div id="xmlimportbg">
</div>
<div id="xmlimport">
<p>Mandelbrot examples can be coded as "XML documents."<br>
You can copy-and-paste the XML code for an example<br>
into this text input box.  Click "Apply" to import the<br>
example.  Click "Cancel" or press ESC to cancel. The <br>
"Grab Current Example" button loads the XML for the<br>
example that is currently shown in the program; this<br>
allows you to save the example (or even edit it by hand).</p>
<p><button style="margin-left:50px" id="applyXMLimport">Apply</button>
<button style="margin-left:20px" id="cancelXMLimport">Cancel</button>
<button style="margin-left:20px" id="grabcurrent">Grab Current Example</button></p>
<p><textarea rows="21" cols="55" id="XMLtextinput" placeholder="XML code goes here"></textarea>
</div>


<div id="paletteEditor">
<table bgcolor="#E8E8E8" cellpadding=3 cellspacing=0 border=2>
<tr>
   <td colspan=2>
      <table width=620 border=0>
      <tr><td align=left><button id="paletteEditStandardInstall"  
             title="Click this button to replace the palette below with the standard palette that is selected on the right.">Install:</button>
          <select id="paletteEditStandardSelect" title="Click the button on the left to apply this palette in the palette editor.">
            <option value="Spectrum">Spectrum</option>
            <option value="EarthAndSky">EarthAndSky</option>
            <option value="Cyclic Fire">Fire</option>
            <option value="Seashore">Seashore</option>
            <option value="TreeColors">Forest</option>
            <option value="Pastels">Pastel Colors</option>
            <option value="Dark">Dark Colors</option>
            <option value="HotAndCold">HotAndCold</option>
            <option value="CyclicGrayscale">Grayscale</option>
            <option value="Random">Random</option>
          </select></td>
          <td align=right><button id="addcolorstop"
                title="Click to add a color stop to the palette below. The stop will be added next to the currently selected stop, if possible.  You can also add a stop by double-clicking the palette.">Add Color Stop</button>
                <button id="deletecolorstop" title="Click to delete the selected color stop. The first and last stops cannot be deleted.">Delete</button>
                <label style="margin-left:20pt" title="Check this box to lock the colors of the first and last color stops so that the two colors are forced to be the same.">Lock<input type="checkbox" id="lockcolors"></label>
          </td>
      </tr>
      </table>
      <p style="margin: 5px 0 0 0"><canvas id="coloredit" width=630 height=80
           title="Click a color stop to select it.  Drag selected color stop (except for the two at the ends) to move it.  Double-click in a free area to add a color stop."></canvas></p>
      <table border=0 cellpadding=0 style="margin:0 0 0 20px">
       <tr><td><canvas id="colorslider0" width=401 height=40
           title="Drag the slider to set the first color component of the selected color stop to a value in the range 0.0 to 1.0."></canvas></td>
           <td><input type=text id="colorinput0" size=5 title="You can type a value for the first color component here, 0.0 to 1.0 for Red, anything greater than or equal to zero for Hue.">
           <span id="colorlabel0">Hue</span></td>
       </tr>
       <tr><td><canvas id="colorslider1" width=401 height=40
           title="Drag the slider to set the second color component of the selected color stop to a value in the range 0.0 to 1.0."></canvas></td>
           <td><input type=text id="colorinput1" size=5 title="You can type a value for the second color component here, in the range 0.0 to 1.0.">
           <span id="colorlabel1">Saturation</span></td>
       </tr>
       <tr><td><canvas id="colorslider2" width=401 height=40
           title="Drag the slider to set the third color component of the selected color stop to a value in the range 0.0 to 1.0."></canvas></td>
           <td><input type=text id="colorinput2" size=5 title="You can type a value for the third color component here, in the range 0.0 to 1.0.">
           <span id="colorlabel2">Brightness</span></td>
       </tr>
      </table>
   </td>
</tr>
<tr>
   <td valign=top>
      <canvas id="histogram" width=420 height=100
          title="Shows the distribution of iteration counts in the image, from 1 up to MaxIterations.  This can help with selecting a good palette length."></canvas>
      <p style="margin: 3px 0 0 9px"><canvas id="histogrampalette" width=408 height=22 style="display:inline"
          title="Shows how colors from palette will actually be applied to each iteration count, based on palette length and palette offset."></canvas></p>
      <table border=0 cellpadding=0 style="margin:3px 0 0 0">
       <tr><td colspan=2><canvas id="lengthslider" width=420 height=40
           title="Drag the slider to set the palette length.  Slider shows values between 1 and MaxIterations.  You can set an even larger value in the input box below."></canvas></td>
       </tr>
       <tr><td align=right colspan=2>
              <input type=text id="editorlengthinput" size=5 
                  title="You can type a value for the palette length here.  It must be 1 or more.">Palette Length</td>
       </tr>
       <tr><td align=right><canvas id="offsetslider" width=250 height=40
           title="Drag the slider to set the palette offset as a percentage in the range 0 to 100."></canvas></td>
           <td align=left><input type=text id="editoroffsetinput" size=5 title="You can type a value for the palette offset percentage, in the range 0.0 to 100.0.">%&nbsp;&nbsp;Offset</td>
       </tr>
      </table>
   </td>
   <td valign=top width=200>
       <table border=0 cellpadding=0>
         <tr><td><canvas id="preview" width=200 height=200 
               title="A rough copy of the current image, with edited colors applied, giving a preview of the image with the edited palette."></td></tr>
         <tr><td><label title="If this box is unchecked, changes are only applied to the above preview when a drag action end.  Uncheck the box if your computer is having trouble keeping up as you drag a slider or color stop.">
               <input type=checkbox id="updateWhileDraggingCheck" checked>UpdateDuringDrag</label></td></tr>
       </table>
   </td>
</tr>
<tr>
   <td align=center  colspan=2>
   <button id="dismissPaletteEdit" title="Cancel palette editing, leaving colors in the image unchanged.">Cancel</button>
   <button id="revertPaletteEdit" title="Restore the palette to the its state when the palette editor was opened.">Revert Palette</button>
   <button id="applyPaletteEdit"  title="Dismiss the palette editor and apply the palette from the editor to the main image.">Apply and Close</button>
   </td>
</tr>
</table>
</div>

</body>
</html>
